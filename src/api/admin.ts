/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * xngin: Experiments API
 * OpenAPI spec version: 0.9.0
 */
import useSwr from "swr";
import type { Arguments, Key, SWRConfiguration } from "swr";

import useSWRMutation from "swr/mutation";
import type { SWRMutationConfiguration } from "swr/mutation";

import type {
	AddMemberToOrganizationRequest,
	AddWebhookToOrganizationRequest,
	AddWebhookToOrganizationResponse,
	AnalyzeExperimentParams,
	CreateApiKeyResponse,
	CreateDatasourceRequest,
	CreateDatasourceResponse,
	CreateExperimentParams,
	CreateExperimentRequest,
	CreateExperimentResponse,
	CreateOrganizationRequest,
	CreateOrganizationResponse,
	CreateParticipantsTypeRequest,
	CreateParticipantsTypeResponse,
	ExperimentAnalysis,
	ExperimentConfig,
	GetDatasourceResponse,
	GetExperimentAssignmentsResponse,
	GetOrganizationResponse,
	GetParticipantAssignmentResponse,
	HTTPExceptionError,
	HTTPValidationError,
	InspectDatasourceParams,
	InspectDatasourceResponse,
	InspectDatasourceTableResponse,
	InspectParticipantTypesParams,
	InspectParticipantTypesResponse,
	InspectTableInDatasourceParams,
	ListApiKeysResponse,
	ListDatasourcesResponse,
	ListExperimentsResponse,
	ListOrganizationEventsResponse,
	ListOrganizationsResponse,
	ListParticipantsTypeResponse,
	ListWebhooksResponse,
	ParticipantsConfig,
	PowerRequest,
	PowerResponseOutput,
	TokenInfo,
	UpdateDatasourceRequest,
	UpdateOrganizationRequest,
	UpdateParticipantsTypeRequest,
	UpdateParticipantsTypeResponse,
} from "./methods.schemas";

import { orvalFetch } from "@/services/orval-fetch";
import type { ErrorType } from "@/services/orval-fetch";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Returns basic metadata about the authenticated caller of this method.
 * @summary Caller Identity
 */
export const getCallerIdentityUrl = () => {
	return `/v1/m/caller-identity`;
};

export const callerIdentity = async (
	options?: RequestInit,
): Promise<TokenInfo> => {
	return orvalFetch<TokenInfo>(getCallerIdentityUrl(), {
		...options,
		method: "GET",
	});
};

export const getCallerIdentityKey = () => [`/v1/m/caller-identity`] as const;

export type CallerIdentityQueryResult = NonNullable<
	Awaited<ReturnType<typeof callerIdentity>>
>;
export type CallerIdentityQueryError = ErrorType<HTTPExceptionError>;

/**
 * @summary Caller Identity
 */
export const useCallerIdentity = <
	TError = ErrorType<HTTPExceptionError>,
>(options?: {
	swr?: SWRConfiguration<Awaited<ReturnType<typeof callerIdentity>>, TError> & {
		swrKey?: Key;
		enabled?: boolean;
	};
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ?? (() => (isEnabled ? getCallerIdentityKey() : null));
	const swrFn = () => callerIdentity(requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns a list of organizations that the authenticated user is a member of.
 * @summary List Organizations
 */
export const getListOrganizationsUrl = () => {
	return `/v1/m/organizations`;
};

export const listOrganizations = async (
	options?: RequestInit,
): Promise<ListOrganizationsResponse> => {
	return orvalFetch<ListOrganizationsResponse>(getListOrganizationsUrl(), {
		...options,
		method: "GET",
	});
};

export const getListOrganizationsKey = () => [`/v1/m/organizations`] as const;

export type ListOrganizationsQueryResult = NonNullable<
	Awaited<ReturnType<typeof listOrganizations>>
>;
export type ListOrganizationsQueryError = ErrorType<HTTPExceptionError>;

/**
 * @summary List Organizations
 */
export const useListOrganizations = <
	TError = ErrorType<HTTPExceptionError>,
>(options?: {
	swr?: SWRConfiguration<
		Awaited<ReturnType<typeof listOrganizations>>,
		TError
	> & { swrKey?: Key; enabled?: boolean };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListOrganizationsKey() : null));
	const swrFn = () => listOrganizations(requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Creates a new organization.

Only users with an @agency.fund email address can create organizations.
 * @summary Create Organizations
 */
export const getCreateOrganizationsUrl = () => {
	return `/v1/m/organizations`;
};

export const createOrganizations = async (
	createOrganizationRequest: CreateOrganizationRequest,
	options?: RequestInit,
): Promise<CreateOrganizationResponse> => {
	return orvalFetch<CreateOrganizationResponse>(getCreateOrganizationsUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createOrganizationRequest),
	});
};

export const getCreateOrganizationsMutationFetcher = (
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: CreateOrganizationRequest },
	): Promise<CreateOrganizationResponse> => {
		return createOrganizations(arg, options);
	};
};
export const getCreateOrganizationsMutationKey = () =>
	[`/v1/m/organizations`] as const;

export type CreateOrganizationsMutationResult = NonNullable<
	Awaited<ReturnType<typeof createOrganizations>>
>;
export type CreateOrganizationsMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Create Organizations
 */
export const useCreateOrganizations = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(options?: {
	swr?: SWRMutationConfiguration<
		Awaited<ReturnType<typeof createOrganizations>>,
		TError,
		Key,
		CreateOrganizationRequest,
		Awaited<ReturnType<typeof createOrganizations>>
	> & { swrKey?: string };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getCreateOrganizationsMutationKey();
	const swrFn = getCreateOrganizationsMutationFetcher(requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Adds a Webhook to an organization.
 * @summary Add Webhook To Organization
 */
export const getAddWebhookToOrganizationUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}/webhooks`;
};

export const addWebhookToOrganization = async (
	organizationId: string,
	addWebhookToOrganizationRequest: AddWebhookToOrganizationRequest,
	options?: RequestInit,
): Promise<AddWebhookToOrganizationResponse> => {
	return orvalFetch<AddWebhookToOrganizationResponse>(
		getAddWebhookToOrganizationUrl(organizationId),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(addWebhookToOrganizationRequest),
		},
	);
};

export const getAddWebhookToOrganizationMutationFetcher = (
	organizationId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: AddWebhookToOrganizationRequest },
	): Promise<AddWebhookToOrganizationResponse> => {
		return addWebhookToOrganization(organizationId, arg, options);
	};
};
export const getAddWebhookToOrganizationMutationKey = (
	organizationId: string,
) => [`/v1/m/organizations/${organizationId}/webhooks`] as const;

export type AddWebhookToOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof addWebhookToOrganization>>
>;
export type AddWebhookToOrganizationMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Add Webhook To Organization
 */
export const useAddWebhookToOrganization = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof addWebhookToOrganization>>,
			TError,
			Key,
			AddWebhookToOrganizationRequest,
			Awaited<ReturnType<typeof addWebhookToOrganization>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getAddWebhookToOrganizationMutationKey(organizationId);
	const swrFn = getAddWebhookToOrganizationMutationFetcher(
		organizationId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Lists all the webhooks for an organization.
 * @summary List Organization Webhooks
 */
export const getListOrganizationWebhooksUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}/webhooks`;
};

export const listOrganizationWebhooks = async (
	organizationId: string,
	options?: RequestInit,
): Promise<ListWebhooksResponse> => {
	return orvalFetch<ListWebhooksResponse>(
		getListOrganizationWebhooksUrl(organizationId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getListOrganizationWebhooksKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}/webhooks`] as const;

export type ListOrganizationWebhooksQueryResult = NonNullable<
	Awaited<ReturnType<typeof listOrganizationWebhooks>>
>;
export type ListOrganizationWebhooksQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary List Organization Webhooks
 */
export const useListOrganizationWebhooks = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof listOrganizationWebhooks>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!organizationId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListOrganizationWebhooksKey(organizationId) : null));
	const swrFn = () => listOrganizationWebhooks(organizationId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Removes a Webhook from an organization.
 * @summary Delete Webhook From Organization
 */
export const getDeleteWebhookFromOrganizationUrl = (
	organizationId: string,
	webhookId: string,
) => {
	return `/v1/m/organizations/${organizationId}/webhooks/${webhookId}`;
};

export const deleteWebhookFromOrganization = async (
	organizationId: string,
	webhookId: string,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(
		getDeleteWebhookFromOrganizationUrl(organizationId, webhookId),
		{
			...options,
			method: "DELETE",
		},
	);
};

export const getDeleteWebhookFromOrganizationMutationFetcher = (
	organizationId: string,
	webhookId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }): Promise<void> => {
		return deleteWebhookFromOrganization(organizationId, webhookId, options);
	};
};
export const getDeleteWebhookFromOrganizationMutationKey = (
	organizationId: string,
	webhookId: string,
) => [`/v1/m/organizations/${organizationId}/webhooks/${webhookId}`] as const;

export type DeleteWebhookFromOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteWebhookFromOrganization>>
>;
export type DeleteWebhookFromOrganizationMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Delete Webhook From Organization
 */
export const useDeleteWebhookFromOrganization = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	webhookId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteWebhookFromOrganization>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteWebhookFromOrganization>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getDeleteWebhookFromOrganizationMutationKey(organizationId, webhookId);
	const swrFn = getDeleteWebhookFromOrganizationMutationFetcher(
		organizationId,
		webhookId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns the most recent 200 events in an organization.
 * @summary List Organization Events
 */
export const getListOrganizationEventsUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}/events`;
};

export const listOrganizationEvents = async (
	organizationId: string,
	options?: RequestInit,
): Promise<ListOrganizationEventsResponse> => {
	return orvalFetch<ListOrganizationEventsResponse>(
		getListOrganizationEventsUrl(organizationId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getListOrganizationEventsKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}/events`] as const;

export type ListOrganizationEventsQueryResult = NonNullable<
	Awaited<ReturnType<typeof listOrganizationEvents>>
>;
export type ListOrganizationEventsQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary List Organization Events
 */
export const useListOrganizationEvents = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof listOrganizationEvents>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!organizationId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListOrganizationEventsKey(organizationId) : null));
	const swrFn = () => listOrganizationEvents(organizationId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Adds a new member to an organization.

The authenticated user must be part of the organization to add members.
 * @summary Add Member To Organization
 */
export const getAddMemberToOrganizationUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}/members`;
};

export const addMemberToOrganization = async (
	organizationId: string,
	addMemberToOrganizationRequest: AddMemberToOrganizationRequest,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(getAddMemberToOrganizationUrl(organizationId), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(addMemberToOrganizationRequest),
	});
};

export const getAddMemberToOrganizationMutationFetcher = (
	organizationId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: AddMemberToOrganizationRequest },
	): Promise<void> => {
		return addMemberToOrganization(organizationId, arg, options);
	};
};
export const getAddMemberToOrganizationMutationKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}/members`] as const;

export type AddMemberToOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof addMemberToOrganization>>
>;
export type AddMemberToOrganizationMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Add Member To Organization
 */
export const useAddMemberToOrganization = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof addMemberToOrganization>>,
			TError,
			Key,
			AddMemberToOrganizationRequest,
			Awaited<ReturnType<typeof addMemberToOrganization>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getAddMemberToOrganizationMutationKey(organizationId);
	const swrFn = getAddMemberToOrganizationMutationFetcher(
		organizationId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Removes a member from an organization.

The authenticated user must be part of the organization to remove members.
 * @summary Remove Member From Organization
 */
export const getRemoveMemberFromOrganizationUrl = (
	organizationId: string,
	userId: string,
) => {
	return `/v1/m/organizations/${organizationId}/members/${userId}`;
};

export const removeMemberFromOrganization = async (
	organizationId: string,
	userId: string,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(
		getRemoveMemberFromOrganizationUrl(organizationId, userId),
		{
			...options,
			method: "DELETE",
		},
	);
};

export const getRemoveMemberFromOrganizationMutationFetcher = (
	organizationId: string,
	userId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }): Promise<void> => {
		return removeMemberFromOrganization(organizationId, userId, options);
	};
};
export const getRemoveMemberFromOrganizationMutationKey = (
	organizationId: string,
	userId: string,
) => [`/v1/m/organizations/${organizationId}/members/${userId}`] as const;

export type RemoveMemberFromOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof removeMemberFromOrganization>>
>;
export type RemoveMemberFromOrganizationMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Remove Member From Organization
 */
export const useRemoveMemberFromOrganization = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	userId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof removeMemberFromOrganization>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof removeMemberFromOrganization>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getRemoveMemberFromOrganizationMutationKey(organizationId, userId);
	const swrFn = getRemoveMemberFromOrganizationMutationFetcher(
		organizationId,
		userId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Updates an organization's properties.

The authenticated user must be a member of the organization.
Currently only supports updating the organization name.
 * @summary Update Organization
 */
export const getUpdateOrganizationUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}`;
};

export const updateOrganization = async (
	organizationId: string,
	updateOrganizationRequest: UpdateOrganizationRequest,
	options?: RequestInit,
): Promise<unknown> => {
	return orvalFetch<unknown>(getUpdateOrganizationUrl(organizationId), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(updateOrganizationRequest),
	});
};

export const getUpdateOrganizationMutationFetcher = (
	organizationId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: UpdateOrganizationRequest },
	): Promise<unknown> => {
		return updateOrganization(organizationId, arg, options);
	};
};
export const getUpdateOrganizationMutationKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}`] as const;

export type UpdateOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateOrganization>>
>;
export type UpdateOrganizationMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Update Organization
 */
export const useUpdateOrganization = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof updateOrganization>>,
			TError,
			Key,
			UpdateOrganizationRequest,
			Awaited<ReturnType<typeof updateOrganization>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getUpdateOrganizationMutationKey(organizationId);
	const swrFn = getUpdateOrganizationMutationFetcher(
		organizationId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns detailed information about a specific organization.

The authenticated user must be a member of the organization.
 * @summary Get Organization
 */
export const getGetOrganizationUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}`;
};

export const getOrganization = async (
	organizationId: string,
	options?: RequestInit,
): Promise<GetOrganizationResponse> => {
	return orvalFetch<GetOrganizationResponse>(
		getGetOrganizationUrl(organizationId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetOrganizationKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}`] as const;

export type GetOrganizationQueryResult = NonNullable<
	Awaited<ReturnType<typeof getOrganization>>
>;
export type GetOrganizationQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Get Organization
 */
export const useGetOrganization = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getOrganization>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!organizationId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getGetOrganizationKey(organizationId) : null));
	const swrFn = () => getOrganization(organizationId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns a list of datasources accessible to the authenticated user for an org.
 * @summary List Organization Datasources
 */
export const getListOrganizationDatasourcesUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}/datasources`;
};

export const listOrganizationDatasources = async (
	organizationId: string,
	options?: RequestInit,
): Promise<ListDatasourcesResponse> => {
	return orvalFetch<ListDatasourcesResponse>(
		getListOrganizationDatasourcesUrl(organizationId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getListOrganizationDatasourcesKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}/datasources`] as const;

export type ListOrganizationDatasourcesQueryResult = NonNullable<
	Awaited<ReturnType<typeof listOrganizationDatasources>>
>;
export type ListOrganizationDatasourcesQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary List Organization Datasources
 */
export const useListOrganizationDatasources = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof listOrganizationDatasources>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!organizationId;
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled ? getListOrganizationDatasourcesKey(organizationId) : null);
	const swrFn = () =>
		listOrganizationDatasources(organizationId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Creates a new datasource for the specified organization.
 * @summary Create Datasource
 */
export const getCreateDatasourceUrl = () => {
	return `/v1/m/datasources`;
};

export const createDatasource = async (
	createDatasourceRequest: CreateDatasourceRequest,
	options?: RequestInit,
): Promise<CreateDatasourceResponse> => {
	return orvalFetch<CreateDatasourceResponse>(getCreateDatasourceUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createDatasourceRequest),
	});
};

export const getCreateDatasourceMutationFetcher = (
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: CreateDatasourceRequest },
	): Promise<CreateDatasourceResponse> => {
		return createDatasource(arg, options);
	};
};
export const getCreateDatasourceMutationKey = () =>
	[`/v1/m/datasources`] as const;

export type CreateDatasourceMutationResult = NonNullable<
	Awaited<ReturnType<typeof createDatasource>>
>;
export type CreateDatasourceMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Create Datasource
 */
export const useCreateDatasource = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(options?: {
	swr?: SWRMutationConfiguration<
		Awaited<ReturnType<typeof createDatasource>>,
		TError,
		Key,
		CreateDatasourceRequest,
		Awaited<ReturnType<typeof createDatasource>>
	> & { swrKey?: string };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getCreateDatasourceMutationKey();
	const swrFn = getCreateDatasourceMutationFetcher(requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Update Datasource
 */
export const getUpdateDatasourceUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}`;
};

export const updateDatasource = async (
	datasourceId: string,
	updateDatasourceRequest: UpdateDatasourceRequest,
	options?: RequestInit,
): Promise<unknown> => {
	return orvalFetch<unknown>(getUpdateDatasourceUrl(datasourceId), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(updateDatasourceRequest),
	});
};

export const getUpdateDatasourceMutationFetcher = (
	datasourceId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: UpdateDatasourceRequest },
	): Promise<unknown> => {
		return updateDatasource(datasourceId, arg, options);
	};
};
export const getUpdateDatasourceMutationKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}`] as const;

export type UpdateDatasourceMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateDatasource>>
>;
export type UpdateDatasourceMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Update Datasource
 */
export const useUpdateDatasource = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof updateDatasource>>,
			TError,
			Key,
			UpdateDatasourceRequest,
			Awaited<ReturnType<typeof updateDatasource>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getUpdateDatasourceMutationKey(datasourceId);
	const swrFn = getUpdateDatasourceMutationFetcher(
		datasourceId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns detailed information about a specific datasource.
 * @summary Get Datasource
 */
export const getGetDatasourceUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}`;
};

export const getDatasource = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<GetDatasourceResponse> => {
	return orvalFetch<GetDatasourceResponse>(getGetDatasourceUrl(datasourceId), {
		...options,
		method: "GET",
	});
};

export const getGetDatasourceKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}`] as const;

export type GetDatasourceQueryResult = NonNullable<
	Awaited<ReturnType<typeof getDatasource>>
>;
export type GetDatasourceQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Get Datasource
 */
export const useGetDatasource = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getDatasource>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!datasourceId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getGetDatasourceKey(datasourceId) : null));
	const swrFn = () => getDatasource(datasourceId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Deletes a datasource.

The user must be a member of the organization that owns the datasource.
 * @summary Delete Datasource
 */
export const getDeleteDatasourceUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}`;
};

export const deleteDatasource = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(getDeleteDatasourceUrl(datasourceId), {
		...options,
		method: "DELETE",
	});
};

export const getDeleteDatasourceMutationFetcher = (
	datasourceId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }): Promise<void> => {
		return deleteDatasource(datasourceId, options);
	};
};
export const getDeleteDatasourceMutationKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}`] as const;

export type DeleteDatasourceMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteDatasource>>
>;
export type DeleteDatasourceMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Delete Datasource
 */
export const useDeleteDatasource = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteDatasource>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteDatasource>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getDeleteDatasourceMutationKey(datasourceId);
	const swrFn = getDeleteDatasourceMutationFetcher(
		datasourceId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Verifies connectivity to a datasource and returns a list of readable tables.
 * @summary Inspect Datasource
 */
export const getInspectDatasourceUrl = (
	datasourceId: string,
	params?: InspectDatasourceParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/inspect?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/inspect`;
};

export const inspectDatasource = async (
	datasourceId: string,
	params?: InspectDatasourceParams,
	options?: RequestInit,
): Promise<InspectDatasourceResponse> => {
	return orvalFetch<InspectDatasourceResponse>(
		getInspectDatasourceUrl(datasourceId, params),
		{
			...options,
			method: "GET",
		},
	);
};

export const getInspectDatasourceKey = (
	datasourceId: string,
	params?: InspectDatasourceParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/inspect`,
		...(params ? [params] : []),
	] as const;

export type InspectDatasourceQueryResult = NonNullable<
	Awaited<ReturnType<typeof inspectDatasource>>
>;
export type InspectDatasourceQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Inspect Datasource
 */
export const useInspectDatasource = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	params?: InspectDatasourceParams,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof inspectDatasource>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!datasourceId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getInspectDatasourceKey(datasourceId, params) : null));
	const swrFn = () => inspectDatasource(datasourceId, params, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Inspects a single table in a datasource and returns a summary of its fields.
 * @summary Inspect Table In Datasource
 */
export const getInspectTableInDatasourceUrl = (
	datasourceId: string,
	tableName: string,
	params?: InspectTableInDatasourceParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/inspect/${tableName}?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/inspect/${tableName}`;
};

export const inspectTableInDatasource = async (
	datasourceId: string,
	tableName: string,
	params?: InspectTableInDatasourceParams,
	options?: RequestInit,
): Promise<InspectDatasourceTableResponse> => {
	return orvalFetch<InspectDatasourceTableResponse>(
		getInspectTableInDatasourceUrl(datasourceId, tableName, params),
		{
			...options,
			method: "GET",
		},
	);
};

export const getInspectTableInDatasourceKey = (
	datasourceId: string,
	tableName: string,
	params?: InspectTableInDatasourceParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/inspect/${tableName}`,
		...(params ? [params] : []),
	] as const;

export type InspectTableInDatasourceQueryResult = NonNullable<
	Awaited<ReturnType<typeof inspectTableInDatasource>>
>;
export type InspectTableInDatasourceQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Inspect Table In Datasource
 */
export const useInspectTableInDatasource = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	tableName: string,
	params?: InspectTableInDatasourceParams,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof inspectTableInDatasource>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && tableName);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getInspectTableInDatasourceKey(datasourceId, tableName, params)
				: null);
	const swrFn = () =>
		inspectTableInDatasource(datasourceId, tableName, params, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary List Participant Types
 */
export const getListParticipantTypesUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/participants`;
};

export const listParticipantTypes = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<ListParticipantsTypeResponse> => {
	return orvalFetch<ListParticipantsTypeResponse>(
		getListParticipantTypesUrl(datasourceId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getListParticipantTypesKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/participants`] as const;

export type ListParticipantTypesQueryResult = NonNullable<
	Awaited<ReturnType<typeof listParticipantTypes>>
>;
export type ListParticipantTypesQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary List Participant Types
 */
export const useListParticipantTypes = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof listParticipantTypes>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!datasourceId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListParticipantTypesKey(datasourceId) : null));
	const swrFn = () => listParticipantTypes(datasourceId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Create Participant Type
 */
export const getCreateParticipantTypeUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/participants`;
};

export const createParticipantType = async (
	datasourceId: string,
	createParticipantsTypeRequest: CreateParticipantsTypeRequest,
	options?: RequestInit,
): Promise<CreateParticipantsTypeResponse> => {
	return orvalFetch<CreateParticipantsTypeResponse>(
		getCreateParticipantTypeUrl(datasourceId),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(createParticipantsTypeRequest),
		},
	);
};

export const getCreateParticipantTypeMutationFetcher = (
	datasourceId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: CreateParticipantsTypeRequest },
	): Promise<CreateParticipantsTypeResponse> => {
		return createParticipantType(datasourceId, arg, options);
	};
};
export const getCreateParticipantTypeMutationKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/participants`] as const;

export type CreateParticipantTypeMutationResult = NonNullable<
	Awaited<ReturnType<typeof createParticipantType>>
>;
export type CreateParticipantTypeMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Create Participant Type
 */
export const useCreateParticipantType = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof createParticipantType>>,
			TError,
			Key,
			CreateParticipantsTypeRequest,
			Awaited<ReturnType<typeof createParticipantType>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getCreateParticipantTypeMutationKey(datasourceId);
	const swrFn = getCreateParticipantTypeMutationFetcher(
		datasourceId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns filter, strata, and metric field metadata for a participant type, including exemplars for filter fields.
 * @summary Inspect Participant Types
 */
export const getInspectParticipantTypesUrl = (
	datasourceId: string,
	participantId: string,
	params?: InspectParticipantTypesParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/participants/${participantId}/inspect?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/participants/${participantId}/inspect`;
};

export const inspectParticipantTypes = async (
	datasourceId: string,
	participantId: string,
	params?: InspectParticipantTypesParams,
	options?: RequestInit,
): Promise<InspectParticipantTypesResponse> => {
	return orvalFetch<InspectParticipantTypesResponse>(
		getInspectParticipantTypesUrl(datasourceId, participantId, params),
		{
			...options,
			method: "GET",
		},
	);
};

export const getInspectParticipantTypesKey = (
	datasourceId: string,
	participantId: string,
	params?: InspectParticipantTypesParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/participants/${participantId}/inspect`,
		...(params ? [params] : []),
	] as const;

export type InspectParticipantTypesQueryResult = NonNullable<
	Awaited<ReturnType<typeof inspectParticipantTypes>>
>;
export type InspectParticipantTypesQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Inspect Participant Types
 */
export const useInspectParticipantTypes = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	participantId: string,
	params?: InspectParticipantTypesParams,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof inspectParticipantTypes>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && participantId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getInspectParticipantTypesKey(datasourceId, participantId, params)
				: null);
	const swrFn = () =>
		inspectParticipantTypes(
			datasourceId,
			participantId,
			params,
			requestOptions,
		);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Get Participant Types
 */
export const getGetParticipantTypesUrl = (
	datasourceId: string,
	participantId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/participants/${participantId}`;
};

export const getParticipantTypes = async (
	datasourceId: string,
	participantId: string,
	options?: RequestInit,
): Promise<ParticipantsConfig> => {
	return orvalFetch<ParticipantsConfig>(
		getGetParticipantTypesUrl(datasourceId, participantId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetParticipantTypesKey = (
	datasourceId: string,
	participantId: string,
) =>
	[`/v1/m/datasources/${datasourceId}/participants/${participantId}`] as const;

export type GetParticipantTypesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getParticipantTypes>>
>;
export type GetParticipantTypesQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Get Participant Types
 */
export const useGetParticipantTypes = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	participantId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getParticipantTypes>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && participantId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getGetParticipantTypesKey(datasourceId, participantId)
				: null);
	const swrFn = () =>
		getParticipantTypes(datasourceId, participantId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Update Participant Type
 */
export const getUpdateParticipantTypeUrl = (
	datasourceId: string,
	participantId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/participants/${participantId}`;
};

export const updateParticipantType = async (
	datasourceId: string,
	participantId: string,
	updateParticipantsTypeRequest: UpdateParticipantsTypeRequest,
	options?: RequestInit,
): Promise<UpdateParticipantsTypeResponse> => {
	return orvalFetch<UpdateParticipantsTypeResponse>(
		getUpdateParticipantTypeUrl(datasourceId, participantId),
		{
			...options,
			method: "PATCH",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(updateParticipantsTypeRequest),
		},
	);
};

export const getUpdateParticipantTypeMutationFetcher = (
	datasourceId: string,
	participantId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: UpdateParticipantsTypeRequest },
	): Promise<UpdateParticipantsTypeResponse> => {
		return updateParticipantType(datasourceId, participantId, arg, options);
	};
};
export const getUpdateParticipantTypeMutationKey = (
	datasourceId: string,
	participantId: string,
) =>
	[`/v1/m/datasources/${datasourceId}/participants/${participantId}`] as const;

export type UpdateParticipantTypeMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateParticipantType>>
>;
export type UpdateParticipantTypeMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Update Participant Type
 */
export const useUpdateParticipantType = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	participantId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof updateParticipantType>>,
			TError,
			Key,
			UpdateParticipantsTypeRequest,
			Awaited<ReturnType<typeof updateParticipantType>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getUpdateParticipantTypeMutationKey(datasourceId, participantId);
	const swrFn = getUpdateParticipantTypeMutationFetcher(
		datasourceId,
		participantId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Delete Participant
 */
export const getDeleteParticipantUrl = (
	datasourceId: string,
	participantId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/participants/${participantId}`;
};

export const deleteParticipant = async (
	datasourceId: string,
	participantId: string,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(
		getDeleteParticipantUrl(datasourceId, participantId),
		{
			...options,
			method: "DELETE",
		},
	);
};

export const getDeleteParticipantMutationFetcher = (
	datasourceId: string,
	participantId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }): Promise<void> => {
		return deleteParticipant(datasourceId, participantId, options);
	};
};
export const getDeleteParticipantMutationKey = (
	datasourceId: string,
	participantId: string,
) =>
	[`/v1/m/datasources/${datasourceId}/participants/${participantId}`] as const;

export type DeleteParticipantMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteParticipant>>
>;
export type DeleteParticipantMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Delete Participant
 */
export const useDeleteParticipant = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	participantId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteParticipant>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteParticipant>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getDeleteParticipantMutationKey(datasourceId, participantId);
	const swrFn = getDeleteParticipantMutationFetcher(
		datasourceId,
		participantId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns API keys that have access to the datasource.
 * @summary List Api Keys
 */
export const getListApiKeysUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/apikeys`;
};

export const listApiKeys = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<ListApiKeysResponse> => {
	return orvalFetch<ListApiKeysResponse>(getListApiKeysUrl(datasourceId), {
		...options,
		method: "GET",
	});
};

export const getListApiKeysKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/apikeys`] as const;

export type ListApiKeysQueryResult = NonNullable<
	Awaited<ReturnType<typeof listApiKeys>>
>;
export type ListApiKeysQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary List Api Keys
 */
export const useListApiKeys = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRConfiguration<Awaited<ReturnType<typeof listApiKeys>>, TError> & {
			swrKey?: Key;
			enabled?: boolean;
		};
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!datasourceId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListApiKeysKey(datasourceId) : null));
	const swrFn = () => listApiKeys(datasourceId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Creates an API key for the specified datasource.

The user must belong to the organization that owns the requested datasource.
 * @summary Create Api Key
 */
export const getCreateApiKeyUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/apikeys`;
};

export const createApiKey = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<CreateApiKeyResponse> => {
	return orvalFetch<CreateApiKeyResponse>(getCreateApiKeyUrl(datasourceId), {
		...options,
		method: "POST",
	});
};

export const getCreateApiKeyMutationFetcher = (
	datasourceId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }): Promise<CreateApiKeyResponse> => {
		return createApiKey(datasourceId, options);
	};
};
export const getCreateApiKeyMutationKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/apikeys`] as const;

export type CreateApiKeyMutationResult = NonNullable<
	Awaited<ReturnType<typeof createApiKey>>
>;
export type CreateApiKeyMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Create Api Key
 */
export const useCreateApiKey = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof createApiKey>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof createApiKey>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getCreateApiKeyMutationKey(datasourceId);
	const swrFn = getCreateApiKeyMutationFetcher(datasourceId, requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Deletes the specified API key.
 * @summary Delete Api Key
 */
export const getDeleteApiKeyUrl = (datasourceId: string, apiKeyId: string) => {
	return `/v1/m/datasources/${datasourceId}/apikeys/${apiKeyId}`;
};

export const deleteApiKey = async (
	datasourceId: string,
	apiKeyId: string,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(getDeleteApiKeyUrl(datasourceId, apiKeyId), {
		...options,
		method: "DELETE",
	});
};

export const getDeleteApiKeyMutationFetcher = (
	datasourceId: string,
	apiKeyId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }): Promise<void> => {
		return deleteApiKey(datasourceId, apiKeyId, options);
	};
};
export const getDeleteApiKeyMutationKey = (
	datasourceId: string,
	apiKeyId: string,
) => [`/v1/m/datasources/${datasourceId}/apikeys/${apiKeyId}`] as const;

export type DeleteApiKeyMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteApiKey>>
>;
export type DeleteApiKeyMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Delete Api Key
 */
export const useDeleteApiKey = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	apiKeyId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteApiKey>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteApiKey>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getDeleteApiKeyMutationKey(datasourceId, apiKeyId);
	const swrFn = getDeleteApiKeyMutationFetcher(
		datasourceId,
		apiKeyId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Create Experiment
 */
export const getCreateExperimentUrl = (
	datasourceId: string,
	params?: CreateExperimentParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/experiments?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/experiments`;
};

export const createExperiment = async (
	datasourceId: string,
	createExperimentRequest: CreateExperimentRequest,
	params?: CreateExperimentParams,
	options?: RequestInit,
): Promise<CreateExperimentResponse> => {
	return orvalFetch<CreateExperimentResponse>(
		getCreateExperimentUrl(datasourceId, params),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(createExperimentRequest),
		},
	);
};

export const getCreateExperimentMutationFetcher = (
	datasourceId: string,
	params?: CreateExperimentParams,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: CreateExperimentRequest },
	): Promise<CreateExperimentResponse> => {
		return createExperiment(datasourceId, arg, params, options);
	};
};
export const getCreateExperimentMutationKey = (
	datasourceId: string,
	params?: CreateExperimentParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments`,
		...(params ? [params] : []),
	] as const;

export type CreateExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof createExperiment>>
>;
export type CreateExperimentMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Create Experiment
 */
export const useCreateExperiment = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	params?: CreateExperimentParams,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof createExperiment>>,
			TError,
			Key,
			CreateExperimentRequest,
			Awaited<ReturnType<typeof createExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getCreateExperimentMutationKey(datasourceId, params);
	const swrFn = getCreateExperimentMutationFetcher(
		datasourceId,
		params,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns the list of experiments in the datasource.
 * @summary List Experiments
 */
export const getListExperimentsUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/experiments`;
};

export const listExperiments = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<ListExperimentsResponse> => {
	return orvalFetch<ListExperimentsResponse>(
		getListExperimentsUrl(datasourceId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getListExperimentsKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/experiments`] as const;

export type ListExperimentsQueryResult = NonNullable<
	Awaited<ReturnType<typeof listExperiments>>
>;
export type ListExperimentsQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary List Experiments
 */
export const useListExperiments = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof listExperiments>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!datasourceId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListExperimentsKey(datasourceId) : null));
	const swrFn = () => listExperiments(datasourceId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Analyze Experiment
 */
export const getAnalyzeExperimentUrl = (
	datasourceId: string,
	experimentId: string,
	params?: AnalyzeExperimentParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/analyze?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/analyze`;
};

export const analyzeExperiment = async (
	datasourceId: string,
	experimentId: string,
	params?: AnalyzeExperimentParams,
	options?: RequestInit,
): Promise<ExperimentAnalysis> => {
	return orvalFetch<ExperimentAnalysis>(
		getAnalyzeExperimentUrl(datasourceId, experimentId, params),
		{
			...options,
			method: "GET",
		},
	);
};

export const getAnalyzeExperimentKey = (
	datasourceId: string,
	experimentId: string,
	params?: AnalyzeExperimentParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/analyze`,
		...(params ? [params] : []),
	] as const;

export type AnalyzeExperimentQueryResult = NonNullable<
	Awaited<ReturnType<typeof analyzeExperiment>>
>;
export type AnalyzeExperimentQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Analyze Experiment
 */
export const useAnalyzeExperiment = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	params?: AnalyzeExperimentParams,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof analyzeExperiment>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && experimentId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getAnalyzeExperimentKey(datasourceId, experimentId, params)
				: null);
	const swrFn = () =>
		analyzeExperiment(datasourceId, experimentId, params, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Commit Experiment
 */
export const getCommitExperimentUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/commit`;
};

export const commitExperiment = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<unknown | void> => {
	return orvalFetch<unknown | void>(
		getCommitExperimentUrl(datasourceId, experimentId),
		{
			...options,
			method: "POST",
		},
	);
};

export const getCommitExperimentMutationFetcher = (
	datasourceId: string,
	experimentId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }): Promise<unknown | void> => {
		return commitExperiment(datasourceId, experimentId, options);
	};
};
export const getCommitExperimentMutationKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/commit`,
	] as const;

export type CommitExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof commitExperiment>>
>;
export type CommitExperimentMutationError = ErrorType<
	void | HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Commit Experiment
 */
export const useCommitExperiment = <
	TError = ErrorType<void | HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof commitExperiment>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof commitExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getCommitExperimentMutationKey(datasourceId, experimentId);
	const swrFn = getCommitExperimentMutationFetcher(
		datasourceId,
		experimentId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Abandon Experiment
 */
export const getAbandonExperimentUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/abandon`;
};

export const abandonExperiment = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<unknown | void> => {
	return orvalFetch<unknown | void>(
		getAbandonExperimentUrl(datasourceId, experimentId),
		{
			...options,
			method: "POST",
		},
	);
};

export const getAbandonExperimentMutationFetcher = (
	datasourceId: string,
	experimentId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }): Promise<unknown | void> => {
		return abandonExperiment(datasourceId, experimentId, options);
	};
};
export const getAbandonExperimentMutationKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/abandon`,
	] as const;

export type AbandonExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof abandonExperiment>>
>;
export type AbandonExperimentMutationError = ErrorType<
	void | HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Abandon Experiment
 */
export const useAbandonExperiment = <
	TError = ErrorType<void | HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof abandonExperiment>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof abandonExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getAbandonExperimentMutationKey(datasourceId, experimentId);
	const swrFn = getAbandonExperimentMutationFetcher(
		datasourceId,
		experimentId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns a list of experiments in the organization.
 * @summary List Organization Experiments
 */
export const getListOrganizationExperimentsUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}/experiments`;
};

export const listOrganizationExperiments = async (
	organizationId: string,
	options?: RequestInit,
): Promise<ListExperimentsResponse> => {
	return orvalFetch<ListExperimentsResponse>(
		getListOrganizationExperimentsUrl(organizationId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getListOrganizationExperimentsKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}/experiments`] as const;

export type ListOrganizationExperimentsQueryResult = NonNullable<
	Awaited<ReturnType<typeof listOrganizationExperiments>>
>;
export type ListOrganizationExperimentsQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary List Organization Experiments
 */
export const useListOrganizationExperiments = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof listOrganizationExperiments>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!organizationId;
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled ? getListOrganizationExperimentsKey(organizationId) : null);
	const swrFn = () =>
		listOrganizationExperiments(organizationId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns the experiment with the specified ID.
 * @summary Get Experiment
 */
export const getGetExperimentUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}`;
};

export const getExperiment = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<ExperimentConfig> => {
	return orvalFetch<ExperimentConfig>(
		getGetExperimentUrl(datasourceId, experimentId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetExperimentKey = (
	datasourceId: string,
	experimentId: string,
) => [`/v1/m/datasources/${datasourceId}/experiments/${experimentId}`] as const;

export type GetExperimentQueryResult = NonNullable<
	Awaited<ReturnType<typeof getExperiment>>
>;
export type GetExperimentQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Get Experiment
 */
export const useGetExperiment = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getExperiment>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && experimentId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled ? getGetExperimentKey(datasourceId, experimentId) : null);
	const swrFn = () => getExperiment(datasourceId, experimentId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Deletes the experiment with the specified ID.
 * @summary Delete Experiment
 */
export const getDeleteExperimentUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}`;
};

export const deleteExperiment = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(getDeleteExperimentUrl(datasourceId, experimentId), {
		...options,
		method: "DELETE",
	});
};

export const getDeleteExperimentMutationFetcher = (
	datasourceId: string,
	experimentId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }): Promise<void> => {
		return deleteExperiment(datasourceId, experimentId, options);
	};
};
export const getDeleteExperimentMutationKey = (
	datasourceId: string,
	experimentId: string,
) => [`/v1/m/datasources/${datasourceId}/experiments/${experimentId}`] as const;

export type DeleteExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteExperiment>>
>;
export type DeleteExperimentMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Delete Experiment
 */
export const useDeleteExperiment = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteExperiment>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getDeleteExperimentMutationKey(datasourceId, experimentId);
	const swrFn = getDeleteExperimentMutationFetcher(
		datasourceId,
		experimentId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Get Experiment Assignments
 */
export const getGetExperimentAssignmentsUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments`;
};

export const getExperimentAssignments = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<GetExperimentAssignmentsResponse> => {
	return orvalFetch<GetExperimentAssignmentsResponse>(
		getGetExperimentAssignmentsUrl(datasourceId, experimentId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetExperimentAssignmentsKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments`,
	] as const;

export type GetExperimentAssignmentsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getExperimentAssignments>>
>;
export type GetExperimentAssignmentsQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Get Experiment Assignments
 */
export const useGetExperimentAssignments = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getExperimentAssignments>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && experimentId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getGetExperimentAssignmentsKey(datasourceId, experimentId)
				: null);
	const swrFn = () =>
		getExperimentAssignments(datasourceId, experimentId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Export experiment assignments as CSV file; BalanceCheck not included. csv header form: participant_id,arm_id,arm_name,strata_name1,strata_name2,...
 */
export const getGetExperimentAssignmentsAsCsvUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments/csv`;
};

export const getExperimentAssignmentsAsCsv = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<unknown> => {
	return orvalFetch<unknown>(
		getGetExperimentAssignmentsAsCsvUrl(datasourceId, experimentId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetExperimentAssignmentsAsCsvKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments/csv`,
	] as const;

export type GetExperimentAssignmentsAsCsvQueryResult = NonNullable<
	Awaited<ReturnType<typeof getExperimentAssignmentsAsCsv>>
>;
export type GetExperimentAssignmentsAsCsvQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Export experiment assignments as CSV file; BalanceCheck not included. csv header form: participant_id,arm_id,arm_name,strata_name1,strata_name2,...
 */
export const useGetExperimentAssignmentsAsCsv = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getExperimentAssignmentsAsCsv>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && experimentId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getGetExperimentAssignmentsAsCsvKey(datasourceId, experimentId)
				: null);
	const swrFn = () =>
		getExperimentAssignmentsAsCsv(datasourceId, experimentId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Get the assignment for a specific participant, excluding strata if any.
    For 'preassigned' experiments, the participant's Assignment is returned if it exists.
    For 'online', returns the assignment if it exists, else generates an assignment.
 * @summary Get Experiment Assignment For Participant
 */
export const getGetExperimentAssignmentForParticipantUrl = (
	datasourceId: string,
	experimentId: string,
	participantId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments/${participantId}`;
};

export const getExperimentAssignmentForParticipant = async (
	datasourceId: string,
	experimentId: string,
	participantId: string,
	options?: RequestInit,
): Promise<GetParticipantAssignmentResponse> => {
	return orvalFetch<GetParticipantAssignmentResponse>(
		getGetExperimentAssignmentForParticipantUrl(
			datasourceId,
			experimentId,
			participantId,
		),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetExperimentAssignmentForParticipantKey = (
	datasourceId: string,
	experimentId: string,
	participantId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments/${participantId}`,
	] as const;

export type GetExperimentAssignmentForParticipantQueryResult = NonNullable<
	Awaited<ReturnType<typeof getExperimentAssignmentForParticipant>>
>;
export type GetExperimentAssignmentForParticipantQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Get Experiment Assignment For Participant
 */
export const useGetExperimentAssignmentForParticipant = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	participantId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getExperimentAssignmentForParticipant>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false &&
		!!(datasourceId && experimentId && participantId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getGetExperimentAssignmentForParticipantKey(
						datasourceId,
						experimentId,
						participantId,
					)
				: null);
	const swrFn = () =>
		getExperimentAssignmentForParticipant(
			datasourceId,
			experimentId,
			participantId,
			requestOptions,
		);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Power Check
 */
export const getPowerCheckUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/power`;
};

export const powerCheck = async (
	datasourceId: string,
	powerRequest: PowerRequest,
	options?: RequestInit,
): Promise<PowerResponseOutput> => {
	return orvalFetch<PowerResponseOutput>(getPowerCheckUrl(datasourceId), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(powerRequest),
	});
};

export const getPowerCheckMutationFetcher = (
	datasourceId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: PowerRequest },
	): Promise<PowerResponseOutput> => {
		return powerCheck(datasourceId, arg, options);
	};
};
export const getPowerCheckMutationKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/power`] as const;

export type PowerCheckMutationResult = NonNullable<
	Awaited<ReturnType<typeof powerCheck>>
>;
export type PowerCheckMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Power Check
 */
export const usePowerCheck = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof powerCheck>>,
			TError,
			Key,
			PowerRequest,
			Awaited<ReturnType<typeof powerCheck>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getPowerCheckMutationKey(datasourceId);
	const swrFn = getPowerCheckMutationFetcher(datasourceId, requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
