/**
 * Generated by orval v7.19.0 üç∫
 * Do not edit manually.
 * Evidential Experiments API
 * OpenAPI spec version: 0.9.0
 */
import useSwr from "swr";
import type { Arguments, Key, SWRConfiguration } from "swr";

import useSWRMutation from "swr/mutation";
import type { SWRMutationConfiguration } from "swr/mutation";

import type {
	AddMemberToOrganizationRequest,
	AddWebhookToOrganizationRequest,
	AddWebhookToOrganizationResponse,
	AnalyzeExperimentParams,
	CMABContextInputRequest,
	CallerIdentity,
	CreateApiKeyResponse,
	CreateDatasourceRequest,
	CreateDatasourceResponse,
	CreateExperimentParams,
	CreateExperimentRequest,
	CreateExperimentResponse,
	CreateOrganizationRequest,
	CreateOrganizationResponse,
	CreateParticipantsTypeRequest,
	CreateParticipantsTypeResponse,
	CreateSnapshotResponse,
	DeleteApiKeyParams,
	DeleteDatasourceParams,
	DeleteExperimentDataRequest,
	DeleteExperimentParams,
	DeleteParticipantParams,
	DeleteSnapshotParams,
	DeleteWebhookFromOrganizationParams,
	ExperimentAnalysisResponse,
	GetDatasourceResponse,
	GetExperimentAssignmentForParticipantParams,
	GetExperimentAssignmentsResponse,
	GetExperimentResponse,
	GetOrganizationResponse,
	GetParticipantAssignmentResponse,
	GetParticipantsTypeResponse,
	GetSnapshotResponse,
	HTTPExceptionError,
	HTTPValidationError,
	InspectDatasourceParams,
	InspectDatasourceResponse,
	InspectDatasourceTableResponse,
	InspectParticipantTypesParams,
	InspectParticipantTypesResponse,
	InspectTableInDatasourceParams,
	ListApiKeysResponse,
	ListDatasourcesResponse,
	ListExperimentsResponse,
	ListOrganizationEventsResponse,
	ListOrganizationsResponse,
	ListParticipantsTypeResponse,
	ListSnapshotsParams,
	ListSnapshotsResponse,
	ListWebhooksResponse,
	PowerRequest,
	PowerResponseOutput,
	RemoveMemberFromOrganizationParams,
	UpdateArmRequest,
	UpdateDatasourceRequest,
	UpdateExperimentRequest,
	UpdateOrganizationRequest,
	UpdateOrganizationWebhookRequest,
	UpdateParticipantsTypeRequest,
	UpdateParticipantsTypeResponse,
} from "./methods.schemas";

import { orvalFetch } from "@/services/orval-fetch";
import type { ErrorType } from "@/services/orval-fetch";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Returns basic metadata about the authenticated caller of this method.
 * @summary Caller Identity
 */
export const getCallerIdentityUrl = () => {
	return `/v1/m/caller-identity`;
};

export const callerIdentity = async (
	options?: RequestInit,
): Promise<CallerIdentity> => {
	return orvalFetch<CallerIdentity>(getCallerIdentityUrl(), {
		...options,
		method: "GET",
	});
};

export const getCallerIdentityKey = () => [`/v1/m/caller-identity`] as const;

export type CallerIdentityQueryResult = NonNullable<
	Awaited<ReturnType<typeof callerIdentity>>
>;
export type CallerIdentityQueryError = ErrorType<HTTPExceptionError>;

/**
 * @summary Caller Identity
 */
export const useCallerIdentity = <
	TError = ErrorType<HTTPExceptionError>,
>(options?: {
	swr?: SWRConfiguration<Awaited<ReturnType<typeof callerIdentity>>, TError> & {
		swrKey?: Key;
		enabled?: boolean;
	};
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ?? (() => (isEnabled ? getCallerIdentityKey() : null));
	const swrFn = () => callerIdentity(requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Invalidates all previously created session tokens.
 * @summary Logout
 */
export const getLogoutUrl = () => {
	return `/v1/m/logout`;
};

export const logout = async (options?: RequestInit): Promise<void> => {
	return orvalFetch<void>(getLogoutUrl(), {
		...options,
		method: "POST",
	});
};

export const getLogoutMutationFetcher = (
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }) => {
		return logout(options);
	};
};
export const getLogoutMutationKey = () => [`/v1/m/logout`] as const;

export type LogoutMutationResult = NonNullable<
	Awaited<ReturnType<typeof logout>>
>;
export type LogoutMutationError = ErrorType<HTTPExceptionError>;

/**
 * @summary Logout
 */
export const useLogout = <TError = ErrorType<HTTPExceptionError>>(options?: {
	swr?: SWRMutationConfiguration<
		Awaited<ReturnType<typeof logout>>,
		TError,
		Key,
		Arguments,
		Awaited<ReturnType<typeof logout>>
	> & { swrKey?: string };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getLogoutMutationKey();
	const swrFn = getLogoutMutationFetcher(requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Fetches a snapshot by ID.
 * @summary Get Snapshot
 */
export const getGetSnapshotUrl = (
	organizationId: string,
	datasourceId: string,
	experimentId: string,
	snapshotId: string,
) => {
	return `/v1/m/organizations/${organizationId}/datasources/${datasourceId}/experiments/${experimentId}/snapshots/${snapshotId}`;
};

export const getSnapshot = async (
	organizationId: string,
	datasourceId: string,
	experimentId: string,
	snapshotId: string,
	options?: RequestInit,
): Promise<GetSnapshotResponse> => {
	return orvalFetch<GetSnapshotResponse>(
		getGetSnapshotUrl(organizationId, datasourceId, experimentId, snapshotId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetSnapshotKey = (
	organizationId: string,
	datasourceId: string,
	experimentId: string,
	snapshotId: string,
) =>
	[
		`/v1/m/organizations/${organizationId}/datasources/${datasourceId}/experiments/${experimentId}/snapshots/${snapshotId}`,
	] as const;

export type GetSnapshotQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSnapshot>>
>;
export type GetSnapshotQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Get Snapshot
 */
export const useGetSnapshot = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	datasourceId: string,
	experimentId: string,
	snapshotId: string,
	options?: {
		swr?: SWRConfiguration<Awaited<ReturnType<typeof getSnapshot>>, TError> & {
			swrKey?: Key;
			enabled?: boolean;
		};
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false &&
		!!(organizationId && datasourceId && experimentId && snapshotId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getGetSnapshotKey(
						organizationId,
						datasourceId,
						experimentId,
						snapshotId,
					)
				: null);
	const swrFn = () =>
		getSnapshot(
			organizationId,
			datasourceId,
			experimentId,
			snapshotId,
			requestOptions,
		);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Deletes a snapshot.
 * @summary Delete Snapshot
 */
export const getDeleteSnapshotUrl = (
	organizationId: string,
	datasourceId: string,
	experimentId: string,
	snapshotId: string,
	params?: DeleteSnapshotParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/organizations/${organizationId}/datasources/${datasourceId}/experiments/${experimentId}/snapshots/${snapshotId}?${stringifiedParams}`
		: `/v1/m/organizations/${organizationId}/datasources/${datasourceId}/experiments/${experimentId}/snapshots/${snapshotId}`;
};

export const deleteSnapshot = async (
	organizationId: string,
	datasourceId: string,
	experimentId: string,
	snapshotId: string,
	params?: DeleteSnapshotParams,
	options?: RequestInit,
): Promise<unknown> => {
	return orvalFetch<unknown>(
		getDeleteSnapshotUrl(
			organizationId,
			datasourceId,
			experimentId,
			snapshotId,
			params,
		),
		{
			...options,
			method: "DELETE",
		},
	);
};

export const getDeleteSnapshotMutationFetcher = (
	organizationId: string,
	datasourceId: string,
	experimentId: string,
	snapshotId: string,
	params?: DeleteSnapshotParams,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }) => {
		return deleteSnapshot(
			organizationId,
			datasourceId,
			experimentId,
			snapshotId,
			params,
			options,
		);
	};
};
export const getDeleteSnapshotMutationKey = (
	organizationId: string,
	datasourceId: string,
	experimentId: string,
	snapshotId: string,
	params?: DeleteSnapshotParams,
) =>
	[
		`/v1/m/organizations/${organizationId}/datasources/${datasourceId}/experiments/${experimentId}/snapshots/${snapshotId}`,
		...(params ? [params] : []),
	] as const;

export type DeleteSnapshotMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteSnapshot>>
>;
export type DeleteSnapshotMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Delete Snapshot
 */
export const useDeleteSnapshot = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	datasourceId: string,
	experimentId: string,
	snapshotId: string,
	params?: DeleteSnapshotParams,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteSnapshot>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteSnapshot>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getDeleteSnapshotMutationKey(
			organizationId,
			datasourceId,
			experimentId,
			snapshotId,
			params,
		);
	const swrFn = getDeleteSnapshotMutationFetcher(
		organizationId,
		datasourceId,
		experimentId,
		snapshotId,
		params,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Lists snapshots for an experiment, ordered by timestamp.
 * @summary List Snapshots
 */
export const getListSnapshotsUrl = (
	organizationId: string,
	datasourceId: string,
	experimentId: string,
	params?: ListSnapshotsParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/organizations/${organizationId}/datasources/${datasourceId}/experiments/${experimentId}/snapshots?${stringifiedParams}`
		: `/v1/m/organizations/${organizationId}/datasources/${datasourceId}/experiments/${experimentId}/snapshots`;
};

export const listSnapshots = async (
	organizationId: string,
	datasourceId: string,
	experimentId: string,
	params?: ListSnapshotsParams,
	options?: RequestInit,
): Promise<ListSnapshotsResponse> => {
	return orvalFetch<ListSnapshotsResponse>(
		getListSnapshotsUrl(organizationId, datasourceId, experimentId, params),
		{
			...options,
			method: "GET",
		},
	);
};

export const getListSnapshotsKey = (
	organizationId: string,
	datasourceId: string,
	experimentId: string,
	params?: ListSnapshotsParams,
) =>
	[
		`/v1/m/organizations/${organizationId}/datasources/${datasourceId}/experiments/${experimentId}/snapshots`,
		...(params ? [params] : []),
	] as const;

export type ListSnapshotsQueryResult = NonNullable<
	Awaited<ReturnType<typeof listSnapshots>>
>;
export type ListSnapshotsQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary List Snapshots
 */
export const useListSnapshots = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	datasourceId: string,
	experimentId: string,
	params?: ListSnapshotsParams,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof listSnapshots>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false &&
		!!(organizationId && datasourceId && experimentId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getListSnapshotsKey(
						organizationId,
						datasourceId,
						experimentId,
						params,
					)
				: null);
	const swrFn = () =>
		listSnapshots(
			organizationId,
			datasourceId,
			experimentId,
			params,
			requestOptions,
		);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Request the asynchronous creation of a snapshot for an experiment.

Returns the ID of the snapshot. Poll get_snapshot until the job is completed.
 * @summary Create Snapshot
 */
export const getCreateSnapshotUrl = (
	organizationId: string,
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/organizations/${organizationId}/datasources/${datasourceId}/experiments/${experimentId}/snapshots`;
};

export const createSnapshot = async (
	organizationId: string,
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<CreateSnapshotResponse> => {
	return orvalFetch<CreateSnapshotResponse>(
		getCreateSnapshotUrl(organizationId, datasourceId, experimentId),
		{
			...options,
			method: "POST",
		},
	);
};

export const getCreateSnapshotMutationFetcher = (
	organizationId: string,
	datasourceId: string,
	experimentId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }) => {
		return createSnapshot(organizationId, datasourceId, experimentId, options);
	};
};
export const getCreateSnapshotMutationKey = (
	organizationId: string,
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/organizations/${organizationId}/datasources/${datasourceId}/experiments/${experimentId}/snapshots`,
	] as const;

export type CreateSnapshotMutationResult = NonNullable<
	Awaited<ReturnType<typeof createSnapshot>>
>;
export type CreateSnapshotMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Create Snapshot
 */
export const useCreateSnapshot = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof createSnapshot>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof createSnapshot>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getCreateSnapshotMutationKey(organizationId, datasourceId, experimentId);
	const swrFn = getCreateSnapshotMutationFetcher(
		organizationId,
		datasourceId,
		experimentId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns a list of organizations that the authenticated user is a member of.
 * @summary List Organizations
 */
export const getListOrganizationsUrl = () => {
	return `/v1/m/organizations`;
};

export const listOrganizations = async (
	options?: RequestInit,
): Promise<ListOrganizationsResponse> => {
	return orvalFetch<ListOrganizationsResponse>(getListOrganizationsUrl(), {
		...options,
		method: "GET",
	});
};

export const getListOrganizationsKey = () => [`/v1/m/organizations`] as const;

export type ListOrganizationsQueryResult = NonNullable<
	Awaited<ReturnType<typeof listOrganizations>>
>;
export type ListOrganizationsQueryError = ErrorType<HTTPExceptionError>;

/**
 * @summary List Organizations
 */
export const useListOrganizations = <
	TError = ErrorType<HTTPExceptionError>,
>(options?: {
	swr?: SWRConfiguration<
		Awaited<ReturnType<typeof listOrganizations>>,
		TError
	> & { swrKey?: Key; enabled?: boolean };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListOrganizationsKey() : null));
	const swrFn = () => listOrganizations(requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Creates a new organization.

Only privileged users can create organizations.
 * @summary Create Organizations
 */
export const getCreateOrganizationsUrl = () => {
	return `/v1/m/organizations`;
};

export const createOrganizations = async (
	createOrganizationRequest: CreateOrganizationRequest,
	options?: RequestInit,
): Promise<CreateOrganizationResponse> => {
	return orvalFetch<CreateOrganizationResponse>(getCreateOrganizationsUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createOrganizationRequest),
	});
};

export const getCreateOrganizationsMutationFetcher = (
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, { arg }: { arg: CreateOrganizationRequest }) => {
		return createOrganizations(arg, options);
	};
};
export const getCreateOrganizationsMutationKey = () =>
	[`/v1/m/organizations`] as const;

export type CreateOrganizationsMutationResult = NonNullable<
	Awaited<ReturnType<typeof createOrganizations>>
>;
export type CreateOrganizationsMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Create Organizations
 */
export const useCreateOrganizations = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(options?: {
	swr?: SWRMutationConfiguration<
		Awaited<ReturnType<typeof createOrganizations>>,
		TError,
		Key,
		CreateOrganizationRequest,
		Awaited<ReturnType<typeof createOrganizations>>
	> & { swrKey?: string };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getCreateOrganizationsMutationKey();
	const swrFn = getCreateOrganizationsMutationFetcher(requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Adds a Webhook to an organization.
 * @summary Add Webhook To Organization
 */
export const getAddWebhookToOrganizationUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}/webhooks`;
};

export const addWebhookToOrganization = async (
	organizationId: string,
	addWebhookToOrganizationRequest: AddWebhookToOrganizationRequest,
	options?: RequestInit,
): Promise<AddWebhookToOrganizationResponse> => {
	return orvalFetch<AddWebhookToOrganizationResponse>(
		getAddWebhookToOrganizationUrl(organizationId),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(addWebhookToOrganizationRequest),
		},
	);
};

export const getAddWebhookToOrganizationMutationFetcher = (
	organizationId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, { arg }: { arg: AddWebhookToOrganizationRequest }) => {
		return addWebhookToOrganization(organizationId, arg, options);
	};
};
export const getAddWebhookToOrganizationMutationKey = (
	organizationId: string,
) => [`/v1/m/organizations/${organizationId}/webhooks`] as const;

export type AddWebhookToOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof addWebhookToOrganization>>
>;
export type AddWebhookToOrganizationMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Add Webhook To Organization
 */
export const useAddWebhookToOrganization = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof addWebhookToOrganization>>,
			TError,
			Key,
			AddWebhookToOrganizationRequest,
			Awaited<ReturnType<typeof addWebhookToOrganization>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getAddWebhookToOrganizationMutationKey(organizationId);
	const swrFn = getAddWebhookToOrganizationMutationFetcher(
		organizationId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Lists all the webhooks for an organization.
 * @summary List Organization Webhooks
 */
export const getListOrganizationWebhooksUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}/webhooks`;
};

export const listOrganizationWebhooks = async (
	organizationId: string,
	options?: RequestInit,
): Promise<ListWebhooksResponse> => {
	return orvalFetch<ListWebhooksResponse>(
		getListOrganizationWebhooksUrl(organizationId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getListOrganizationWebhooksKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}/webhooks`] as const;

export type ListOrganizationWebhooksQueryResult = NonNullable<
	Awaited<ReturnType<typeof listOrganizationWebhooks>>
>;
export type ListOrganizationWebhooksQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary List Organization Webhooks
 */
export const useListOrganizationWebhooks = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof listOrganizationWebhooks>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!organizationId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListOrganizationWebhooksKey(organizationId) : null));
	const swrFn = () => listOrganizationWebhooks(organizationId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Updates a webhook's name and URL in an organization.
 * @summary Update Organization Webhook
 */
export const getUpdateOrganizationWebhookUrl = (
	organizationId: string,
	webhookId: string,
) => {
	return `/v1/m/organizations/${organizationId}/webhooks/${webhookId}`;
};

export const updateOrganizationWebhook = async (
	organizationId: string,
	webhookId: string,
	updateOrganizationWebhookRequest: UpdateOrganizationWebhookRequest,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(
		getUpdateOrganizationWebhookUrl(organizationId, webhookId),
		{
			...options,
			method: "PATCH",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(updateOrganizationWebhookRequest),
		},
	);
};

export const getUpdateOrganizationWebhookMutationFetcher = (
	organizationId: string,
	webhookId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, { arg }: { arg: UpdateOrganizationWebhookRequest }) => {
		return updateOrganizationWebhook(organizationId, webhookId, arg, options);
	};
};
export const getUpdateOrganizationWebhookMutationKey = (
	organizationId: string,
	webhookId: string,
) => [`/v1/m/organizations/${organizationId}/webhooks/${webhookId}`] as const;

export type UpdateOrganizationWebhookMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateOrganizationWebhook>>
>;
export type UpdateOrganizationWebhookMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Update Organization Webhook
 */
export const useUpdateOrganizationWebhook = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	webhookId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof updateOrganizationWebhook>>,
			TError,
			Key,
			UpdateOrganizationWebhookRequest,
			Awaited<ReturnType<typeof updateOrganizationWebhook>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getUpdateOrganizationWebhookMutationKey(organizationId, webhookId);
	const swrFn = getUpdateOrganizationWebhookMutationFetcher(
		organizationId,
		webhookId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Removes a Webhook from an organization.
 * @summary Delete Webhook From Organization
 */
export const getDeleteWebhookFromOrganizationUrl = (
	organizationId: string,
	webhookId: string,
	params?: DeleteWebhookFromOrganizationParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/organizations/${organizationId}/webhooks/${webhookId}?${stringifiedParams}`
		: `/v1/m/organizations/${organizationId}/webhooks/${webhookId}`;
};

export const deleteWebhookFromOrganization = async (
	organizationId: string,
	webhookId: string,
	params?: DeleteWebhookFromOrganizationParams,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(
		getDeleteWebhookFromOrganizationUrl(organizationId, webhookId, params),
		{
			...options,
			method: "DELETE",
		},
	);
};

export const getDeleteWebhookFromOrganizationMutationFetcher = (
	organizationId: string,
	webhookId: string,
	params?: DeleteWebhookFromOrganizationParams,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }) => {
		return deleteWebhookFromOrganization(
			organizationId,
			webhookId,
			params,
			options,
		);
	};
};
export const getDeleteWebhookFromOrganizationMutationKey = (
	organizationId: string,
	webhookId: string,
	params?: DeleteWebhookFromOrganizationParams,
) =>
	[
		`/v1/m/organizations/${organizationId}/webhooks/${webhookId}`,
		...(params ? [params] : []),
	] as const;

export type DeleteWebhookFromOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteWebhookFromOrganization>>
>;
export type DeleteWebhookFromOrganizationMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Delete Webhook From Organization
 */
export const useDeleteWebhookFromOrganization = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	webhookId: string,
	params?: DeleteWebhookFromOrganizationParams,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteWebhookFromOrganization>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteWebhookFromOrganization>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getDeleteWebhookFromOrganizationMutationKey(
			organizationId,
			webhookId,
			params,
		);
	const swrFn = getDeleteWebhookFromOrganizationMutationFetcher(
		organizationId,
		webhookId,
		params,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Regenerates the auth token for a webhook in an organization.
 * @summary Regenerate Webhook Auth Token
 */
export const getRegenerateWebhookAuthTokenUrl = (
	organizationId: string,
	webhookId: string,
) => {
	return `/v1/m/organizations/${organizationId}/webhooks/${webhookId}/authtoken`;
};

export const regenerateWebhookAuthToken = async (
	organizationId: string,
	webhookId: string,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(
		getRegenerateWebhookAuthTokenUrl(organizationId, webhookId),
		{
			...options,
			method: "POST",
		},
	);
};

export const getRegenerateWebhookAuthTokenMutationFetcher = (
	organizationId: string,
	webhookId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }) => {
		return regenerateWebhookAuthToken(organizationId, webhookId, options);
	};
};
export const getRegenerateWebhookAuthTokenMutationKey = (
	organizationId: string,
	webhookId: string,
) =>
	[
		`/v1/m/organizations/${organizationId}/webhooks/${webhookId}/authtoken`,
	] as const;

export type RegenerateWebhookAuthTokenMutationResult = NonNullable<
	Awaited<ReturnType<typeof regenerateWebhookAuthToken>>
>;
export type RegenerateWebhookAuthTokenMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Regenerate Webhook Auth Token
 */
export const useRegenerateWebhookAuthToken = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	webhookId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof regenerateWebhookAuthToken>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof regenerateWebhookAuthToken>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getRegenerateWebhookAuthTokenMutationKey(organizationId, webhookId);
	const swrFn = getRegenerateWebhookAuthTokenMutationFetcher(
		organizationId,
		webhookId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns the most recent 200 events in an organization.
 * @summary List Organization Events
 */
export const getListOrganizationEventsUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}/events`;
};

export const listOrganizationEvents = async (
	organizationId: string,
	options?: RequestInit,
): Promise<ListOrganizationEventsResponse> => {
	return orvalFetch<ListOrganizationEventsResponse>(
		getListOrganizationEventsUrl(organizationId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getListOrganizationEventsKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}/events`] as const;

export type ListOrganizationEventsQueryResult = NonNullable<
	Awaited<ReturnType<typeof listOrganizationEvents>>
>;
export type ListOrganizationEventsQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary List Organization Events
 */
export const useListOrganizationEvents = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof listOrganizationEvents>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!organizationId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListOrganizationEventsKey(organizationId) : null));
	const swrFn = () => listOrganizationEvents(organizationId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Adds a new member to an organization.

The authenticated user must be part of the organization to add members.
 * @summary Add Member To Organization
 */
export const getAddMemberToOrganizationUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}/members`;
};

export const addMemberToOrganization = async (
	organizationId: string,
	addMemberToOrganizationRequest: AddMemberToOrganizationRequest,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(getAddMemberToOrganizationUrl(organizationId), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(addMemberToOrganizationRequest),
	});
};

export const getAddMemberToOrganizationMutationFetcher = (
	organizationId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, { arg }: { arg: AddMemberToOrganizationRequest }) => {
		return addMemberToOrganization(organizationId, arg, options);
	};
};
export const getAddMemberToOrganizationMutationKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}/members`] as const;

export type AddMemberToOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof addMemberToOrganization>>
>;
export type AddMemberToOrganizationMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Add Member To Organization
 */
export const useAddMemberToOrganization = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof addMemberToOrganization>>,
			TError,
			Key,
			AddMemberToOrganizationRequest,
			Awaited<ReturnType<typeof addMemberToOrganization>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getAddMemberToOrganizationMutationKey(organizationId);
	const swrFn = getAddMemberToOrganizationMutationFetcher(
		organizationId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Removes a member from an organization.

The authenticated user must be part of the organization to remove members.
 * @summary Remove Member From Organization
 */
export const getRemoveMemberFromOrganizationUrl = (
	organizationId: string,
	userId: string,
	params?: RemoveMemberFromOrganizationParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/organizations/${organizationId}/members/${userId}?${stringifiedParams}`
		: `/v1/m/organizations/${organizationId}/members/${userId}`;
};

export const removeMemberFromOrganization = async (
	organizationId: string,
	userId: string,
	params?: RemoveMemberFromOrganizationParams,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(
		getRemoveMemberFromOrganizationUrl(organizationId, userId, params),
		{
			...options,
			method: "DELETE",
		},
	);
};

export const getRemoveMemberFromOrganizationMutationFetcher = (
	organizationId: string,
	userId: string,
	params?: RemoveMemberFromOrganizationParams,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }) => {
		return removeMemberFromOrganization(
			organizationId,
			userId,
			params,
			options,
		);
	};
};
export const getRemoveMemberFromOrganizationMutationKey = (
	organizationId: string,
	userId: string,
	params?: RemoveMemberFromOrganizationParams,
) =>
	[
		`/v1/m/organizations/${organizationId}/members/${userId}`,
		...(params ? [params] : []),
	] as const;

export type RemoveMemberFromOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof removeMemberFromOrganization>>
>;
export type RemoveMemberFromOrganizationMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Remove Member From Organization
 */
export const useRemoveMemberFromOrganization = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	userId: string,
	params?: RemoveMemberFromOrganizationParams,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof removeMemberFromOrganization>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof removeMemberFromOrganization>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getRemoveMemberFromOrganizationMutationKey(organizationId, userId, params);
	const swrFn = getRemoveMemberFromOrganizationMutationFetcher(
		organizationId,
		userId,
		params,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Updates an organization's properties.

The authenticated user must be a member of the organization.
Currently only supports updating the organization name.
 * @summary Update Organization
 */
export const getUpdateOrganizationUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}`;
};

export const updateOrganization = async (
	organizationId: string,
	updateOrganizationRequest: UpdateOrganizationRequest,
	options?: RequestInit,
): Promise<unknown> => {
	return orvalFetch<unknown>(getUpdateOrganizationUrl(organizationId), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(updateOrganizationRequest),
	});
};

export const getUpdateOrganizationMutationFetcher = (
	organizationId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, { arg }: { arg: UpdateOrganizationRequest }) => {
		return updateOrganization(organizationId, arg, options);
	};
};
export const getUpdateOrganizationMutationKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}`] as const;

export type UpdateOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateOrganization>>
>;
export type UpdateOrganizationMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Update Organization
 */
export const useUpdateOrganization = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof updateOrganization>>,
			TError,
			Key,
			UpdateOrganizationRequest,
			Awaited<ReturnType<typeof updateOrganization>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getUpdateOrganizationMutationKey(organizationId);
	const swrFn = getUpdateOrganizationMutationFetcher(
		organizationId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns detailed information about a specific organization.

The authenticated user must be a member of the organization.
 * @summary Get Organization
 */
export const getGetOrganizationUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}`;
};

export const getOrganization = async (
	organizationId: string,
	options?: RequestInit,
): Promise<GetOrganizationResponse> => {
	return orvalFetch<GetOrganizationResponse>(
		getGetOrganizationUrl(organizationId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetOrganizationKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}`] as const;

export type GetOrganizationQueryResult = NonNullable<
	Awaited<ReturnType<typeof getOrganization>>
>;
export type GetOrganizationQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Get Organization
 */
export const useGetOrganization = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getOrganization>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!organizationId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getGetOrganizationKey(organizationId) : null));
	const swrFn = () => getOrganization(organizationId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns a list of datasources accessible to the authenticated user for an org.
 * @summary List Organization Datasources
 */
export const getListOrganizationDatasourcesUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}/datasources`;
};

export const listOrganizationDatasources = async (
	organizationId: string,
	options?: RequestInit,
): Promise<ListDatasourcesResponse> => {
	return orvalFetch<ListDatasourcesResponse>(
		getListOrganizationDatasourcesUrl(organizationId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getListOrganizationDatasourcesKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}/datasources`] as const;

export type ListOrganizationDatasourcesQueryResult = NonNullable<
	Awaited<ReturnType<typeof listOrganizationDatasources>>
>;
export type ListOrganizationDatasourcesQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary List Organization Datasources
 */
export const useListOrganizationDatasources = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof listOrganizationDatasources>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!organizationId;
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled ? getListOrganizationDatasourcesKey(organizationId) : null);
	const swrFn = () =>
		listOrganizationDatasources(organizationId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Creates a new datasource for the specified organization.
 * @summary Create Datasource
 */
export const getCreateDatasourceUrl = () => {
	return `/v1/m/datasources`;
};

export const createDatasource = async (
	createDatasourceRequest: CreateDatasourceRequest,
	options?: RequestInit,
): Promise<CreateDatasourceResponse> => {
	return orvalFetch<CreateDatasourceResponse>(getCreateDatasourceUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createDatasourceRequest),
	});
};

export const getCreateDatasourceMutationFetcher = (
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, { arg }: { arg: CreateDatasourceRequest }) => {
		return createDatasource(arg, options);
	};
};
export const getCreateDatasourceMutationKey = () =>
	[`/v1/m/datasources`] as const;

export type CreateDatasourceMutationResult = NonNullable<
	Awaited<ReturnType<typeof createDatasource>>
>;
export type CreateDatasourceMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Create Datasource
 */
export const useCreateDatasource = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(options?: {
	swr?: SWRMutationConfiguration<
		Awaited<ReturnType<typeof createDatasource>>,
		TError,
		Key,
		CreateDatasourceRequest,
		Awaited<ReturnType<typeof createDatasource>>
	> & { swrKey?: string };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getCreateDatasourceMutationKey();
	const swrFn = getCreateDatasourceMutationFetcher(requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Update Datasource
 */
export const getUpdateDatasourceUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}`;
};

export const updateDatasource = async (
	datasourceId: string,
	updateDatasourceRequest: UpdateDatasourceRequest,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(getUpdateDatasourceUrl(datasourceId), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(updateDatasourceRequest),
	});
};

export const getUpdateDatasourceMutationFetcher = (
	datasourceId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, { arg }: { arg: UpdateDatasourceRequest }) => {
		return updateDatasource(datasourceId, arg, options);
	};
};
export const getUpdateDatasourceMutationKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}`] as const;

export type UpdateDatasourceMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateDatasource>>
>;
export type UpdateDatasourceMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Update Datasource
 */
export const useUpdateDatasource = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof updateDatasource>>,
			TError,
			Key,
			UpdateDatasourceRequest,
			Awaited<ReturnType<typeof updateDatasource>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getUpdateDatasourceMutationKey(datasourceId);
	const swrFn = getUpdateDatasourceMutationFetcher(
		datasourceId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns detailed information about a specific datasource.
 * @summary Get Datasource
 */
export const getGetDatasourceUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}`;
};

export const getDatasource = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<GetDatasourceResponse> => {
	return orvalFetch<GetDatasourceResponse>(getGetDatasourceUrl(datasourceId), {
		...options,
		method: "GET",
	});
};

export const getGetDatasourceKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}`] as const;

export type GetDatasourceQueryResult = NonNullable<
	Awaited<ReturnType<typeof getDatasource>>
>;
export type GetDatasourceQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Get Datasource
 */
export const useGetDatasource = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getDatasource>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!datasourceId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getGetDatasourceKey(datasourceId) : null));
	const swrFn = () => getDatasource(datasourceId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Verifies connectivity to a datasource and returns a list of readable tables.
 * @summary Inspect Datasource
 */
export const getInspectDatasourceUrl = (
	datasourceId: string,
	params?: InspectDatasourceParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/inspect?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/inspect`;
};

export const inspectDatasource = async (
	datasourceId: string,
	params?: InspectDatasourceParams,
	options?: RequestInit,
): Promise<InspectDatasourceResponse> => {
	return orvalFetch<InspectDatasourceResponse>(
		getInspectDatasourceUrl(datasourceId, params),
		{
			...options,
			method: "GET",
		},
	);
};

export const getInspectDatasourceKey = (
	datasourceId: string,
	params?: InspectDatasourceParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/inspect`,
		...(params ? [params] : []),
	] as const;

export type InspectDatasourceQueryResult = NonNullable<
	Awaited<ReturnType<typeof inspectDatasource>>
>;
export type InspectDatasourceQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Inspect Datasource
 */
export const useInspectDatasource = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	params?: InspectDatasourceParams,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof inspectDatasource>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!datasourceId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getInspectDatasourceKey(datasourceId, params) : null));
	const swrFn = () => inspectDatasource(datasourceId, params, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Inspects a single table in a datasource and returns a summary of its fields.
 * @summary Inspect Table In Datasource
 */
export const getInspectTableInDatasourceUrl = (
	datasourceId: string,
	tableName: string,
	params?: InspectTableInDatasourceParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/inspect/${tableName}?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/inspect/${tableName}`;
};

export const inspectTableInDatasource = async (
	datasourceId: string,
	tableName: string,
	params?: InspectTableInDatasourceParams,
	options?: RequestInit,
): Promise<InspectDatasourceTableResponse> => {
	return orvalFetch<InspectDatasourceTableResponse>(
		getInspectTableInDatasourceUrl(datasourceId, tableName, params),
		{
			...options,
			method: "GET",
		},
	);
};

export const getInspectTableInDatasourceKey = (
	datasourceId: string,
	tableName: string,
	params?: InspectTableInDatasourceParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/inspect/${tableName}`,
		...(params ? [params] : []),
	] as const;

export type InspectTableInDatasourceQueryResult = NonNullable<
	Awaited<ReturnType<typeof inspectTableInDatasource>>
>;
export type InspectTableInDatasourceQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Inspect Table In Datasource
 */
export const useInspectTableInDatasource = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	tableName: string,
	params?: InspectTableInDatasourceParams,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof inspectTableInDatasource>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && tableName);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getInspectTableInDatasourceKey(datasourceId, tableName, params)
				: null);
	const swrFn = () =>
		inspectTableInDatasource(datasourceId, tableName, params, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Deletes a datasource.

The user must be a member of the organization that owns the datasource.
 * @summary Delete Datasource
 */
export const getDeleteDatasourceUrl = (
	organizationId: string,
	datasourceId: string,
	params?: DeleteDatasourceParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/organizations/${organizationId}/datasources/${datasourceId}?${stringifiedParams}`
		: `/v1/m/organizations/${organizationId}/datasources/${datasourceId}`;
};

export const deleteDatasource = async (
	organizationId: string,
	datasourceId: string,
	params?: DeleteDatasourceParams,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(
		getDeleteDatasourceUrl(organizationId, datasourceId, params),
		{
			...options,
			method: "DELETE",
		},
	);
};

export const getDeleteDatasourceMutationFetcher = (
	organizationId: string,
	datasourceId: string,
	params?: DeleteDatasourceParams,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }) => {
		return deleteDatasource(organizationId, datasourceId, params, options);
	};
};
export const getDeleteDatasourceMutationKey = (
	organizationId: string,
	datasourceId: string,
	params?: DeleteDatasourceParams,
) =>
	[
		`/v1/m/organizations/${organizationId}/datasources/${datasourceId}`,
		...(params ? [params] : []),
	] as const;

export type DeleteDatasourceMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteDatasource>>
>;
export type DeleteDatasourceMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Delete Datasource
 */
export const useDeleteDatasource = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	datasourceId: string,
	params?: DeleteDatasourceParams,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteDatasource>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteDatasource>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getDeleteDatasourceMutationKey(organizationId, datasourceId, params);
	const swrFn = getDeleteDatasourceMutationFetcher(
		organizationId,
		datasourceId,
		params,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary List Participant Types
 */
export const getListParticipantTypesUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/participants`;
};

export const listParticipantTypes = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<ListParticipantsTypeResponse> => {
	return orvalFetch<ListParticipantsTypeResponse>(
		getListParticipantTypesUrl(datasourceId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getListParticipantTypesKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/participants`] as const;

export type ListParticipantTypesQueryResult = NonNullable<
	Awaited<ReturnType<typeof listParticipantTypes>>
>;
export type ListParticipantTypesQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary List Participant Types
 */
export const useListParticipantTypes = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof listParticipantTypes>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!datasourceId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListParticipantTypesKey(datasourceId) : null));
	const swrFn = () => listParticipantTypes(datasourceId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Create Participant Type
 */
export const getCreateParticipantTypeUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/participants`;
};

export const createParticipantType = async (
	datasourceId: string,
	createParticipantsTypeRequest: CreateParticipantsTypeRequest,
	options?: RequestInit,
): Promise<CreateParticipantsTypeResponse> => {
	return orvalFetch<CreateParticipantsTypeResponse>(
		getCreateParticipantTypeUrl(datasourceId),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(createParticipantsTypeRequest),
		},
	);
};

export const getCreateParticipantTypeMutationFetcher = (
	datasourceId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, { arg }: { arg: CreateParticipantsTypeRequest }) => {
		return createParticipantType(datasourceId, arg, options);
	};
};
export const getCreateParticipantTypeMutationKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/participants`] as const;

export type CreateParticipantTypeMutationResult = NonNullable<
	Awaited<ReturnType<typeof createParticipantType>>
>;
export type CreateParticipantTypeMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Create Participant Type
 */
export const useCreateParticipantType = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof createParticipantType>>,
			TError,
			Key,
			CreateParticipantsTypeRequest,
			Awaited<ReturnType<typeof createParticipantType>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getCreateParticipantTypeMutationKey(datasourceId);
	const swrFn = getCreateParticipantTypeMutationFetcher(
		datasourceId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns filter, strata, and metric field metadata for a participant type, including exemplars for
filter fields.
 * @summary Inspect Participant Types
 */
export const getInspectParticipantTypesUrl = (
	datasourceId: string,
	participantId: string,
	params?: InspectParticipantTypesParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/participants/${participantId}/inspect?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/participants/${participantId}/inspect`;
};

export const inspectParticipantTypes = async (
	datasourceId: string,
	participantId: string,
	params?: InspectParticipantTypesParams,
	options?: RequestInit,
): Promise<InspectParticipantTypesResponse> => {
	return orvalFetch<InspectParticipantTypesResponse>(
		getInspectParticipantTypesUrl(datasourceId, participantId, params),
		{
			...options,
			method: "GET",
		},
	);
};

export const getInspectParticipantTypesKey = (
	datasourceId: string,
	participantId: string,
	params?: InspectParticipantTypesParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/participants/${participantId}/inspect`,
		...(params ? [params] : []),
	] as const;

export type InspectParticipantTypesQueryResult = NonNullable<
	Awaited<ReturnType<typeof inspectParticipantTypes>>
>;
export type InspectParticipantTypesQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Inspect Participant Types
 */
export const useInspectParticipantTypes = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	participantId: string,
	params?: InspectParticipantTypesParams,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof inspectParticipantTypes>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && participantId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getInspectParticipantTypesKey(datasourceId, participantId, params)
				: null);
	const swrFn = () =>
		inspectParticipantTypes(
			datasourceId,
			participantId,
			params,
			requestOptions,
		);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Get Participant Type
 */
export const getGetParticipantTypeUrl = (
	datasourceId: string,
	participantId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/participants/${participantId}`;
};

export const getParticipantType = async (
	datasourceId: string,
	participantId: string,
	options?: RequestInit,
): Promise<GetParticipantsTypeResponse> => {
	return orvalFetch<GetParticipantsTypeResponse>(
		getGetParticipantTypeUrl(datasourceId, participantId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetParticipantTypeKey = (
	datasourceId: string,
	participantId: string,
) =>
	[`/v1/m/datasources/${datasourceId}/participants/${participantId}`] as const;

export type GetParticipantTypeQueryResult = NonNullable<
	Awaited<ReturnType<typeof getParticipantType>>
>;
export type GetParticipantTypeQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Get Participant Type
 */
export const useGetParticipantType = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	participantId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getParticipantType>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && participantId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled ? getGetParticipantTypeKey(datasourceId, participantId) : null);
	const swrFn = () =>
		getParticipantType(datasourceId, participantId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Update Participant Type
 */
export const getUpdateParticipantTypeUrl = (
	datasourceId: string,
	participantId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/participants/${participantId}`;
};

export const updateParticipantType = async (
	datasourceId: string,
	participantId: string,
	updateParticipantsTypeRequest: UpdateParticipantsTypeRequest,
	options?: RequestInit,
): Promise<UpdateParticipantsTypeResponse> => {
	return orvalFetch<UpdateParticipantsTypeResponse>(
		getUpdateParticipantTypeUrl(datasourceId, participantId),
		{
			...options,
			method: "PATCH",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(updateParticipantsTypeRequest),
		},
	);
};

export const getUpdateParticipantTypeMutationFetcher = (
	datasourceId: string,
	participantId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, { arg }: { arg: UpdateParticipantsTypeRequest }) => {
		return updateParticipantType(datasourceId, participantId, arg, options);
	};
};
export const getUpdateParticipantTypeMutationKey = (
	datasourceId: string,
	participantId: string,
) =>
	[`/v1/m/datasources/${datasourceId}/participants/${participantId}`] as const;

export type UpdateParticipantTypeMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateParticipantType>>
>;
export type UpdateParticipantTypeMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Update Participant Type
 */
export const useUpdateParticipantType = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	participantId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof updateParticipantType>>,
			TError,
			Key,
			UpdateParticipantsTypeRequest,
			Awaited<ReturnType<typeof updateParticipantType>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getUpdateParticipantTypeMutationKey(datasourceId, participantId);
	const swrFn = getUpdateParticipantTypeMutationFetcher(
		datasourceId,
		participantId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Delete Participant
 */
export const getDeleteParticipantUrl = (
	datasourceId: string,
	participantId: string,
	params?: DeleteParticipantParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/participants/${participantId}?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/participants/${participantId}`;
};

export const deleteParticipant = async (
	datasourceId: string,
	participantId: string,
	params?: DeleteParticipantParams,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(
		getDeleteParticipantUrl(datasourceId, participantId, params),
		{
			...options,
			method: "DELETE",
		},
	);
};

export const getDeleteParticipantMutationFetcher = (
	datasourceId: string,
	participantId: string,
	params?: DeleteParticipantParams,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }) => {
		return deleteParticipant(datasourceId, participantId, params, options);
	};
};
export const getDeleteParticipantMutationKey = (
	datasourceId: string,
	participantId: string,
	params?: DeleteParticipantParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/participants/${participantId}`,
		...(params ? [params] : []),
	] as const;

export type DeleteParticipantMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteParticipant>>
>;
export type DeleteParticipantMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Delete Participant
 */
export const useDeleteParticipant = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	participantId: string,
	params?: DeleteParticipantParams,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteParticipant>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteParticipant>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getDeleteParticipantMutationKey(datasourceId, participantId, params);
	const swrFn = getDeleteParticipantMutationFetcher(
		datasourceId,
		participantId,
		params,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns API keys that have access to the datasource.
 * @summary List Api Keys
 */
export const getListApiKeysUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/apikeys`;
};

export const listApiKeys = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<ListApiKeysResponse> => {
	return orvalFetch<ListApiKeysResponse>(getListApiKeysUrl(datasourceId), {
		...options,
		method: "GET",
	});
};

export const getListApiKeysKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/apikeys`] as const;

export type ListApiKeysQueryResult = NonNullable<
	Awaited<ReturnType<typeof listApiKeys>>
>;
export type ListApiKeysQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary List Api Keys
 */
export const useListApiKeys = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRConfiguration<Awaited<ReturnType<typeof listApiKeys>>, TError> & {
			swrKey?: Key;
			enabled?: boolean;
		};
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!datasourceId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListApiKeysKey(datasourceId) : null));
	const swrFn = () => listApiKeys(datasourceId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Creates an API key for the specified datasource.

The user must belong to the organization that owns the requested datasource.
 * @summary Create Api Key
 */
export const getCreateApiKeyUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/apikeys`;
};

export const createApiKey = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<CreateApiKeyResponse> => {
	return orvalFetch<CreateApiKeyResponse>(getCreateApiKeyUrl(datasourceId), {
		...options,
		method: "POST",
	});
};

export const getCreateApiKeyMutationFetcher = (
	datasourceId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }) => {
		return createApiKey(datasourceId, options);
	};
};
export const getCreateApiKeyMutationKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/apikeys`] as const;

export type CreateApiKeyMutationResult = NonNullable<
	Awaited<ReturnType<typeof createApiKey>>
>;
export type CreateApiKeyMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Create Api Key
 */
export const useCreateApiKey = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof createApiKey>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof createApiKey>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getCreateApiKeyMutationKey(datasourceId);
	const swrFn = getCreateApiKeyMutationFetcher(datasourceId, requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Deletes the specified API key.
 * @summary Delete Api Key
 */
export const getDeleteApiKeyUrl = (
	datasourceId: string,
	apiKeyId: string,
	params?: DeleteApiKeyParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/apikeys/${apiKeyId}?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/apikeys/${apiKeyId}`;
};

export const deleteApiKey = async (
	datasourceId: string,
	apiKeyId: string,
	params?: DeleteApiKeyParams,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(getDeleteApiKeyUrl(datasourceId, apiKeyId, params), {
		...options,
		method: "DELETE",
	});
};

export const getDeleteApiKeyMutationFetcher = (
	datasourceId: string,
	apiKeyId: string,
	params?: DeleteApiKeyParams,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }) => {
		return deleteApiKey(datasourceId, apiKeyId, params, options);
	};
};
export const getDeleteApiKeyMutationKey = (
	datasourceId: string,
	apiKeyId: string,
	params?: DeleteApiKeyParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/apikeys/${apiKeyId}`,
		...(params ? [params] : []),
	] as const;

export type DeleteApiKeyMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteApiKey>>
>;
export type DeleteApiKeyMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Delete Api Key
 */
export const useDeleteApiKey = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	apiKeyId: string,
	params?: DeleteApiKeyParams,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteApiKey>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteApiKey>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getDeleteApiKeyMutationKey(datasourceId, apiKeyId, params);
	const swrFn = getDeleteApiKeyMutationFetcher(
		datasourceId,
		apiKeyId,
		params,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Creates a new experiment in the specified datasource.
 * @summary Create Experiment
 */
export const getCreateExperimentUrl = (
	datasourceId: string,
	params?: CreateExperimentParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/experiments?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/experiments`;
};

export const createExperiment = async (
	datasourceId: string,
	createExperimentRequest: CreateExperimentRequest,
	params?: CreateExperimentParams,
	options?: RequestInit,
): Promise<CreateExperimentResponse> => {
	return orvalFetch<CreateExperimentResponse>(
		getCreateExperimentUrl(datasourceId, params),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(createExperimentRequest),
		},
	);
};

export const getCreateExperimentMutationFetcher = (
	datasourceId: string,
	params?: CreateExperimentParams,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, { arg }: { arg: CreateExperimentRequest }) => {
		return createExperiment(datasourceId, arg, params, options);
	};
};
export const getCreateExperimentMutationKey = (
	datasourceId: string,
	params?: CreateExperimentParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments`,
		...(params ? [params] : []),
	] as const;

export type CreateExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof createExperiment>>
>;
export type CreateExperimentMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Create Experiment
 */
export const useCreateExperiment = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	params?: CreateExperimentParams,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof createExperiment>>,
			TError,
			Key,
			CreateExperimentRequest,
			Awaited<ReturnType<typeof createExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getCreateExperimentMutationKey(datasourceId, params);
	const swrFn = getCreateExperimentMutationFetcher(
		datasourceId,
		params,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * For preassigned experiments, and online experiments (except contextual bandits),
    returns an analysis of the experiment's performance, given datasource and experiment ID.
 * @summary Analyze Experiment
 */
export const getAnalyzeExperimentUrl = (
	datasourceId: string,
	experimentId: string,
	params?: AnalyzeExperimentParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/analyze?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/analyze`;
};

export const analyzeExperiment = async (
	datasourceId: string,
	experimentId: string,
	params?: AnalyzeExperimentParams,
	options?: RequestInit,
): Promise<ExperimentAnalysisResponse> => {
	return orvalFetch<ExperimentAnalysisResponse>(
		getAnalyzeExperimentUrl(datasourceId, experimentId, params),
		{
			...options,
			method: "GET",
		},
	);
};

export const getAnalyzeExperimentKey = (
	datasourceId: string,
	experimentId: string,
	params?: AnalyzeExperimentParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/analyze`,
		...(params ? [params] : []),
	] as const;

export type AnalyzeExperimentQueryResult = NonNullable<
	Awaited<ReturnType<typeof analyzeExperiment>>
>;
export type AnalyzeExperimentQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Analyze Experiment
 */
export const useAnalyzeExperiment = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	params?: AnalyzeExperimentParams,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof analyzeExperiment>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && experimentId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getAnalyzeExperimentKey(datasourceId, experimentId, params)
				: null);
	const swrFn = () =>
		analyzeExperiment(datasourceId, experimentId, params, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * For contextual bandit experiments, returns an analysis of the experiment's performance,
    given datasource and experiment ID and context values as input.
 * @summary Analyze Cmab Experiment
 */
export const getAnalyzeCmabExperimentUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/analyze_cmab`;
};

export const analyzeCmabExperiment = async (
	datasourceId: string,
	experimentId: string,
	cMABContextInputRequest: CMABContextInputRequest,
	options?: RequestInit,
): Promise<ExperimentAnalysisResponse> => {
	return orvalFetch<ExperimentAnalysisResponse>(
		getAnalyzeCmabExperimentUrl(datasourceId, experimentId),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(cMABContextInputRequest),
		},
	);
};

export const getAnalyzeCmabExperimentMutationFetcher = (
	datasourceId: string,
	experimentId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, { arg }: { arg: CMABContextInputRequest }) => {
		return analyzeCmabExperiment(datasourceId, experimentId, arg, options);
	};
};
export const getAnalyzeCmabExperimentMutationKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/analyze_cmab`,
	] as const;

export type AnalyzeCmabExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof analyzeCmabExperiment>>
>;
export type AnalyzeCmabExperimentMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Analyze Cmab Experiment
 */
export const useAnalyzeCmabExperiment = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof analyzeCmabExperiment>>,
			TError,
			Key,
			CMABContextInputRequest,
			Awaited<ReturnType<typeof analyzeCmabExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getAnalyzeCmabExperimentMutationKey(datasourceId, experimentId);
	const swrFn = getAnalyzeCmabExperimentMutationFetcher(
		datasourceId,
		experimentId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Commit Experiment
 */
export const getCommitExperimentUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/commit`;
};

export const commitExperiment = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(getCommitExperimentUrl(datasourceId, experimentId), {
		...options,
		method: "POST",
	});
};

export const getCommitExperimentMutationFetcher = (
	datasourceId: string,
	experimentId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }) => {
		return commitExperiment(datasourceId, experimentId, options);
	};
};
export const getCommitExperimentMutationKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/commit`,
	] as const;

export type CommitExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof commitExperiment>>
>;
export type CommitExperimentMutationError = ErrorType<
	void | HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Commit Experiment
 */
export const useCommitExperiment = <
	TError = ErrorType<void | HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof commitExperiment>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof commitExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getCommitExperimentMutationKey(datasourceId, experimentId);
	const swrFn = getCommitExperimentMutationFetcher(
		datasourceId,
		experimentId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Abandon Experiment
 */
export const getAbandonExperimentUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/abandon`;
};

export const abandonExperiment = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(getAbandonExperimentUrl(datasourceId, experimentId), {
		...options,
		method: "POST",
	});
};

export const getAbandonExperimentMutationFetcher = (
	datasourceId: string,
	experimentId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }) => {
		return abandonExperiment(datasourceId, experimentId, options);
	};
};
export const getAbandonExperimentMutationKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/abandon`,
	] as const;

export type AbandonExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof abandonExperiment>>
>;
export type AbandonExperimentMutationError = ErrorType<
	void | HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Abandon Experiment
 */
export const useAbandonExperiment = <
	TError = ErrorType<void | HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof abandonExperiment>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof abandonExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getAbandonExperimentMutationKey(datasourceId, experimentId);
	const swrFn = getAbandonExperimentMutationFetcher(
		datasourceId,
		experimentId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns a list of experiments in the organization.
 * @summary List Organization Experiments
 */
export const getListOrganizationExperimentsUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}/experiments`;
};

export const listOrganizationExperiments = async (
	organizationId: string,
	options?: RequestInit,
): Promise<ListExperimentsResponse> => {
	return orvalFetch<ListExperimentsResponse>(
		getListOrganizationExperimentsUrl(organizationId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getListOrganizationExperimentsKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}/experiments`] as const;

export type ListOrganizationExperimentsQueryResult = NonNullable<
	Awaited<ReturnType<typeof listOrganizationExperiments>>
>;
export type ListOrganizationExperimentsQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary List Organization Experiments
 */
export const useListOrganizationExperiments = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof listOrganizationExperiments>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!organizationId;
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled ? getListOrganizationExperimentsKey(organizationId) : null);
	const swrFn = () =>
		listOrganizationExperiments(organizationId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns the experiment with the specified ID.
 * @summary Get Experiment For Ui
 */
export const getGetExperimentForUiUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}`;
};

export const getExperimentForUi = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<GetExperimentResponse> => {
	return orvalFetch<GetExperimentResponse>(
		getGetExperimentForUiUrl(datasourceId, experimentId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetExperimentForUiKey = (
	datasourceId: string,
	experimentId: string,
) => [`/v1/m/datasources/${datasourceId}/experiments/${experimentId}`] as const;

export type GetExperimentForUiQueryResult = NonNullable<
	Awaited<ReturnType<typeof getExperimentForUi>>
>;
export type GetExperimentForUiQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Get Experiment For Ui
 */
export const useGetExperimentForUi = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getExperimentForUi>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && experimentId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled ? getGetExperimentForUiKey(datasourceId, experimentId) : null);
	const swrFn = () =>
		getExperimentForUi(datasourceId, experimentId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Update Experiment
 */
export const getUpdateExperimentUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}`;
};

export const updateExperiment = async (
	datasourceId: string,
	experimentId: string,
	updateExperimentRequest: UpdateExperimentRequest,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(getUpdateExperimentUrl(datasourceId, experimentId), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(updateExperimentRequest),
	});
};

export const getUpdateExperimentMutationFetcher = (
	datasourceId: string,
	experimentId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, { arg }: { arg: UpdateExperimentRequest }) => {
		return updateExperiment(datasourceId, experimentId, arg, options);
	};
};
export const getUpdateExperimentMutationKey = (
	datasourceId: string,
	experimentId: string,
) => [`/v1/m/datasources/${datasourceId}/experiments/${experimentId}`] as const;

export type UpdateExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateExperiment>>
>;
export type UpdateExperimentMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Update Experiment
 */
export const useUpdateExperiment = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof updateExperiment>>,
			TError,
			Key,
			UpdateExperimentRequest,
			Awaited<ReturnType<typeof updateExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getUpdateExperimentMutationKey(datasourceId, experimentId);
	const swrFn = getUpdateExperimentMutationFetcher(
		datasourceId,
		experimentId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Deletes the experiment with the specified ID.
 * @summary Delete Experiment
 */
export const getDeleteExperimentUrl = (
	datasourceId: string,
	experimentId: string,
	params?: DeleteExperimentParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/experiments/${experimentId}?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/experiments/${experimentId}`;
};

export const deleteExperiment = async (
	datasourceId: string,
	experimentId: string,
	params?: DeleteExperimentParams,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(
		getDeleteExperimentUrl(datasourceId, experimentId, params),
		{
			...options,
			method: "DELETE",
		},
	);
};

export const getDeleteExperimentMutationFetcher = (
	datasourceId: string,
	experimentId: string,
	params?: DeleteExperimentParams,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }) => {
		return deleteExperiment(datasourceId, experimentId, params, options);
	};
};
export const getDeleteExperimentMutationKey = (
	datasourceId: string,
	experimentId: string,
	params?: DeleteExperimentParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}`,
		...(params ? [params] : []),
	] as const;

export type DeleteExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteExperiment>>
>;
export type DeleteExperimentMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Delete Experiment
 */
export const useDeleteExperiment = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	params?: DeleteExperimentParams,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteExperiment>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getDeleteExperimentMutationKey(datasourceId, experimentId, params);
	const swrFn = getDeleteExperimentMutationFetcher(
		datasourceId,
		experimentId,
		params,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Get Experiment Assignments For Ui
 */
export const getGetExperimentAssignmentsForUiUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments`;
};

export const getExperimentAssignmentsForUi = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<GetExperimentAssignmentsResponse> => {
	return orvalFetch<GetExperimentAssignmentsResponse>(
		getGetExperimentAssignmentsForUiUrl(datasourceId, experimentId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetExperimentAssignmentsForUiKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments`,
	] as const;

export type GetExperimentAssignmentsForUiQueryResult = NonNullable<
	Awaited<ReturnType<typeof getExperimentAssignmentsForUi>>
>;
export type GetExperimentAssignmentsForUiQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Get Experiment Assignments For Ui
 */
export const useGetExperimentAssignmentsForUi = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getExperimentAssignmentsForUi>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && experimentId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getGetExperimentAssignmentsForUiKey(datasourceId, experimentId)
				: null);
	const swrFn = () =>
		getExperimentAssignmentsForUi(datasourceId, experimentId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Export experiment assignments as CSV file; BalanceCheck not included. csv header form: participant_id,arm_id,arm_name,strata_name1,strata_name2,...
 */
export const getGetExperimentAssignmentsAsCsvForUiUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments/csv`;
};

export const getExperimentAssignmentsAsCsvForUi = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<unknown> => {
	return orvalFetch<unknown>(
		getGetExperimentAssignmentsAsCsvForUiUrl(datasourceId, experimentId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetExperimentAssignmentsAsCsvForUiKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments/csv`,
	] as const;

export type GetExperimentAssignmentsAsCsvForUiQueryResult = NonNullable<
	Awaited<ReturnType<typeof getExperimentAssignmentsAsCsvForUi>>
>;
export type GetExperimentAssignmentsAsCsvForUiQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Export experiment assignments as CSV file; BalanceCheck not included. csv header form: participant_id,arm_id,arm_name,strata_name1,strata_name2,...
 */
export const useGetExperimentAssignmentsAsCsvForUi = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getExperimentAssignmentsAsCsvForUi>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && experimentId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getGetExperimentAssignmentsAsCsvForUiKey(datasourceId, experimentId)
				: null);
	const swrFn = () =>
		getExperimentAssignmentsAsCsvForUi(
			datasourceId,
			experimentId,
			requestOptions,
		);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Get the assignment for a specific participant, excluding strata if any.
    For 'preassigned' experiments, the participant's Assignment is returned if it exists.
    For 'online', returns the assignment if it exists, else generates an assignment.
 * @summary Get Experiment Assignment For Participant
 */
export const getGetExperimentAssignmentForParticipantUrl = (
	datasourceId: string,
	experimentId: string,
	participantId: string,
	params?: GetExperimentAssignmentForParticipantParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments/${participantId}?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments/${participantId}`;
};

export const getExperimentAssignmentForParticipant = async (
	datasourceId: string,
	experimentId: string,
	participantId: string,
	params?: GetExperimentAssignmentForParticipantParams,
	options?: RequestInit,
): Promise<GetParticipantAssignmentResponse> => {
	return orvalFetch<GetParticipantAssignmentResponse>(
		getGetExperimentAssignmentForParticipantUrl(
			datasourceId,
			experimentId,
			participantId,
			params,
		),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetExperimentAssignmentForParticipantKey = (
	datasourceId: string,
	experimentId: string,
	participantId: string,
	params?: GetExperimentAssignmentForParticipantParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments/${participantId}`,
		...(params ? [params] : []),
	] as const;

export type GetExperimentAssignmentForParticipantQueryResult = NonNullable<
	Awaited<ReturnType<typeof getExperimentAssignmentForParticipant>>
>;
export type GetExperimentAssignmentForParticipantQueryError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Get Experiment Assignment For Participant
 */
export const useGetExperimentAssignmentForParticipant = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	participantId: string,
	params?: GetExperimentAssignmentForParticipantParams,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getExperimentAssignmentForParticipant>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false &&
		!!(datasourceId && experimentId && participantId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getGetExperimentAssignmentForParticipantKey(
						datasourceId,
						experimentId,
						participantId,
						params,
					)
				: null);
	const swrFn = () =>
		getExperimentAssignmentForParticipant(
			datasourceId,
			experimentId,
			participantId,
			params,
			requestOptions,
		);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Deletes specific data associated with an experiment.
 * @summary Delete Experiment Data
 */
export const getDeleteExperimentDataUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/data`;
};

export const deleteExperimentData = async (
	datasourceId: string,
	experimentId: string,
	deleteExperimentDataRequest: DeleteExperimentDataRequest,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(
		getDeleteExperimentDataUrl(datasourceId, experimentId),
		{
			...options,
			method: "DELETE",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(deleteExperimentDataRequest),
		},
	);
};

export const getDeleteExperimentDataMutationFetcher = (
	datasourceId: string,
	experimentId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, { arg }: { arg: DeleteExperimentDataRequest }) => {
		return deleteExperimentData(datasourceId, experimentId, arg, options);
	};
};
export const getDeleteExperimentDataMutationKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/data`,
	] as const;

export type DeleteExperimentDataMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteExperimentData>>
>;
export type DeleteExperimentDataMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Delete Experiment Data
 */
export const useDeleteExperimentData = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteExperimentData>>,
			TError,
			Key,
			DeleteExperimentDataRequest,
			Awaited<ReturnType<typeof deleteExperimentData>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getDeleteExperimentDataMutationKey(datasourceId, experimentId);
	const swrFn = getDeleteExperimentDataMutationFetcher(
		datasourceId,
		experimentId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Update Arm
 */
export const getUpdateArmUrl = (
	datasourceId: string,
	experimentId: string,
	armId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/arms/${armId}`;
};

export const updateArm = async (
	datasourceId: string,
	experimentId: string,
	armId: string,
	updateArmRequest: UpdateArmRequest,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(getUpdateArmUrl(datasourceId, experimentId, armId), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(updateArmRequest),
	});
};

export const getUpdateArmMutationFetcher = (
	datasourceId: string,
	experimentId: string,
	armId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, { arg }: { arg: UpdateArmRequest }) => {
		return updateArm(datasourceId, experimentId, armId, arg, options);
	};
};
export const getUpdateArmMutationKey = (
	datasourceId: string,
	experimentId: string,
	armId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/arms/${armId}`,
	] as const;

export type UpdateArmMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateArm>>
>;
export type UpdateArmMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Update Arm
 */
export const useUpdateArm = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	armId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof updateArm>>,
			TError,
			Key,
			UpdateArmRequest,
			Awaited<ReturnType<typeof updateArm>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getUpdateArmMutationKey(datasourceId, experimentId, armId);
	const swrFn = getUpdateArmMutationFetcher(
		datasourceId,
		experimentId,
		armId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Performs a power check for the specified datasource.
 * @summary Power Check
 */
export const getPowerCheckUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/power`;
};

export const powerCheck = async (
	datasourceId: string,
	powerRequest: PowerRequest,
	options?: RequestInit,
): Promise<PowerResponseOutput> => {
	return orvalFetch<PowerResponseOutput>(getPowerCheckUrl(datasourceId), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(powerRequest),
	});
};

export const getPowerCheckMutationFetcher = (
	datasourceId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, { arg }: { arg: PowerRequest }) => {
		return powerCheck(datasourceId, arg, options);
	};
};
export const getPowerCheckMutationKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/power`] as const;

export type PowerCheckMutationResult = NonNullable<
	Awaited<ReturnType<typeof powerCheck>>
>;
export type PowerCheckMutationError = ErrorType<
	HTTPExceptionError | HTTPValidationError
>;

/**
 * @summary Power Check
 */
export const usePowerCheck = <
	TError = ErrorType<HTTPExceptionError | HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof powerCheck>>,
			TError,
			Key,
			PowerRequest,
			Awaited<ReturnType<typeof powerCheck>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getPowerCheckMutationKey(datasourceId);
	const swrFn = getPowerCheckMutationFetcher(datasourceId, requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
