/**
 * Generated by orval v7.6.0 üç∫
 * Do not edit manually.
 * xngin: Experiments API
 * OpenAPI spec version: 0.9.0
 */
import useSwr from "swr";
import type { Arguments, Key, SWRConfiguration } from "swr";

import useSWRMutation from "swr/mutation";
import type { SWRMutationConfiguration } from "swr/mutation";

import type {
	AddMemberToOrganizationRequest,
	CreateApiKeyRequest,
	CreateApiKeyResponse,
	CreateDatasourceRequest,
	CreateDatasourceResponse,
	CreateExperimentRequest,
	CreateExperimentWithAssignmentParams,
	CreateExperimentWithAssignmentResponse,
	CreateOrganizationRequest,
	CreateOrganizationResponse,
	CreateParticipantsTypeRequest,
	CreateParticipantsTypeResponse,
	ExperimentConfig,
	GetDatasourceResponse,
	GetExperimentAssigmentsResponse,
	GetOrganizationResponse,
	HTTPValidationError,
	InspectDatasourceParams,
	InspectDatasourceResponse,
	InspectDatasourceTableResponse,
	InspectParticipantTypesParams,
	InspectParticipantTypesResponse,
	InspectTableInDatasourceParams,
	ListApiKeysResponse,
	ListDatasourcesResponse,
	ListExperimentsResponse,
	ListOrganizationsResponse,
	ListParticipantsTypeResponse,
	ParticipantsConfig,
	PowerRequest,
	PowerResponseOutput,
	TokenInfo,
	UpdateDatasourceRequest,
	UpdateOrganizationRequest,
	UpdateParticipantsTypeRequest,
	UpdateParticipantsTypeResponse,
} from "./methods.schemas";

import { orvalFetch } from "../services/orval-fetch";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Returns basic metadata about the authenticated caller of this method.
 * @summary Caller Identity
 */
export type callerIdentityResponse200 = {
	data: TokenInfo;
	status: 200;
};

export type callerIdentityResponseComposite = callerIdentityResponse200;

export type callerIdentityResponse = callerIdentityResponseComposite & {
	headers: Headers;
};

export const getCallerIdentityUrl = () => {
	return `/v1/m/caller-identity`;
};

export const callerIdentity = async (
	options?: RequestInit,
): Promise<callerIdentityResponse> => {
	return orvalFetch<callerIdentityResponse>(getCallerIdentityUrl(), {
		...options,
		method: "GET",
	});
};

export const getCallerIdentityKey = () => [`/v1/m/caller-identity`] as const;

export type CallerIdentityQueryResult = NonNullable<
	Awaited<ReturnType<typeof callerIdentity>>
>;
export type CallerIdentityQueryError = unknown;

/**
 * @summary Caller Identity
 */
export const useCallerIdentity = <TError = unknown>(options?: {
	swr?: SWRConfiguration<Awaited<ReturnType<typeof callerIdentity>>, TError> & {
		swrKey?: Key;
		enabled?: boolean;
	};
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ?? (() => (isEnabled ? getCallerIdentityKey() : null));
	const swrFn = () => callerIdentity(requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns a list of organizations that the authenticated user is a member of.
 * @summary List Organizations
 */
export type listOrganizationsResponse200 = {
	data: ListOrganizationsResponse;
	status: 200;
};

export type listOrganizationsResponseComposite = listOrganizationsResponse200;

export type listOrganizationsResponse = listOrganizationsResponseComposite & {
	headers: Headers;
};

export const getListOrganizationsUrl = () => {
	return `/v1/m/organizations`;
};

export const listOrganizations = async (
	options?: RequestInit,
): Promise<listOrganizationsResponse> => {
	return orvalFetch<listOrganizationsResponse>(getListOrganizationsUrl(), {
		...options,
		method: "GET",
	});
};

export const getListOrganizationsKey = () => [`/v1/m/organizations`] as const;

export type ListOrganizationsQueryResult = NonNullable<
	Awaited<ReturnType<typeof listOrganizations>>
>;
export type ListOrganizationsQueryError = unknown;

/**
 * @summary List Organizations
 */
export const useListOrganizations = <TError = unknown>(options?: {
	swr?: SWRConfiguration<
		Awaited<ReturnType<typeof listOrganizations>>,
		TError
	> & { swrKey?: Key; enabled?: boolean };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListOrganizationsKey() : null));
	const swrFn = () => listOrganizations(requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Creates a new organization.

Only users with an @agency.fund email address can create organizations.
 * @summary Create Organizations
 */
export type createOrganizationsResponse200 = {
	data: CreateOrganizationResponse;
	status: 200;
};

export type createOrganizationsResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type createOrganizationsResponseComposite =
	| createOrganizationsResponse200
	| createOrganizationsResponse422;

export type createOrganizationsResponse =
	createOrganizationsResponseComposite & {
		headers: Headers;
	};

export const getCreateOrganizationsUrl = () => {
	return `/v1/m/organizations`;
};

export const createOrganizations = async (
	createOrganizationRequest: CreateOrganizationRequest,
	options?: RequestInit,
): Promise<createOrganizationsResponse> => {
	return orvalFetch<createOrganizationsResponse>(getCreateOrganizationsUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createOrganizationRequest),
	});
};

export const getCreateOrganizationsMutationFetcher = (
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: CreateOrganizationRequest },
	): Promise<createOrganizationsResponse> => {
		return createOrganizations(arg, options);
	};
};
export const getCreateOrganizationsMutationKey = () =>
	[`/v1/m/organizations`] as const;

export type CreateOrganizationsMutationResult = NonNullable<
	Awaited<ReturnType<typeof createOrganizations>>
>;
export type CreateOrganizationsMutationError = HTTPValidationError;

/**
 * @summary Create Organizations
 */
export const useCreateOrganizations = <TError = HTTPValidationError>(options?: {
	swr?: SWRMutationConfiguration<
		Awaited<ReturnType<typeof createOrganizations>>,
		TError,
		Key,
		CreateOrganizationRequest,
		Awaited<ReturnType<typeof createOrganizations>>
	> & { swrKey?: string };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getCreateOrganizationsMutationKey();
	const swrFn = getCreateOrganizationsMutationFetcher(requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Adds a new member to an organization.

The authenticated user must be part of the organization to add members.
 * @summary Add Member To Organization
 */
export type addMemberToOrganizationResponse204 = {
	data: void;
	status: 204;
};

export type addMemberToOrganizationResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type addMemberToOrganizationResponseComposite =
	| addMemberToOrganizationResponse204
	| addMemberToOrganizationResponse422;

export type addMemberToOrganizationResponse =
	addMemberToOrganizationResponseComposite & {
		headers: Headers;
	};

export const getAddMemberToOrganizationUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}/members`;
};

export const addMemberToOrganization = async (
	organizationId: string,
	addMemberToOrganizationRequest: AddMemberToOrganizationRequest,
	options?: RequestInit,
): Promise<addMemberToOrganizationResponse> => {
	return orvalFetch<addMemberToOrganizationResponse>(
		getAddMemberToOrganizationUrl(organizationId),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(addMemberToOrganizationRequest),
		},
	);
};

export const getAddMemberToOrganizationMutationFetcher = (
	organizationId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: AddMemberToOrganizationRequest },
	): Promise<addMemberToOrganizationResponse> => {
		return addMemberToOrganization(organizationId, arg, options);
	};
};
export const getAddMemberToOrganizationMutationKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}/members`] as const;

export type AddMemberToOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof addMemberToOrganization>>
>;
export type AddMemberToOrganizationMutationError = HTTPValidationError;

/**
 * @summary Add Member To Organization
 */
export const useAddMemberToOrganization = <TError = HTTPValidationError>(
	organizationId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof addMemberToOrganization>>,
			TError,
			Key,
			AddMemberToOrganizationRequest,
			Awaited<ReturnType<typeof addMemberToOrganization>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getAddMemberToOrganizationMutationKey(organizationId);
	const swrFn = getAddMemberToOrganizationMutationFetcher(
		organizationId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Removes a member from an organization.

The authenticated user must be part of the organization to remove members.
 * @summary Remove Member From Organization
 */
export type removeMemberFromOrganizationResponse204 = {
	data: void;
	status: 204;
};

export type removeMemberFromOrganizationResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type removeMemberFromOrganizationResponseComposite =
	| removeMemberFromOrganizationResponse204
	| removeMemberFromOrganizationResponse422;

export type removeMemberFromOrganizationResponse =
	removeMemberFromOrganizationResponseComposite & {
		headers: Headers;
	};

export const getRemoveMemberFromOrganizationUrl = (
	organizationId: string,
	userId: string,
) => {
	return `/v1/m/organizations/${organizationId}/members/${userId}`;
};

export const removeMemberFromOrganization = async (
	organizationId: string,
	userId: string,
	options?: RequestInit,
): Promise<removeMemberFromOrganizationResponse> => {
	return orvalFetch<removeMemberFromOrganizationResponse>(
		getRemoveMemberFromOrganizationUrl(organizationId, userId),
		{
			...options,
			method: "DELETE",
		},
	);
};

export const getRemoveMemberFromOrganizationMutationFetcher = (
	organizationId: string,
	userId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		__: { arg: Arguments },
	): Promise<removeMemberFromOrganizationResponse> => {
		return removeMemberFromOrganization(organizationId, userId, options);
	};
};
export const getRemoveMemberFromOrganizationMutationKey = (
	organizationId: string,
	userId: string,
) => [`/v1/m/organizations/${organizationId}/members/${userId}`] as const;

export type RemoveMemberFromOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof removeMemberFromOrganization>>
>;
export type RemoveMemberFromOrganizationMutationError = HTTPValidationError;

/**
 * @summary Remove Member From Organization
 */
export const useRemoveMemberFromOrganization = <TError = HTTPValidationError>(
	organizationId: string,
	userId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof removeMemberFromOrganization>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof removeMemberFromOrganization>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getRemoveMemberFromOrganizationMutationKey(organizationId, userId);
	const swrFn = getRemoveMemberFromOrganizationMutationFetcher(
		organizationId,
		userId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Updates an organization's properties.

The authenticated user must be a member of the organization.
Currently only supports updating the organization name.
 * @summary Update Organization
 */
export type updateOrganizationResponse200 = {
	data: unknown;
	status: 200;
};

export type updateOrganizationResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type updateOrganizationResponseComposite =
	| updateOrganizationResponse200
	| updateOrganizationResponse422;

export type updateOrganizationResponse = updateOrganizationResponseComposite & {
	headers: Headers;
};

export const getUpdateOrganizationUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}`;
};

export const updateOrganization = async (
	organizationId: string,
	updateOrganizationRequest: UpdateOrganizationRequest,
	options?: RequestInit,
): Promise<updateOrganizationResponse> => {
	return orvalFetch<updateOrganizationResponse>(
		getUpdateOrganizationUrl(organizationId),
		{
			...options,
			method: "PATCH",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(updateOrganizationRequest),
		},
	);
};

export const getUpdateOrganizationMutationFetcher = (
	organizationId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: UpdateOrganizationRequest },
	): Promise<updateOrganizationResponse> => {
		return updateOrganization(organizationId, arg, options);
	};
};
export const getUpdateOrganizationMutationKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}`] as const;

export type UpdateOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateOrganization>>
>;
export type UpdateOrganizationMutationError = HTTPValidationError;

/**
 * @summary Update Organization
 */
export const useUpdateOrganization = <TError = HTTPValidationError>(
	organizationId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof updateOrganization>>,
			TError,
			Key,
			UpdateOrganizationRequest,
			Awaited<ReturnType<typeof updateOrganization>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getUpdateOrganizationMutationKey(organizationId);
	const swrFn = getUpdateOrganizationMutationFetcher(
		organizationId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns detailed information about a specific organization.

The authenticated user must be a member of the organization.
 * @summary Get Organization
 */
export type getOrganizationResponse200 = {
	data: GetOrganizationResponse;
	status: 200;
};

export type getOrganizationResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getOrganizationResponseComposite =
	| getOrganizationResponse200
	| getOrganizationResponse422;

export type getOrganizationResponse = getOrganizationResponseComposite & {
	headers: Headers;
};

export const getGetOrganizationUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}`;
};

export const getOrganization = async (
	organizationId: string,
	options?: RequestInit,
): Promise<getOrganizationResponse> => {
	return orvalFetch<getOrganizationResponse>(
		getGetOrganizationUrl(organizationId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetOrganizationKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}`] as const;

export type GetOrganizationQueryResult = NonNullable<
	Awaited<ReturnType<typeof getOrganization>>
>;
export type GetOrganizationQueryError = HTTPValidationError;

/**
 * @summary Get Organization
 */
export const useGetOrganization = <TError = HTTPValidationError>(
	organizationId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getOrganization>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!organizationId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getGetOrganizationKey(organizationId) : null));
	const swrFn = () => getOrganization(organizationId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns a list of datasources accessible to the authenticated user.
 * @summary List Datasources
 */
export type listDatasourcesResponse200 = {
	data: ListDatasourcesResponse;
	status: 200;
};

export type listDatasourcesResponseComposite = listDatasourcesResponse200;

export type listDatasourcesResponse = listDatasourcesResponseComposite & {
	headers: Headers;
};

export const getListDatasourcesUrl = () => {
	return `/v1/m/datasources`;
};

export const listDatasources = async (
	options?: RequestInit,
): Promise<listDatasourcesResponse> => {
	return orvalFetch<listDatasourcesResponse>(getListDatasourcesUrl(), {
		...options,
		method: "GET",
	});
};

export const getListDatasourcesKey = () => [`/v1/m/datasources`] as const;

export type ListDatasourcesQueryResult = NonNullable<
	Awaited<ReturnType<typeof listDatasources>>
>;
export type ListDatasourcesQueryError = unknown;

/**
 * @summary List Datasources
 */
export const useListDatasources = <TError = unknown>(options?: {
	swr?: SWRConfiguration<
		Awaited<ReturnType<typeof listDatasources>>,
		TError
	> & { swrKey?: Key; enabled?: boolean };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ?? (() => (isEnabled ? getListDatasourcesKey() : null));
	const swrFn = () => listDatasources(requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Creates a new datasource for the specified organization.
 * @summary Create Datasource
 */
export type createDatasourceResponse200 = {
	data: CreateDatasourceResponse;
	status: 200;
};

export type createDatasourceResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type createDatasourceResponseComposite =
	| createDatasourceResponse200
	| createDatasourceResponse422;

export type createDatasourceResponse = createDatasourceResponseComposite & {
	headers: Headers;
};

export const getCreateDatasourceUrl = () => {
	return `/v1/m/datasources`;
};

export const createDatasource = async (
	createDatasourceRequest: CreateDatasourceRequest,
	options?: RequestInit,
): Promise<createDatasourceResponse> => {
	return orvalFetch<createDatasourceResponse>(getCreateDatasourceUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createDatasourceRequest),
	});
};

export const getCreateDatasourceMutationFetcher = (
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: CreateDatasourceRequest },
	): Promise<createDatasourceResponse> => {
		return createDatasource(arg, options);
	};
};
export const getCreateDatasourceMutationKey = () =>
	[`/v1/m/datasources`] as const;

export type CreateDatasourceMutationResult = NonNullable<
	Awaited<ReturnType<typeof createDatasource>>
>;
export type CreateDatasourceMutationError = HTTPValidationError;

/**
 * @summary Create Datasource
 */
export const useCreateDatasource = <TError = HTTPValidationError>(options?: {
	swr?: SWRMutationConfiguration<
		Awaited<ReturnType<typeof createDatasource>>,
		TError,
		Key,
		CreateDatasourceRequest,
		Awaited<ReturnType<typeof createDatasource>>
	> & { swrKey?: string };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getCreateDatasourceMutationKey();
	const swrFn = getCreateDatasourceMutationFetcher(requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Update Datasource
 */
export type updateDatasourceResponse200 = {
	data: unknown;
	status: 200;
};

export type updateDatasourceResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type updateDatasourceResponseComposite =
	| updateDatasourceResponse200
	| updateDatasourceResponse422;

export type updateDatasourceResponse = updateDatasourceResponseComposite & {
	headers: Headers;
};

export const getUpdateDatasourceUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}`;
};

export const updateDatasource = async (
	datasourceId: string,
	updateDatasourceRequest: UpdateDatasourceRequest,
	options?: RequestInit,
): Promise<updateDatasourceResponse> => {
	return orvalFetch<updateDatasourceResponse>(
		getUpdateDatasourceUrl(datasourceId),
		{
			...options,
			method: "PATCH",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(updateDatasourceRequest),
		},
	);
};

export const getUpdateDatasourceMutationFetcher = (
	datasourceId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: UpdateDatasourceRequest },
	): Promise<updateDatasourceResponse> => {
		return updateDatasource(datasourceId, arg, options);
	};
};
export const getUpdateDatasourceMutationKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}`] as const;

export type UpdateDatasourceMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateDatasource>>
>;
export type UpdateDatasourceMutationError = HTTPValidationError;

/**
 * @summary Update Datasource
 */
export const useUpdateDatasource = <TError = HTTPValidationError>(
	datasourceId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof updateDatasource>>,
			TError,
			Key,
			UpdateDatasourceRequest,
			Awaited<ReturnType<typeof updateDatasource>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getUpdateDatasourceMutationKey(datasourceId);
	const swrFn = getUpdateDatasourceMutationFetcher(
		datasourceId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns detailed information about a specific datasource.
 * @summary Get Datasource
 */
export type getDatasourceResponse200 = {
	data: GetDatasourceResponse;
	status: 200;
};

export type getDatasourceResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getDatasourceResponseComposite =
	| getDatasourceResponse200
	| getDatasourceResponse422;

export type getDatasourceResponse = getDatasourceResponseComposite & {
	headers: Headers;
};

export const getGetDatasourceUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}`;
};

export const getDatasource = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<getDatasourceResponse> => {
	return orvalFetch<getDatasourceResponse>(getGetDatasourceUrl(datasourceId), {
		...options,
		method: "GET",
	});
};

export const getGetDatasourceKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}`] as const;

export type GetDatasourceQueryResult = NonNullable<
	Awaited<ReturnType<typeof getDatasource>>
>;
export type GetDatasourceQueryError = HTTPValidationError;

/**
 * @summary Get Datasource
 */
export const useGetDatasource = <TError = HTTPValidationError>(
	datasourceId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getDatasource>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!datasourceId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getGetDatasourceKey(datasourceId) : null));
	const swrFn = () => getDatasource(datasourceId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Deletes a datasource.

The user must be a member of the organization that owns the datasource.
 * @summary Delete Datasource
 */
export type deleteDatasourceResponse204 = {
	data: void;
	status: 204;
};

export type deleteDatasourceResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type deleteDatasourceResponseComposite =
	| deleteDatasourceResponse204
	| deleteDatasourceResponse422;

export type deleteDatasourceResponse = deleteDatasourceResponseComposite & {
	headers: Headers;
};

export const getDeleteDatasourceUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}`;
};

export const deleteDatasource = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<deleteDatasourceResponse> => {
	return orvalFetch<deleteDatasourceResponse>(
		getDeleteDatasourceUrl(datasourceId),
		{
			...options,
			method: "DELETE",
		},
	);
};

export const getDeleteDatasourceMutationFetcher = (
	datasourceId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		__: { arg: Arguments },
	): Promise<deleteDatasourceResponse> => {
		return deleteDatasource(datasourceId, options);
	};
};
export const getDeleteDatasourceMutationKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}`] as const;

export type DeleteDatasourceMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteDatasource>>
>;
export type DeleteDatasourceMutationError = HTTPValidationError;

/**
 * @summary Delete Datasource
 */
export const useDeleteDatasource = <TError = HTTPValidationError>(
	datasourceId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteDatasource>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteDatasource>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getDeleteDatasourceMutationKey(datasourceId);
	const swrFn = getDeleteDatasourceMutationFetcher(
		datasourceId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Verifies connectivity to a datasource and returns a list of readable tables.
 * @summary Inspect Datasource
 */
export type inspectDatasourceResponse200 = {
	data: InspectDatasourceResponse;
	status: 200;
};

export type inspectDatasourceResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type inspectDatasourceResponseComposite =
	| inspectDatasourceResponse200
	| inspectDatasourceResponse422;

export type inspectDatasourceResponse = inspectDatasourceResponseComposite & {
	headers: Headers;
};

export const getInspectDatasourceUrl = (
	datasourceId: string,
	params?: InspectDatasourceParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/inspect?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/inspect`;
};

export const inspectDatasource = async (
	datasourceId: string,
	params?: InspectDatasourceParams,
	options?: RequestInit,
): Promise<inspectDatasourceResponse> => {
	return orvalFetch<inspectDatasourceResponse>(
		getInspectDatasourceUrl(datasourceId, params),
		{
			...options,
			method: "GET",
		},
	);
};

export const getInspectDatasourceKey = (
	datasourceId: string,
	params?: InspectDatasourceParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/inspect`,
		...(params ? [params] : []),
	] as const;

export type InspectDatasourceQueryResult = NonNullable<
	Awaited<ReturnType<typeof inspectDatasource>>
>;
export type InspectDatasourceQueryError = HTTPValidationError;

/**
 * @summary Inspect Datasource
 */
export const useInspectDatasource = <TError = HTTPValidationError>(
	datasourceId: string,
	params?: InspectDatasourceParams,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof inspectDatasource>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!datasourceId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getInspectDatasourceKey(datasourceId, params) : null));
	const swrFn = () => inspectDatasource(datasourceId, params, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Inspects a single table in a datasource and returns a summary of its fields.
 * @summary Inspect Table In Datasource
 */
export type inspectTableInDatasourceResponse200 = {
	data: InspectDatasourceTableResponse;
	status: 200;
};

export type inspectTableInDatasourceResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type inspectTableInDatasourceResponseComposite =
	| inspectTableInDatasourceResponse200
	| inspectTableInDatasourceResponse422;

export type inspectTableInDatasourceResponse =
	inspectTableInDatasourceResponseComposite & {
		headers: Headers;
	};

export const getInspectTableInDatasourceUrl = (
	datasourceId: string,
	tableName: string,
	params?: InspectTableInDatasourceParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/inspect/${tableName}?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/inspect/${tableName}`;
};

export const inspectTableInDatasource = async (
	datasourceId: string,
	tableName: string,
	params?: InspectTableInDatasourceParams,
	options?: RequestInit,
): Promise<inspectTableInDatasourceResponse> => {
	return orvalFetch<inspectTableInDatasourceResponse>(
		getInspectTableInDatasourceUrl(datasourceId, tableName, params),
		{
			...options,
			method: "GET",
		},
	);
};

export const getInspectTableInDatasourceKey = (
	datasourceId: string,
	tableName: string,
	params?: InspectTableInDatasourceParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/inspect/${tableName}`,
		...(params ? [params] : []),
	] as const;

export type InspectTableInDatasourceQueryResult = NonNullable<
	Awaited<ReturnType<typeof inspectTableInDatasource>>
>;
export type InspectTableInDatasourceQueryError = HTTPValidationError;

/**
 * @summary Inspect Table In Datasource
 */
export const useInspectTableInDatasource = <TError = HTTPValidationError>(
	datasourceId: string,
	tableName: string,
	params?: InspectTableInDatasourceParams,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof inspectTableInDatasource>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && tableName);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getInspectTableInDatasourceKey(datasourceId, tableName, params)
				: null);
	const swrFn = () =>
		inspectTableInDatasource(datasourceId, tableName, params, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary List Participant Types
 */
export type listParticipantTypesResponse200 = {
	data: ListParticipantsTypeResponse;
	status: 200;
};

export type listParticipantTypesResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type listParticipantTypesResponseComposite =
	| listParticipantTypesResponse200
	| listParticipantTypesResponse422;

export type listParticipantTypesResponse =
	listParticipantTypesResponseComposite & {
		headers: Headers;
	};

export const getListParticipantTypesUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/participants`;
};

export const listParticipantTypes = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<listParticipantTypesResponse> => {
	return orvalFetch<listParticipantTypesResponse>(
		getListParticipantTypesUrl(datasourceId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getListParticipantTypesKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/participants`] as const;

export type ListParticipantTypesQueryResult = NonNullable<
	Awaited<ReturnType<typeof listParticipantTypes>>
>;
export type ListParticipantTypesQueryError = HTTPValidationError;

/**
 * @summary List Participant Types
 */
export const useListParticipantTypes = <TError = HTTPValidationError>(
	datasourceId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof listParticipantTypes>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!datasourceId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListParticipantTypesKey(datasourceId) : null));
	const swrFn = () => listParticipantTypes(datasourceId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Create Participant Type
 */
export type createParticipantTypeResponse200 = {
	data: CreateParticipantsTypeResponse;
	status: 200;
};

export type createParticipantTypeResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type createParticipantTypeResponseComposite =
	| createParticipantTypeResponse200
	| createParticipantTypeResponse422;

export type createParticipantTypeResponse =
	createParticipantTypeResponseComposite & {
		headers: Headers;
	};

export const getCreateParticipantTypeUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/participants`;
};

export const createParticipantType = async (
	datasourceId: string,
	createParticipantsTypeRequest: CreateParticipantsTypeRequest,
	options?: RequestInit,
): Promise<createParticipantTypeResponse> => {
	return orvalFetch<createParticipantTypeResponse>(
		getCreateParticipantTypeUrl(datasourceId),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(createParticipantsTypeRequest),
		},
	);
};

export const getCreateParticipantTypeMutationFetcher = (
	datasourceId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: CreateParticipantsTypeRequest },
	): Promise<createParticipantTypeResponse> => {
		return createParticipantType(datasourceId, arg, options);
	};
};
export const getCreateParticipantTypeMutationKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/participants`] as const;

export type CreateParticipantTypeMutationResult = NonNullable<
	Awaited<ReturnType<typeof createParticipantType>>
>;
export type CreateParticipantTypeMutationError = HTTPValidationError;

/**
 * @summary Create Participant Type
 */
export const useCreateParticipantType = <TError = HTTPValidationError>(
	datasourceId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof createParticipantType>>,
			TError,
			Key,
			CreateParticipantsTypeRequest,
			Awaited<ReturnType<typeof createParticipantType>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getCreateParticipantTypeMutationKey(datasourceId);
	const swrFn = getCreateParticipantTypeMutationFetcher(
		datasourceId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns filter, strata, and metric field metadata for a participant type, including exemplars for filter fields.
 * @summary Inspect Participant Types
 */
export type inspectParticipantTypesResponse200 = {
	data: InspectParticipantTypesResponse;
	status: 200;
};

export type inspectParticipantTypesResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type inspectParticipantTypesResponseComposite =
	| inspectParticipantTypesResponse200
	| inspectParticipantTypesResponse422;

export type inspectParticipantTypesResponse =
	inspectParticipantTypesResponseComposite & {
		headers: Headers;
	};

export const getInspectParticipantTypesUrl = (
	datasourceId: string,
	participantId: string,
	params?: InspectParticipantTypesParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/participants/${participantId}/inspect?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/participants/${participantId}/inspect`;
};

export const inspectParticipantTypes = async (
	datasourceId: string,
	participantId: string,
	params?: InspectParticipantTypesParams,
	options?: RequestInit,
): Promise<inspectParticipantTypesResponse> => {
	return orvalFetch<inspectParticipantTypesResponse>(
		getInspectParticipantTypesUrl(datasourceId, participantId, params),
		{
			...options,
			method: "GET",
		},
	);
};

export const getInspectParticipantTypesKey = (
	datasourceId: string,
	participantId: string,
	params?: InspectParticipantTypesParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/participants/${participantId}/inspect`,
		...(params ? [params] : []),
	] as const;

export type InspectParticipantTypesQueryResult = NonNullable<
	Awaited<ReturnType<typeof inspectParticipantTypes>>
>;
export type InspectParticipantTypesQueryError = HTTPValidationError;

/**
 * @summary Inspect Participant Types
 */
export const useInspectParticipantTypes = <TError = HTTPValidationError>(
	datasourceId: string,
	participantId: string,
	params?: InspectParticipantTypesParams,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof inspectParticipantTypes>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && participantId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getInspectParticipantTypesKey(datasourceId, participantId, params)
				: null);
	const swrFn = () =>
		inspectParticipantTypes(
			datasourceId,
			participantId,
			params,
			requestOptions,
		);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Get Participant Types
 */
export type getParticipantTypesResponse200 = {
	data: ParticipantsConfig;
	status: 200;
};

export type getParticipantTypesResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getParticipantTypesResponseComposite =
	| getParticipantTypesResponse200
	| getParticipantTypesResponse422;

export type getParticipantTypesResponse =
	getParticipantTypesResponseComposite & {
		headers: Headers;
	};

export const getGetParticipantTypesUrl = (
	datasourceId: string,
	participantId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/participants/${participantId}`;
};

export const getParticipantTypes = async (
	datasourceId: string,
	participantId: string,
	options?: RequestInit,
): Promise<getParticipantTypesResponse> => {
	return orvalFetch<getParticipantTypesResponse>(
		getGetParticipantTypesUrl(datasourceId, participantId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetParticipantTypesKey = (
	datasourceId: string,
	participantId: string,
) =>
	[`/v1/m/datasources/${datasourceId}/participants/${participantId}`] as const;

export type GetParticipantTypesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getParticipantTypes>>
>;
export type GetParticipantTypesQueryError = HTTPValidationError;

/**
 * @summary Get Participant Types
 */
export const useGetParticipantTypes = <TError = HTTPValidationError>(
	datasourceId: string,
	participantId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getParticipantTypes>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && participantId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getGetParticipantTypesKey(datasourceId, participantId)
				: null);
	const swrFn = () =>
		getParticipantTypes(datasourceId, participantId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Update Participant Type
 */
export type updateParticipantTypeResponse200 = {
	data: UpdateParticipantsTypeResponse;
	status: 200;
};

export type updateParticipantTypeResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type updateParticipantTypeResponseComposite =
	| updateParticipantTypeResponse200
	| updateParticipantTypeResponse422;

export type updateParticipantTypeResponse =
	updateParticipantTypeResponseComposite & {
		headers: Headers;
	};

export const getUpdateParticipantTypeUrl = (
	datasourceId: string,
	participantId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/participants/${participantId}`;
};

export const updateParticipantType = async (
	datasourceId: string,
	participantId: string,
	updateParticipantsTypeRequest: UpdateParticipantsTypeRequest,
	options?: RequestInit,
): Promise<updateParticipantTypeResponse> => {
	return orvalFetch<updateParticipantTypeResponse>(
		getUpdateParticipantTypeUrl(datasourceId, participantId),
		{
			...options,
			method: "PATCH",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(updateParticipantsTypeRequest),
		},
	);
};

export const getUpdateParticipantTypeMutationFetcher = (
	datasourceId: string,
	participantId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: UpdateParticipantsTypeRequest },
	): Promise<updateParticipantTypeResponse> => {
		return updateParticipantType(datasourceId, participantId, arg, options);
	};
};
export const getUpdateParticipantTypeMutationKey = (
	datasourceId: string,
	participantId: string,
) =>
	[`/v1/m/datasources/${datasourceId}/participants/${participantId}`] as const;

export type UpdateParticipantTypeMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateParticipantType>>
>;
export type UpdateParticipantTypeMutationError = HTTPValidationError;

/**
 * @summary Update Participant Type
 */
export const useUpdateParticipantType = <TError = HTTPValidationError>(
	datasourceId: string,
	participantId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof updateParticipantType>>,
			TError,
			Key,
			UpdateParticipantsTypeRequest,
			Awaited<ReturnType<typeof updateParticipantType>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getUpdateParticipantTypeMutationKey(datasourceId, participantId);
	const swrFn = getUpdateParticipantTypeMutationFetcher(
		datasourceId,
		participantId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Delete Participant
 */
export type deleteParticipantResponse204 = {
	data: void;
	status: 204;
};

export type deleteParticipantResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type deleteParticipantResponseComposite =
	| deleteParticipantResponse204
	| deleteParticipantResponse422;

export type deleteParticipantResponse = deleteParticipantResponseComposite & {
	headers: Headers;
};

export const getDeleteParticipantUrl = (
	datasourceId: string,
	participantId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/participants/${participantId}`;
};

export const deleteParticipant = async (
	datasourceId: string,
	participantId: string,
	options?: RequestInit,
): Promise<deleteParticipantResponse> => {
	return orvalFetch<deleteParticipantResponse>(
		getDeleteParticipantUrl(datasourceId, participantId),
		{
			...options,
			method: "DELETE",
		},
	);
};

export const getDeleteParticipantMutationFetcher = (
	datasourceId: string,
	participantId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		__: { arg: Arguments },
	): Promise<deleteParticipantResponse> => {
		return deleteParticipant(datasourceId, participantId, options);
	};
};
export const getDeleteParticipantMutationKey = (
	datasourceId: string,
	participantId: string,
) =>
	[`/v1/m/datasources/${datasourceId}/participants/${participantId}`] as const;

export type DeleteParticipantMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteParticipant>>
>;
export type DeleteParticipantMutationError = HTTPValidationError;

/**
 * @summary Delete Participant
 */
export const useDeleteParticipant = <TError = HTTPValidationError>(
	datasourceId: string,
	participantId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteParticipant>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteParticipant>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getDeleteParticipantMutationKey(datasourceId, participantId);
	const swrFn = getDeleteParticipantMutationFetcher(
		datasourceId,
		participantId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns API keys that the caller has access to via their organization memberships.

An API key is visible if the user belongs to the organization that owns any of the
datasources that the API key can access.
 * @summary List Api Keys
 */
export type listApiKeysResponse200 = {
	data: ListApiKeysResponse;
	status: 200;
};

export type listApiKeysResponseComposite = listApiKeysResponse200;

export type listApiKeysResponse = listApiKeysResponseComposite & {
	headers: Headers;
};

export const getListApiKeysUrl = () => {
	return `/v1/m/apikeys`;
};

export const listApiKeys = async (
	options?: RequestInit,
): Promise<listApiKeysResponse> => {
	return orvalFetch<listApiKeysResponse>(getListApiKeysUrl(), {
		...options,
		method: "GET",
	});
};

export const getListApiKeysKey = () => [`/v1/m/apikeys`] as const;

export type ListApiKeysQueryResult = NonNullable<
	Awaited<ReturnType<typeof listApiKeys>>
>;
export type ListApiKeysQueryError = unknown;

/**
 * @summary List Api Keys
 */
export const useListApiKeys = <TError = unknown>(options?: {
	swr?: SWRConfiguration<Awaited<ReturnType<typeof listApiKeys>>, TError> & {
		swrKey?: Key;
		enabled?: boolean;
	};
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ?? (() => (isEnabled ? getListApiKeysKey() : null));
	const swrFn = () => listApiKeys(requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Creates an API key for the specified datasource.

The user must belong to the organization that owns the requested datasource.
 * @summary Create Api Key
 */
export type createApiKeyResponse200 = {
	data: CreateApiKeyResponse;
	status: 200;
};

export type createApiKeyResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type createApiKeyResponseComposite =
	| createApiKeyResponse200
	| createApiKeyResponse422;

export type createApiKeyResponse = createApiKeyResponseComposite & {
	headers: Headers;
};

export const getCreateApiKeyUrl = () => {
	return `/v1/m/apikeys`;
};

export const createApiKey = async (
	createApiKeyRequest: CreateApiKeyRequest,
	options?: RequestInit,
): Promise<createApiKeyResponse> => {
	return orvalFetch<createApiKeyResponse>(getCreateApiKeyUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createApiKeyRequest),
	});
};

export const getCreateApiKeyMutationFetcher = (
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: CreateApiKeyRequest },
	): Promise<createApiKeyResponse> => {
		return createApiKey(arg, options);
	};
};
export const getCreateApiKeyMutationKey = () => [`/v1/m/apikeys`] as const;

export type CreateApiKeyMutationResult = NonNullable<
	Awaited<ReturnType<typeof createApiKey>>
>;
export type CreateApiKeyMutationError = HTTPValidationError;

/**
 * @summary Create Api Key
 */
export const useCreateApiKey = <TError = HTTPValidationError>(options?: {
	swr?: SWRMutationConfiguration<
		Awaited<ReturnType<typeof createApiKey>>,
		TError,
		Key,
		CreateApiKeyRequest,
		Awaited<ReturnType<typeof createApiKey>>
	> & { swrKey?: string };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getCreateApiKeyMutationKey();
	const swrFn = getCreateApiKeyMutationFetcher(requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Deletes the specified API key.
 * @summary Delete Api Key
 */
export type deleteApiKeyResponse204 = {
	data: void;
	status: 204;
};

export type deleteApiKeyResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type deleteApiKeyResponseComposite =
	| deleteApiKeyResponse204
	| deleteApiKeyResponse422;

export type deleteApiKeyResponse = deleteApiKeyResponseComposite & {
	headers: Headers;
};

export const getDeleteApiKeyUrl = (apiKeyId: string) => {
	return `/v1/m/apikeys/${apiKeyId}`;
};

export const deleteApiKey = async (
	apiKeyId: string,
	options?: RequestInit,
): Promise<deleteApiKeyResponse> => {
	return orvalFetch<deleteApiKeyResponse>(getDeleteApiKeyUrl(apiKeyId), {
		...options,
		method: "DELETE",
	});
};

export const getDeleteApiKeyMutationFetcher = (
	apiKeyId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }): Promise<deleteApiKeyResponse> => {
		return deleteApiKey(apiKeyId, options);
	};
};
export const getDeleteApiKeyMutationKey = (apiKeyId: string) =>
	[`/v1/m/apikeys/${apiKeyId}`] as const;

export type DeleteApiKeyMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteApiKey>>
>;
export type DeleteApiKeyMutationError = HTTPValidationError;

/**
 * @summary Delete Api Key
 */
export const useDeleteApiKey = <TError = HTTPValidationError>(
	apiKeyId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteApiKey>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteApiKey>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getDeleteApiKeyMutationKey(apiKeyId);
	const swrFn = getDeleteApiKeyMutationFetcher(apiKeyId, requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Create Experiment With Assignment
 */
export type createExperimentWithAssignmentResponse200 = {
	data: CreateExperimentWithAssignmentResponse;
	status: 200;
};

export type createExperimentWithAssignmentResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type createExperimentWithAssignmentResponseComposite =
	| createExperimentWithAssignmentResponse200
	| createExperimentWithAssignmentResponse422;

export type createExperimentWithAssignmentResponse =
	createExperimentWithAssignmentResponseComposite & {
		headers: Headers;
	};

export const getCreateExperimentWithAssignmentUrl = (
	datasourceId: string,
	params: CreateExperimentWithAssignmentParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/experiments/${datasourceId}/with-assignment?${stringifiedParams}`
		: `/v1/m/experiments/${datasourceId}/with-assignment`;
};

export const createExperimentWithAssignment = async (
	datasourceId: string,
	createExperimentRequest: CreateExperimentRequest,
	params: CreateExperimentWithAssignmentParams,
	options?: RequestInit,
): Promise<createExperimentWithAssignmentResponse> => {
	return orvalFetch<createExperimentWithAssignmentResponse>(
		getCreateExperimentWithAssignmentUrl(datasourceId, params),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(createExperimentRequest),
		},
	);
};

export const getCreateExperimentWithAssignmentMutationFetcher = (
	datasourceId: string,
	params: CreateExperimentWithAssignmentParams,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: CreateExperimentRequest },
	): Promise<createExperimentWithAssignmentResponse> => {
		return createExperimentWithAssignment(datasourceId, arg, params, options);
	};
};
export const getCreateExperimentWithAssignmentMutationKey = (
	datasourceId: string,
	params: CreateExperimentWithAssignmentParams,
) =>
	[
		`/v1/m/experiments/${datasourceId}/with-assignment`,
		...(params ? [params] : []),
	] as const;

export type CreateExperimentWithAssignmentMutationResult = NonNullable<
	Awaited<ReturnType<typeof createExperimentWithAssignment>>
>;
export type CreateExperimentWithAssignmentMutationError = HTTPValidationError;

/**
 * @summary Create Experiment With Assignment
 */
export const useCreateExperimentWithAssignment = <TError = HTTPValidationError>(
	datasourceId: string,
	params: CreateExperimentWithAssignmentParams,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof createExperimentWithAssignment>>,
			TError,
			Key,
			CreateExperimentRequest,
			Awaited<ReturnType<typeof createExperimentWithAssignment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getCreateExperimentWithAssignmentMutationKey(datasourceId, params);
	const swrFn = getCreateExperimentWithAssignmentMutationFetcher(
		datasourceId,
		params,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Commit Experiment
 */
export type commitExperimentResponse204 = {
	data: void;
	status: 204;
};

export type commitExperimentResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type commitExperimentResponseComposite =
	| commitExperimentResponse204
	| commitExperimentResponse422;

export type commitExperimentResponse = commitExperimentResponseComposite & {
	headers: Headers;
};

export const getCommitExperimentUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/commit`;
};

export const commitExperiment = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<commitExperimentResponse> => {
	return orvalFetch<commitExperimentResponse>(
		getCommitExperimentUrl(datasourceId, experimentId),
		{
			...options,
			method: "POST",
		},
	);
};

export const getCommitExperimentMutationFetcher = (
	datasourceId: string,
	experimentId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		__: { arg: Arguments },
	): Promise<commitExperimentResponse> => {
		return commitExperiment(datasourceId, experimentId, options);
	};
};
export const getCommitExperimentMutationKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/commit`,
	] as const;

export type CommitExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof commitExperiment>>
>;
export type CommitExperimentMutationError = HTTPValidationError;

/**
 * @summary Commit Experiment
 */
export const useCommitExperiment = <TError = HTTPValidationError>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof commitExperiment>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof commitExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getCommitExperimentMutationKey(datasourceId, experimentId);
	const swrFn = getCommitExperimentMutationFetcher(
		datasourceId,
		experimentId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Abandon Experiment
 */
export type abandonExperimentResponse204 = {
	data: void;
	status: 204;
};

export type abandonExperimentResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type abandonExperimentResponseComposite =
	| abandonExperimentResponse204
	| abandonExperimentResponse422;

export type abandonExperimentResponse = abandonExperimentResponseComposite & {
	headers: Headers;
};

export const getAbandonExperimentUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/abandon`;
};

export const abandonExperiment = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<abandonExperimentResponse> => {
	return orvalFetch<abandonExperimentResponse>(
		getAbandonExperimentUrl(datasourceId, experimentId),
		{
			...options,
			method: "POST",
		},
	);
};

export const getAbandonExperimentMutationFetcher = (
	datasourceId: string,
	experimentId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		__: { arg: Arguments },
	): Promise<abandonExperimentResponse> => {
		return abandonExperiment(datasourceId, experimentId, options);
	};
};
export const getAbandonExperimentMutationKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/abandon`,
	] as const;

export type AbandonExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof abandonExperiment>>
>;
export type AbandonExperimentMutationError = HTTPValidationError;

/**
 * @summary Abandon Experiment
 */
export const useAbandonExperiment = <TError = HTTPValidationError>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof abandonExperiment>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof abandonExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getAbandonExperimentMutationKey(datasourceId, experimentId);
	const swrFn = getAbandonExperimentMutationFetcher(
		datasourceId,
		experimentId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns the list of experiments in the datasource.
 * @summary List Experiments
 */
export type listExperimentsResponse200 = {
	data: ListExperimentsResponse;
	status: 200;
};

export type listExperimentsResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type listExperimentsResponseComposite =
	| listExperimentsResponse200
	| listExperimentsResponse422;

export type listExperimentsResponse = listExperimentsResponseComposite & {
	headers: Headers;
};

export const getListExperimentsUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/experiments`;
};

export const listExperiments = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<listExperimentsResponse> => {
	return orvalFetch<listExperimentsResponse>(
		getListExperimentsUrl(datasourceId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getListExperimentsKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/experiments`] as const;

export type ListExperimentsQueryResult = NonNullable<
	Awaited<ReturnType<typeof listExperiments>>
>;
export type ListExperimentsQueryError = HTTPValidationError;

/**
 * @summary List Experiments
 */
export const useListExperiments = <TError = HTTPValidationError>(
	datasourceId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof listExperiments>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!datasourceId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListExperimentsKey(datasourceId) : null));
	const swrFn = () => listExperiments(datasourceId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns the experiment with the specified ID.
 * @summary Get Experiment
 */
export type getExperimentResponse200 = {
	data: ExperimentConfig;
	status: 200;
};

export type getExperimentResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getExperimentResponseComposite =
	| getExperimentResponse200
	| getExperimentResponse422;

export type getExperimentResponse = getExperimentResponseComposite & {
	headers: Headers;
};

export const getGetExperimentUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}`;
};

export const getExperiment = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<getExperimentResponse> => {
	return orvalFetch<getExperimentResponse>(
		getGetExperimentUrl(datasourceId, experimentId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetExperimentKey = (
	datasourceId: string,
	experimentId: string,
) => [`/v1/m/datasources/${datasourceId}/experiments/${experimentId}`] as const;

export type GetExperimentQueryResult = NonNullable<
	Awaited<ReturnType<typeof getExperiment>>
>;
export type GetExperimentQueryError = HTTPValidationError;

/**
 * @summary Get Experiment
 */
export const useGetExperiment = <TError = HTTPValidationError>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getExperiment>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && experimentId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled ? getGetExperimentKey(datasourceId, experimentId) : null);
	const swrFn = () => getExperiment(datasourceId, experimentId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Get Experiment Assignments
 */
export type getExperimentAssignmentsResponse200 = {
	data: GetExperimentAssigmentsResponse;
	status: 200;
};

export type getExperimentAssignmentsResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getExperimentAssignmentsResponseComposite =
	| getExperimentAssignmentsResponse200
	| getExperimentAssignmentsResponse422;

export type getExperimentAssignmentsResponse =
	getExperimentAssignmentsResponseComposite & {
		headers: Headers;
	};

export const getGetExperimentAssignmentsUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments`;
};

export const getExperimentAssignments = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<getExperimentAssignmentsResponse> => {
	return orvalFetch<getExperimentAssignmentsResponse>(
		getGetExperimentAssignmentsUrl(datasourceId, experimentId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetExperimentAssignmentsKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments`,
	] as const;

export type GetExperimentAssignmentsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getExperimentAssignments>>
>;
export type GetExperimentAssignmentsQueryError = HTTPValidationError;

/**
 * @summary Get Experiment Assignments
 */
export const useGetExperimentAssignments = <TError = HTTPValidationError>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getExperimentAssignments>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && experimentId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getGetExperimentAssignmentsKey(datasourceId, experimentId)
				: null);
	const swrFn = () =>
		getExperimentAssignments(datasourceId, experimentId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Power Check
 */
export type powerCheckResponse200 = {
	data: PowerResponseOutput;
	status: 200;
};

export type powerCheckResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type powerCheckResponseComposite =
	| powerCheckResponse200
	| powerCheckResponse422;

export type powerCheckResponse = powerCheckResponseComposite & {
	headers: Headers;
};

export const getPowerCheckUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/balance`;
};

export const powerCheck = async (
	datasourceId: string,
	powerRequest: PowerRequest,
	options?: RequestInit,
): Promise<powerCheckResponse> => {
	return orvalFetch<powerCheckResponse>(getPowerCheckUrl(datasourceId), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(powerRequest),
	});
};

export const getPowerCheckMutationFetcher = (
	datasourceId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: PowerRequest },
	): Promise<powerCheckResponse> => {
		return powerCheck(datasourceId, arg, options);
	};
};
export const getPowerCheckMutationKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/balance`] as const;

export type PowerCheckMutationResult = NonNullable<
	Awaited<ReturnType<typeof powerCheck>>
>;
export type PowerCheckMutationError = HTTPValidationError;

/**
 * @summary Power Check
 */
export const usePowerCheck = <TError = HTTPValidationError>(
	datasourceId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof powerCheck>>,
			TError,
			Key,
			PowerRequest,
			Awaited<ReturnType<typeof powerCheck>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getPowerCheckMutationKey(datasourceId);
	const swrFn = getPowerCheckMutationFetcher(datasourceId, requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
