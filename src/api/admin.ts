/**
 * Generated by orval v7.6.0 üç∫
 * Do not edit manually.
 * xngin: Experiments API
 * OpenAPI spec version: 0.9.0
 */
import useSwr from "swr";
import type { Arguments, Key, SWRConfiguration } from "swr";

import useSWRMutation from "swr/mutation";
import type { SWRMutationConfiguration } from "swr/mutation";

import type {
	AddMemberToOrganizationRequest,
	CreateApiKeyRequest,
	CreateApiKeyResponse,
	CreateDatasourceRequest,
	CreateDatasourceResponse,
	CreateExperimentRequest,
	CreateExperimentWithAssignmentParams,
	CreateExperimentWithAssignmentResponse,
	CreateOrganizationRequest,
	CreateOrganizationResponse,
	CreateParticipantsTypeRequest,
	CreateParticipantsTypeResponse,
	ExperimentAnalysis,
	ExperimentConfig,
	GetDatasourceResponse,
	GetExperimentAssigmentsResponse,
	GetOrganizationResponse,
	HTTPValidationError,
	InspectDatasourceParams,
	InspectDatasourceResponse,
	InspectDatasourceTableResponse,
	InspectParticipantTypesParams,
	InspectParticipantTypesResponse,
	InspectTableInDatasourceParams,
	ListApiKeysResponse,
	ListDatasourcesResponse,
	ListExperimentsResponse,
	ListOrganizationsResponse,
	ListParticipantsTypeResponse,
	ParticipantsConfig,
	PowerRequest,
	PowerResponseOutput,
	TokenInfo,
	UpdateDatasourceRequest,
	UpdateOrganizationRequest,
	UpdateParticipantsTypeRequest,
	UpdateParticipantsTypeResponse,
} from "./methods.schemas";

import { orvalFetch } from "../services/orval-fetch";
import type { ErrorType } from "../services/orval-fetch";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Returns basic metadata about the authenticated caller of this method.
 * @summary Caller Identity
 */
export const getCallerIdentityUrl = () => {
	return `/v1/m/caller-identity`;
};

export const callerIdentity = async (
	options?: RequestInit,
): Promise<TokenInfo> => {
	return orvalFetch<TokenInfo>(getCallerIdentityUrl(), {
		...options,
		method: "GET",
	});
};

export const getCallerIdentityKey = () => [`/v1/m/caller-identity`] as const;

export type CallerIdentityQueryResult = NonNullable<
	Awaited<ReturnType<typeof callerIdentity>>
>;
export type CallerIdentityQueryError = ErrorType<unknown>;

/**
 * @summary Caller Identity
 */
export const useCallerIdentity = <TError = ErrorType<unknown>>(options?: {
	swr?: SWRConfiguration<Awaited<ReturnType<typeof callerIdentity>>, TError> & {
		swrKey?: Key;
		enabled?: boolean;
	};
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ?? (() => (isEnabled ? getCallerIdentityKey() : null));
	const swrFn = () => callerIdentity(requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns a list of organizations that the authenticated user is a member of.
 * @summary List Organizations
 */
export const getListOrganizationsUrl = () => {
	return `/v1/m/organizations`;
};

export const listOrganizations = async (
	options?: RequestInit,
): Promise<ListOrganizationsResponse> => {
	return orvalFetch<ListOrganizationsResponse>(getListOrganizationsUrl(), {
		...options,
		method: "GET",
	});
};

export const getListOrganizationsKey = () => [`/v1/m/organizations`] as const;

export type ListOrganizationsQueryResult = NonNullable<
	Awaited<ReturnType<typeof listOrganizations>>
>;
export type ListOrganizationsQueryError = ErrorType<unknown>;

/**
 * @summary List Organizations
 */
export const useListOrganizations = <TError = ErrorType<unknown>>(options?: {
	swr?: SWRConfiguration<
		Awaited<ReturnType<typeof listOrganizations>>,
		TError
	> & { swrKey?: Key; enabled?: boolean };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListOrganizationsKey() : null));
	const swrFn = () => listOrganizations(requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Creates a new organization.

Only users with an @agency.fund email address can create organizations.
 * @summary Create Organizations
 */
export const getCreateOrganizationsUrl = () => {
	return `/v1/m/organizations`;
};

export const createOrganizations = async (
	createOrganizationRequest: CreateOrganizationRequest,
	options?: RequestInit,
): Promise<CreateOrganizationResponse> => {
	return orvalFetch<CreateOrganizationResponse>(getCreateOrganizationsUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createOrganizationRequest),
	});
};

export const getCreateOrganizationsMutationFetcher = (
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: CreateOrganizationRequest },
	): Promise<CreateOrganizationResponse> => {
		return createOrganizations(arg, options);
	};
};
export const getCreateOrganizationsMutationKey = () =>
	[`/v1/m/organizations`] as const;

export type CreateOrganizationsMutationResult = NonNullable<
	Awaited<ReturnType<typeof createOrganizations>>
>;
export type CreateOrganizationsMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Create Organizations
 */
export const useCreateOrganizations = <
	TError = ErrorType<HTTPValidationError>,
>(options?: {
	swr?: SWRMutationConfiguration<
		Awaited<ReturnType<typeof createOrganizations>>,
		TError,
		Key,
		CreateOrganizationRequest,
		Awaited<ReturnType<typeof createOrganizations>>
	> & { swrKey?: string };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getCreateOrganizationsMutationKey();
	const swrFn = getCreateOrganizationsMutationFetcher(requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Adds a new member to an organization.

The authenticated user must be part of the organization to add members.
 * @summary Add Member To Organization
 */
export const getAddMemberToOrganizationUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}/members`;
};

export const addMemberToOrganization = async (
	organizationId: string,
	addMemberToOrganizationRequest: AddMemberToOrganizationRequest,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(getAddMemberToOrganizationUrl(organizationId), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(addMemberToOrganizationRequest),
	});
};

export const getAddMemberToOrganizationMutationFetcher = (
	organizationId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: AddMemberToOrganizationRequest },
	): Promise<void> => {
		return addMemberToOrganization(organizationId, arg, options);
	};
};
export const getAddMemberToOrganizationMutationKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}/members`] as const;

export type AddMemberToOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof addMemberToOrganization>>
>;
export type AddMemberToOrganizationMutationError =
	ErrorType<HTTPValidationError>;

/**
 * @summary Add Member To Organization
 */
export const useAddMemberToOrganization = <
	TError = ErrorType<HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof addMemberToOrganization>>,
			TError,
			Key,
			AddMemberToOrganizationRequest,
			Awaited<ReturnType<typeof addMemberToOrganization>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getAddMemberToOrganizationMutationKey(organizationId);
	const swrFn = getAddMemberToOrganizationMutationFetcher(
		organizationId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Removes a member from an organization.

The authenticated user must be part of the organization to remove members.
 * @summary Remove Member From Organization
 */
export const getRemoveMemberFromOrganizationUrl = (
	organizationId: string,
	userId: string,
) => {
	return `/v1/m/organizations/${organizationId}/members/${userId}`;
};

export const removeMemberFromOrganization = async (
	organizationId: string,
	userId: string,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(
		getRemoveMemberFromOrganizationUrl(organizationId, userId),
		{
			...options,
			method: "DELETE",
		},
	);
};

export const getRemoveMemberFromOrganizationMutationFetcher = (
	organizationId: string,
	userId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }): Promise<void> => {
		return removeMemberFromOrganization(organizationId, userId, options);
	};
};
export const getRemoveMemberFromOrganizationMutationKey = (
	organizationId: string,
	userId: string,
) => [`/v1/m/organizations/${organizationId}/members/${userId}`] as const;

export type RemoveMemberFromOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof removeMemberFromOrganization>>
>;
export type RemoveMemberFromOrganizationMutationError =
	ErrorType<HTTPValidationError>;

/**
 * @summary Remove Member From Organization
 */
export const useRemoveMemberFromOrganization = <
	TError = ErrorType<HTTPValidationError>,
>(
	organizationId: string,
	userId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof removeMemberFromOrganization>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof removeMemberFromOrganization>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getRemoveMemberFromOrganizationMutationKey(organizationId, userId);
	const swrFn = getRemoveMemberFromOrganizationMutationFetcher(
		organizationId,
		userId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Updates an organization's properties.

The authenticated user must be a member of the organization.
Currently only supports updating the organization name.
 * @summary Update Organization
 */
export const getUpdateOrganizationUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}`;
};

export const updateOrganization = async (
	organizationId: string,
	updateOrganizationRequest: UpdateOrganizationRequest,
	options?: RequestInit,
): Promise<unknown> => {
	return orvalFetch<unknown>(getUpdateOrganizationUrl(organizationId), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(updateOrganizationRequest),
	});
};

export const getUpdateOrganizationMutationFetcher = (
	organizationId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: UpdateOrganizationRequest },
	): Promise<unknown> => {
		return updateOrganization(organizationId, arg, options);
	};
};
export const getUpdateOrganizationMutationKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}`] as const;

export type UpdateOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateOrganization>>
>;
export type UpdateOrganizationMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Update Organization
 */
export const useUpdateOrganization = <TError = ErrorType<HTTPValidationError>>(
	organizationId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof updateOrganization>>,
			TError,
			Key,
			UpdateOrganizationRequest,
			Awaited<ReturnType<typeof updateOrganization>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getUpdateOrganizationMutationKey(organizationId);
	const swrFn = getUpdateOrganizationMutationFetcher(
		organizationId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns detailed information about a specific organization.

The authenticated user must be a member of the organization.
 * @summary Get Organization
 */
export const getGetOrganizationUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}`;
};

export const getOrganization = async (
	organizationId: string,
	options?: RequestInit,
): Promise<GetOrganizationResponse> => {
	return orvalFetch<GetOrganizationResponse>(
		getGetOrganizationUrl(organizationId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetOrganizationKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}`] as const;

export type GetOrganizationQueryResult = NonNullable<
	Awaited<ReturnType<typeof getOrganization>>
>;
export type GetOrganizationQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary Get Organization
 */
export const useGetOrganization = <TError = ErrorType<HTTPValidationError>>(
	organizationId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getOrganization>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!organizationId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getGetOrganizationKey(organizationId) : null));
	const swrFn = () => getOrganization(organizationId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns a list of datasources accessible to the authenticated user for an org.
 * @summary List Organization Datasources
 */
export const getListOrganizationDatasourcesUrl = (organizationId: string) => {
	return `/v1/m/organizations/${organizationId}/datasources`;
};

export const listOrganizationDatasources = async (
	organizationId: string,
	options?: RequestInit,
): Promise<ListDatasourcesResponse> => {
	return orvalFetch<ListDatasourcesResponse>(
		getListOrganizationDatasourcesUrl(organizationId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getListOrganizationDatasourcesKey = (organizationId: string) =>
	[`/v1/m/organizations/${organizationId}/datasources`] as const;

export type ListOrganizationDatasourcesQueryResult = NonNullable<
	Awaited<ReturnType<typeof listOrganizationDatasources>>
>;
export type ListOrganizationDatasourcesQueryError =
	ErrorType<HTTPValidationError>;

/**
 * @summary List Organization Datasources
 */
export const useListOrganizationDatasources = <
	TError = ErrorType<HTTPValidationError>,
>(
	organizationId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof listOrganizationDatasources>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!organizationId;
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled ? getListOrganizationDatasourcesKey(organizationId) : null);
	const swrFn = () =>
		listOrganizationDatasources(organizationId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns a list of datasources accessible to the authenticated user.
 * @summary List Datasources
 */
export const getListDatasourcesUrl = () => {
	return `/v1/m/datasources`;
};

export const listDatasources = async (
	options?: RequestInit,
): Promise<ListDatasourcesResponse> => {
	return orvalFetch<ListDatasourcesResponse>(getListDatasourcesUrl(), {
		...options,
		method: "GET",
	});
};

export const getListDatasourcesKey = () => [`/v1/m/datasources`] as const;

export type ListDatasourcesQueryResult = NonNullable<
	Awaited<ReturnType<typeof listDatasources>>
>;
export type ListDatasourcesQueryError = ErrorType<unknown>;

/**
 * @summary List Datasources
 */
export const useListDatasources = <TError = ErrorType<unknown>>(options?: {
	swr?: SWRConfiguration<
		Awaited<ReturnType<typeof listDatasources>>,
		TError
	> & { swrKey?: Key; enabled?: boolean };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ?? (() => (isEnabled ? getListDatasourcesKey() : null));
	const swrFn = () => listDatasources(requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Creates a new datasource for the specified organization.
 * @summary Create Datasource
 */
export const getCreateDatasourceUrl = () => {
	return `/v1/m/datasources`;
};

export const createDatasource = async (
	createDatasourceRequest: CreateDatasourceRequest,
	options?: RequestInit,
): Promise<CreateDatasourceResponse> => {
	return orvalFetch<CreateDatasourceResponse>(getCreateDatasourceUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createDatasourceRequest),
	});
};

export const getCreateDatasourceMutationFetcher = (
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: CreateDatasourceRequest },
	): Promise<CreateDatasourceResponse> => {
		return createDatasource(arg, options);
	};
};
export const getCreateDatasourceMutationKey = () =>
	[`/v1/m/datasources`] as const;

export type CreateDatasourceMutationResult = NonNullable<
	Awaited<ReturnType<typeof createDatasource>>
>;
export type CreateDatasourceMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Create Datasource
 */
export const useCreateDatasource = <
	TError = ErrorType<HTTPValidationError>,
>(options?: {
	swr?: SWRMutationConfiguration<
		Awaited<ReturnType<typeof createDatasource>>,
		TError,
		Key,
		CreateDatasourceRequest,
		Awaited<ReturnType<typeof createDatasource>>
	> & { swrKey?: string };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getCreateDatasourceMutationKey();
	const swrFn = getCreateDatasourceMutationFetcher(requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Update Datasource
 */
export const getUpdateDatasourceUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}`;
};

export const updateDatasource = async (
	datasourceId: string,
	updateDatasourceRequest: UpdateDatasourceRequest,
	options?: RequestInit,
): Promise<unknown> => {
	return orvalFetch<unknown>(getUpdateDatasourceUrl(datasourceId), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(updateDatasourceRequest),
	});
};

export const getUpdateDatasourceMutationFetcher = (
	datasourceId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: UpdateDatasourceRequest },
	): Promise<unknown> => {
		return updateDatasource(datasourceId, arg, options);
	};
};
export const getUpdateDatasourceMutationKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}`] as const;

export type UpdateDatasourceMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateDatasource>>
>;
export type UpdateDatasourceMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Update Datasource
 */
export const useUpdateDatasource = <TError = ErrorType<HTTPValidationError>>(
	datasourceId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof updateDatasource>>,
			TError,
			Key,
			UpdateDatasourceRequest,
			Awaited<ReturnType<typeof updateDatasource>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getUpdateDatasourceMutationKey(datasourceId);
	const swrFn = getUpdateDatasourceMutationFetcher(
		datasourceId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns detailed information about a specific datasource.
 * @summary Get Datasource
 */
export const getGetDatasourceUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}`;
};

export const getDatasource = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<GetDatasourceResponse> => {
	return orvalFetch<GetDatasourceResponse>(getGetDatasourceUrl(datasourceId), {
		...options,
		method: "GET",
	});
};

export const getGetDatasourceKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}`] as const;

export type GetDatasourceQueryResult = NonNullable<
	Awaited<ReturnType<typeof getDatasource>>
>;
export type GetDatasourceQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary Get Datasource
 */
export const useGetDatasource = <TError = ErrorType<HTTPValidationError>>(
	datasourceId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getDatasource>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!datasourceId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getGetDatasourceKey(datasourceId) : null));
	const swrFn = () => getDatasource(datasourceId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Deletes a datasource.

The user must be a member of the organization that owns the datasource.
 * @summary Delete Datasource
 */
export const getDeleteDatasourceUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}`;
};

export const deleteDatasource = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(getDeleteDatasourceUrl(datasourceId), {
		...options,
		method: "DELETE",
	});
};

export const getDeleteDatasourceMutationFetcher = (
	datasourceId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }): Promise<void> => {
		return deleteDatasource(datasourceId, options);
	};
};
export const getDeleteDatasourceMutationKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}`] as const;

export type DeleteDatasourceMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteDatasource>>
>;
export type DeleteDatasourceMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Delete Datasource
 */
export const useDeleteDatasource = <TError = ErrorType<HTTPValidationError>>(
	datasourceId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteDatasource>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteDatasource>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getDeleteDatasourceMutationKey(datasourceId);
	const swrFn = getDeleteDatasourceMutationFetcher(
		datasourceId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Verifies connectivity to a datasource and returns a list of readable tables.
 * @summary Inspect Datasource
 */
export const getInspectDatasourceUrl = (
	datasourceId: string,
	params?: InspectDatasourceParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/inspect?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/inspect`;
};

export const inspectDatasource = async (
	datasourceId: string,
	params?: InspectDatasourceParams,
	options?: RequestInit,
): Promise<InspectDatasourceResponse> => {
	return orvalFetch<InspectDatasourceResponse>(
		getInspectDatasourceUrl(datasourceId, params),
		{
			...options,
			method: "GET",
		},
	);
};

export const getInspectDatasourceKey = (
	datasourceId: string,
	params?: InspectDatasourceParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/inspect`,
		...(params ? [params] : []),
	] as const;

export type InspectDatasourceQueryResult = NonNullable<
	Awaited<ReturnType<typeof inspectDatasource>>
>;
export type InspectDatasourceQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary Inspect Datasource
 */
export const useInspectDatasource = <TError = ErrorType<HTTPValidationError>>(
	datasourceId: string,
	params?: InspectDatasourceParams,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof inspectDatasource>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!datasourceId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getInspectDatasourceKey(datasourceId, params) : null));
	const swrFn = () => inspectDatasource(datasourceId, params, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Inspects a single table in a datasource and returns a summary of its fields.
 * @summary Inspect Table In Datasource
 */
export const getInspectTableInDatasourceUrl = (
	datasourceId: string,
	tableName: string,
	params?: InspectTableInDatasourceParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/inspect/${tableName}?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/inspect/${tableName}`;
};

export const inspectTableInDatasource = async (
	datasourceId: string,
	tableName: string,
	params?: InspectTableInDatasourceParams,
	options?: RequestInit,
): Promise<InspectDatasourceTableResponse> => {
	return orvalFetch<InspectDatasourceTableResponse>(
		getInspectTableInDatasourceUrl(datasourceId, tableName, params),
		{
			...options,
			method: "GET",
		},
	);
};

export const getInspectTableInDatasourceKey = (
	datasourceId: string,
	tableName: string,
	params?: InspectTableInDatasourceParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/inspect/${tableName}`,
		...(params ? [params] : []),
	] as const;

export type InspectTableInDatasourceQueryResult = NonNullable<
	Awaited<ReturnType<typeof inspectTableInDatasource>>
>;
export type InspectTableInDatasourceQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary Inspect Table In Datasource
 */
export const useInspectTableInDatasource = <
	TError = ErrorType<HTTPValidationError>,
>(
	datasourceId: string,
	tableName: string,
	params?: InspectTableInDatasourceParams,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof inspectTableInDatasource>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && tableName);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getInspectTableInDatasourceKey(datasourceId, tableName, params)
				: null);
	const swrFn = () =>
		inspectTableInDatasource(datasourceId, tableName, params, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary List Participant Types
 */
export const getListParticipantTypesUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/participants`;
};

export const listParticipantTypes = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<ListParticipantsTypeResponse> => {
	return orvalFetch<ListParticipantsTypeResponse>(
		getListParticipantTypesUrl(datasourceId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getListParticipantTypesKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/participants`] as const;

export type ListParticipantTypesQueryResult = NonNullable<
	Awaited<ReturnType<typeof listParticipantTypes>>
>;
export type ListParticipantTypesQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary List Participant Types
 */
export const useListParticipantTypes = <
	TError = ErrorType<HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof listParticipantTypes>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!datasourceId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListParticipantTypesKey(datasourceId) : null));
	const swrFn = () => listParticipantTypes(datasourceId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Create Participant Type
 */
export const getCreateParticipantTypeUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/participants`;
};

export const createParticipantType = async (
	datasourceId: string,
	createParticipantsTypeRequest: CreateParticipantsTypeRequest,
	options?: RequestInit,
): Promise<CreateParticipantsTypeResponse> => {
	return orvalFetch<CreateParticipantsTypeResponse>(
		getCreateParticipantTypeUrl(datasourceId),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(createParticipantsTypeRequest),
		},
	);
};

export const getCreateParticipantTypeMutationFetcher = (
	datasourceId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: CreateParticipantsTypeRequest },
	): Promise<CreateParticipantsTypeResponse> => {
		return createParticipantType(datasourceId, arg, options);
	};
};
export const getCreateParticipantTypeMutationKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/participants`] as const;

export type CreateParticipantTypeMutationResult = NonNullable<
	Awaited<ReturnType<typeof createParticipantType>>
>;
export type CreateParticipantTypeMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Create Participant Type
 */
export const useCreateParticipantType = <
	TError = ErrorType<HTTPValidationError>,
>(
	datasourceId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof createParticipantType>>,
			TError,
			Key,
			CreateParticipantsTypeRequest,
			Awaited<ReturnType<typeof createParticipantType>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getCreateParticipantTypeMutationKey(datasourceId);
	const swrFn = getCreateParticipantTypeMutationFetcher(
		datasourceId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns filter, strata, and metric field metadata for a participant type, including exemplars for filter fields.
 * @summary Inspect Participant Types
 */
export const getInspectParticipantTypesUrl = (
	datasourceId: string,
	participantId: string,
	params?: InspectParticipantTypesParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/datasources/${datasourceId}/participants/${participantId}/inspect?${stringifiedParams}`
		: `/v1/m/datasources/${datasourceId}/participants/${participantId}/inspect`;
};

export const inspectParticipantTypes = async (
	datasourceId: string,
	participantId: string,
	params?: InspectParticipantTypesParams,
	options?: RequestInit,
): Promise<InspectParticipantTypesResponse> => {
	return orvalFetch<InspectParticipantTypesResponse>(
		getInspectParticipantTypesUrl(datasourceId, participantId, params),
		{
			...options,
			method: "GET",
		},
	);
};

export const getInspectParticipantTypesKey = (
	datasourceId: string,
	participantId: string,
	params?: InspectParticipantTypesParams,
) =>
	[
		`/v1/m/datasources/${datasourceId}/participants/${participantId}/inspect`,
		...(params ? [params] : []),
	] as const;

export type InspectParticipantTypesQueryResult = NonNullable<
	Awaited<ReturnType<typeof inspectParticipantTypes>>
>;
export type InspectParticipantTypesQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary Inspect Participant Types
 */
export const useInspectParticipantTypes = <
	TError = ErrorType<HTTPValidationError>,
>(
	datasourceId: string,
	participantId: string,
	params?: InspectParticipantTypesParams,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof inspectParticipantTypes>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && participantId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getInspectParticipantTypesKey(datasourceId, participantId, params)
				: null);
	const swrFn = () =>
		inspectParticipantTypes(
			datasourceId,
			participantId,
			params,
			requestOptions,
		);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Get Participant Types
 */
export const getGetParticipantTypesUrl = (
	datasourceId: string,
	participantId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/participants/${participantId}`;
};

export const getParticipantTypes = async (
	datasourceId: string,
	participantId: string,
	options?: RequestInit,
): Promise<ParticipantsConfig> => {
	return orvalFetch<ParticipantsConfig>(
		getGetParticipantTypesUrl(datasourceId, participantId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetParticipantTypesKey = (
	datasourceId: string,
	participantId: string,
) =>
	[`/v1/m/datasources/${datasourceId}/participants/${participantId}`] as const;

export type GetParticipantTypesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getParticipantTypes>>
>;
export type GetParticipantTypesQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary Get Participant Types
 */
export const useGetParticipantTypes = <TError = ErrorType<HTTPValidationError>>(
	datasourceId: string,
	participantId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getParticipantTypes>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && participantId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getGetParticipantTypesKey(datasourceId, participantId)
				: null);
	const swrFn = () =>
		getParticipantTypes(datasourceId, participantId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Update Participant Type
 */
export const getUpdateParticipantTypeUrl = (
	datasourceId: string,
	participantId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/participants/${participantId}`;
};

export const updateParticipantType = async (
	datasourceId: string,
	participantId: string,
	updateParticipantsTypeRequest: UpdateParticipantsTypeRequest,
	options?: RequestInit,
): Promise<UpdateParticipantsTypeResponse> => {
	return orvalFetch<UpdateParticipantsTypeResponse>(
		getUpdateParticipantTypeUrl(datasourceId, participantId),
		{
			...options,
			method: "PATCH",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(updateParticipantsTypeRequest),
		},
	);
};

export const getUpdateParticipantTypeMutationFetcher = (
	datasourceId: string,
	participantId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: UpdateParticipantsTypeRequest },
	): Promise<UpdateParticipantsTypeResponse> => {
		return updateParticipantType(datasourceId, participantId, arg, options);
	};
};
export const getUpdateParticipantTypeMutationKey = (
	datasourceId: string,
	participantId: string,
) =>
	[`/v1/m/datasources/${datasourceId}/participants/${participantId}`] as const;

export type UpdateParticipantTypeMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateParticipantType>>
>;
export type UpdateParticipantTypeMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Update Participant Type
 */
export const useUpdateParticipantType = <
	TError = ErrorType<HTTPValidationError>,
>(
	datasourceId: string,
	participantId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof updateParticipantType>>,
			TError,
			Key,
			UpdateParticipantsTypeRequest,
			Awaited<ReturnType<typeof updateParticipantType>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getUpdateParticipantTypeMutationKey(datasourceId, participantId);
	const swrFn = getUpdateParticipantTypeMutationFetcher(
		datasourceId,
		participantId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Delete Participant
 */
export const getDeleteParticipantUrl = (
	datasourceId: string,
	participantId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/participants/${participantId}`;
};

export const deleteParticipant = async (
	datasourceId: string,
	participantId: string,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(
		getDeleteParticipantUrl(datasourceId, participantId),
		{
			...options,
			method: "DELETE",
		},
	);
};

export const getDeleteParticipantMutationFetcher = (
	datasourceId: string,
	participantId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }): Promise<void> => {
		return deleteParticipant(datasourceId, participantId, options);
	};
};
export const getDeleteParticipantMutationKey = (
	datasourceId: string,
	participantId: string,
) =>
	[`/v1/m/datasources/${datasourceId}/participants/${participantId}`] as const;

export type DeleteParticipantMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteParticipant>>
>;
export type DeleteParticipantMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Delete Participant
 */
export const useDeleteParticipant = <TError = ErrorType<HTTPValidationError>>(
	datasourceId: string,
	participantId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteParticipant>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteParticipant>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getDeleteParticipantMutationKey(datasourceId, participantId);
	const swrFn = getDeleteParticipantMutationFetcher(
		datasourceId,
		participantId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns API keys that the caller has access to via their organization memberships.

An API key is visible if the user belongs to the organization that owns any of the
datasources that the API key can access.
 * @summary List Api Keys
 */
export const getListApiKeysUrl = () => {
	return `/v1/m/apikeys`;
};

export const listApiKeys = async (
	options?: RequestInit,
): Promise<ListApiKeysResponse> => {
	return orvalFetch<ListApiKeysResponse>(getListApiKeysUrl(), {
		...options,
		method: "GET",
	});
};

export const getListApiKeysKey = () => [`/v1/m/apikeys`] as const;

export type ListApiKeysQueryResult = NonNullable<
	Awaited<ReturnType<typeof listApiKeys>>
>;
export type ListApiKeysQueryError = ErrorType<unknown>;

/**
 * @summary List Api Keys
 */
export const useListApiKeys = <TError = ErrorType<unknown>>(options?: {
	swr?: SWRConfiguration<Awaited<ReturnType<typeof listApiKeys>>, TError> & {
		swrKey?: Key;
		enabled?: boolean;
	};
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ?? (() => (isEnabled ? getListApiKeysKey() : null));
	const swrFn = () => listApiKeys(requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Creates an API key for the specified datasource.

The user must belong to the organization that owns the requested datasource.
 * @summary Create Api Key
 */
export const getCreateApiKeyUrl = () => {
	return `/v1/m/apikeys`;
};

export const createApiKey = async (
	createApiKeyRequest: CreateApiKeyRequest,
	options?: RequestInit,
): Promise<CreateApiKeyResponse> => {
	return orvalFetch<CreateApiKeyResponse>(getCreateApiKeyUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createApiKeyRequest),
	});
};

export const getCreateApiKeyMutationFetcher = (
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: CreateApiKeyRequest },
	): Promise<CreateApiKeyResponse> => {
		return createApiKey(arg, options);
	};
};
export const getCreateApiKeyMutationKey = () => [`/v1/m/apikeys`] as const;

export type CreateApiKeyMutationResult = NonNullable<
	Awaited<ReturnType<typeof createApiKey>>
>;
export type CreateApiKeyMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Create Api Key
 */
export const useCreateApiKey = <
	TError = ErrorType<HTTPValidationError>,
>(options?: {
	swr?: SWRMutationConfiguration<
		Awaited<ReturnType<typeof createApiKey>>,
		TError,
		Key,
		CreateApiKeyRequest,
		Awaited<ReturnType<typeof createApiKey>>
	> & { swrKey?: string };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getCreateApiKeyMutationKey();
	const swrFn = getCreateApiKeyMutationFetcher(requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Deletes the specified API key.
 * @summary Delete Api Key
 */
export const getDeleteApiKeyUrl = (apiKeyId: string) => {
	return `/v1/m/apikeys/${apiKeyId}`;
};

export const deleteApiKey = async (
	apiKeyId: string,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(getDeleteApiKeyUrl(apiKeyId), {
		...options,
		method: "DELETE",
	});
};

export const getDeleteApiKeyMutationFetcher = (
	apiKeyId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }): Promise<void> => {
		return deleteApiKey(apiKeyId, options);
	};
};
export const getDeleteApiKeyMutationKey = (apiKeyId: string) =>
	[`/v1/m/apikeys/${apiKeyId}`] as const;

export type DeleteApiKeyMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteApiKey>>
>;
export type DeleteApiKeyMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Delete Api Key
 */
export const useDeleteApiKey = <TError = ErrorType<HTTPValidationError>>(
	apiKeyId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteApiKey>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteApiKey>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getDeleteApiKeyMutationKey(apiKeyId);
	const swrFn = getDeleteApiKeyMutationFetcher(apiKeyId, requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Create Experiment With Assignment
 */
export const getCreateExperimentWithAssignmentUrl = (
	datasourceId: string,
	params: CreateExperimentWithAssignmentParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/m/experiments/${datasourceId}/with-assignment?${stringifiedParams}`
		: `/v1/m/experiments/${datasourceId}/with-assignment`;
};

export const createExperimentWithAssignment = async (
	datasourceId: string,
	createExperimentRequest: CreateExperimentRequest,
	params: CreateExperimentWithAssignmentParams,
	options?: RequestInit,
): Promise<CreateExperimentWithAssignmentResponse> => {
	return orvalFetch<CreateExperimentWithAssignmentResponse>(
		getCreateExperimentWithAssignmentUrl(datasourceId, params),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(createExperimentRequest),
		},
	);
};

export const getCreateExperimentWithAssignmentMutationFetcher = (
	datasourceId: string,
	params: CreateExperimentWithAssignmentParams,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: CreateExperimentRequest },
	): Promise<CreateExperimentWithAssignmentResponse> => {
		return createExperimentWithAssignment(datasourceId, arg, params, options);
	};
};
export const getCreateExperimentWithAssignmentMutationKey = (
	datasourceId: string,
	params: CreateExperimentWithAssignmentParams,
) =>
	[
		`/v1/m/experiments/${datasourceId}/with-assignment`,
		...(params ? [params] : []),
	] as const;

export type CreateExperimentWithAssignmentMutationResult = NonNullable<
	Awaited<ReturnType<typeof createExperimentWithAssignment>>
>;
export type CreateExperimentWithAssignmentMutationError =
	ErrorType<HTTPValidationError>;

/**
 * @summary Create Experiment With Assignment
 */
export const useCreateExperimentWithAssignment = <
	TError = ErrorType<HTTPValidationError>,
>(
	datasourceId: string,
	params: CreateExperimentWithAssignmentParams,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof createExperimentWithAssignment>>,
			TError,
			Key,
			CreateExperimentRequest,
			Awaited<ReturnType<typeof createExperimentWithAssignment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getCreateExperimentWithAssignmentMutationKey(datasourceId, params);
	const swrFn = getCreateExperimentWithAssignmentMutationFetcher(
		datasourceId,
		params,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Analyze Experiment
 */
export const getAnalyzeExperimentUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/analyze`;
};

export const analyzeExperiment = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<ExperimentAnalysis[]> => {
	return orvalFetch<ExperimentAnalysis[]>(
		getAnalyzeExperimentUrl(datasourceId, experimentId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getAnalyzeExperimentKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/analyze`,
	] as const;

export type AnalyzeExperimentQueryResult = NonNullable<
	Awaited<ReturnType<typeof analyzeExperiment>>
>;
export type AnalyzeExperimentQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary Analyze Experiment
 */
export const useAnalyzeExperiment = <TError = ErrorType<HTTPValidationError>>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof analyzeExperiment>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && experimentId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled ? getAnalyzeExperimentKey(datasourceId, experimentId) : null);
	const swrFn = () =>
		analyzeExperiment(datasourceId, experimentId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Commit Experiment
 */
export const getCommitExperimentUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/commit`;
};

export const commitExperiment = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(getCommitExperimentUrl(datasourceId, experimentId), {
		...options,
		method: "POST",
	});
};

export const getCommitExperimentMutationFetcher = (
	datasourceId: string,
	experimentId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }): Promise<void> => {
		return commitExperiment(datasourceId, experimentId, options);
	};
};
export const getCommitExperimentMutationKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/commit`,
	] as const;

export type CommitExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof commitExperiment>>
>;
export type CommitExperimentMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Commit Experiment
 */
export const useCommitExperiment = <TError = ErrorType<HTTPValidationError>>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof commitExperiment>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof commitExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getCommitExperimentMutationKey(datasourceId, experimentId);
	const swrFn = getCommitExperimentMutationFetcher(
		datasourceId,
		experimentId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Abandon Experiment
 */
export const getAbandonExperimentUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/abandon`;
};

export const abandonExperiment = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(getAbandonExperimentUrl(datasourceId, experimentId), {
		...options,
		method: "POST",
	});
};

export const getAbandonExperimentMutationFetcher = (
	datasourceId: string,
	experimentId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }): Promise<void> => {
		return abandonExperiment(datasourceId, experimentId, options);
	};
};
export const getAbandonExperimentMutationKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/abandon`,
	] as const;

export type AbandonExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof abandonExperiment>>
>;
export type AbandonExperimentMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Abandon Experiment
 */
export const useAbandonExperiment = <TError = ErrorType<HTTPValidationError>>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof abandonExperiment>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof abandonExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getAbandonExperimentMutationKey(datasourceId, experimentId);
	const swrFn = getAbandonExperimentMutationFetcher(
		datasourceId,
		experimentId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns the list of experiments in the datasource.
 * @summary List Experiments
 */
export const getListExperimentsUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/experiments`;
};

export const listExperiments = async (
	datasourceId: string,
	options?: RequestInit,
): Promise<ListExperimentsResponse> => {
	return orvalFetch<ListExperimentsResponse>(
		getListExperimentsUrl(datasourceId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getListExperimentsKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/experiments`] as const;

export type ListExperimentsQueryResult = NonNullable<
	Awaited<ReturnType<typeof listExperiments>>
>;
export type ListExperimentsQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary List Experiments
 */
export const useListExperiments = <TError = ErrorType<HTTPValidationError>>(
	datasourceId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof listExperiments>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!datasourceId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListExperimentsKey(datasourceId) : null));
	const swrFn = () => listExperiments(datasourceId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Returns the experiment with the specified ID.
 * @summary Get Experiment
 */
export const getGetExperimentUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}`;
};

export const getExperiment = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<ExperimentConfig> => {
	return orvalFetch<ExperimentConfig>(
		getGetExperimentUrl(datasourceId, experimentId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetExperimentKey = (
	datasourceId: string,
	experimentId: string,
) => [`/v1/m/datasources/${datasourceId}/experiments/${experimentId}`] as const;

export type GetExperimentQueryResult = NonNullable<
	Awaited<ReturnType<typeof getExperiment>>
>;
export type GetExperimentQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary Get Experiment
 */
export const useGetExperiment = <TError = ErrorType<HTTPValidationError>>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getExperiment>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && experimentId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled ? getGetExperimentKey(datasourceId, experimentId) : null);
	const swrFn = () => getExperiment(datasourceId, experimentId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Deletes the experiment with the specified ID.
 * @summary Delete Experiment
 */
export const getDeleteExperimentUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}`;
};

export const deleteExperiment = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<void> => {
	return orvalFetch<void>(getDeleteExperimentUrl(datasourceId, experimentId), {
		...options,
		method: "DELETE",
	});
};

export const getDeleteExperimentMutationFetcher = (
	datasourceId: string,
	experimentId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (_: Key, __: { arg: Arguments }): Promise<void> => {
		return deleteExperiment(datasourceId, experimentId, options);
	};
};
export const getDeleteExperimentMutationKey = (
	datasourceId: string,
	experimentId: string,
) => [`/v1/m/datasources/${datasourceId}/experiments/${experimentId}`] as const;

export type DeleteExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteExperiment>>
>;
export type DeleteExperimentMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Delete Experiment
 */
export const useDeleteExperiment = <TError = ErrorType<HTTPValidationError>>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof deleteExperiment>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof deleteExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getDeleteExperimentMutationKey(datasourceId, experimentId);
	const swrFn = getDeleteExperimentMutationFetcher(
		datasourceId,
		experimentId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Get Experiment Assignments
 */
export const getGetExperimentAssignmentsUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments`;
};

export const getExperimentAssignments = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<GetExperimentAssigmentsResponse> => {
	return orvalFetch<GetExperimentAssigmentsResponse>(
		getGetExperimentAssignmentsUrl(datasourceId, experimentId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetExperimentAssignmentsKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments`,
	] as const;

export type GetExperimentAssignmentsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getExperimentAssignments>>
>;
export type GetExperimentAssignmentsQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary Get Experiment Assignments
 */
export const useGetExperimentAssignments = <
	TError = ErrorType<HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getExperimentAssignments>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && experimentId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getGetExperimentAssignmentsKey(datasourceId, experimentId)
				: null);
	const swrFn = () =>
		getExperimentAssignments(datasourceId, experimentId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Export experiment assignments as CSV file; BalanceCheck not included. csv header form: participant_id,arm_id,arm_name,strata_name1,strata_name2,...
 */
export const getGetExperimentAssignmentsAsCsvUrl = (
	datasourceId: string,
	experimentId: string,
) => {
	return `/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments/csv`;
};

export const getExperimentAssignmentsAsCsv = async (
	datasourceId: string,
	experimentId: string,
	options?: RequestInit,
): Promise<unknown> => {
	return orvalFetch<unknown>(
		getGetExperimentAssignmentsAsCsvUrl(datasourceId, experimentId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetExperimentAssignmentsAsCsvKey = (
	datasourceId: string,
	experimentId: string,
) =>
	[
		`/v1/m/datasources/${datasourceId}/experiments/${experimentId}/assignments/csv`,
	] as const;

export type GetExperimentAssignmentsAsCsvQueryResult = NonNullable<
	Awaited<ReturnType<typeof getExperimentAssignmentsAsCsv>>
>;
export type GetExperimentAssignmentsAsCsvQueryError =
	ErrorType<HTTPValidationError>;

/**
 * @summary Export experiment assignments as CSV file; BalanceCheck not included. csv header form: participant_id,arm_id,arm_name,strata_name1,strata_name2,...
 */
export const useGetExperimentAssignmentsAsCsv = <
	TError = ErrorType<HTTPValidationError>,
>(
	datasourceId: string,
	experimentId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getExperimentAssignmentsAsCsv>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled =
		swrOptions?.enabled !== false && !!(datasourceId && experimentId);
	const swrKey =
		swrOptions?.swrKey ??
		(() =>
			isEnabled
				? getGetExperimentAssignmentsAsCsvKey(datasourceId, experimentId)
				: null);
	const swrFn = () =>
		getExperimentAssignmentsAsCsv(datasourceId, experimentId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Power Check
 */
export const getPowerCheckUrl = (datasourceId: string) => {
	return `/v1/m/datasources/${datasourceId}/power`;
};

export const powerCheck = async (
	datasourceId: string,
	powerRequest: PowerRequest,
	options?: RequestInit,
): Promise<PowerResponseOutput> => {
	return orvalFetch<PowerResponseOutput>(getPowerCheckUrl(datasourceId), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(powerRequest),
	});
};

export const getPowerCheckMutationFetcher = (
	datasourceId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: PowerRequest },
	): Promise<PowerResponseOutput> => {
		return powerCheck(datasourceId, arg, options);
	};
};
export const getPowerCheckMutationKey = (datasourceId: string) =>
	[`/v1/m/datasources/${datasourceId}/power`] as const;

export type PowerCheckMutationResult = NonNullable<
	Awaited<ReturnType<typeof powerCheck>>
>;
export type PowerCheckMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Power Check
 */
export const usePowerCheck = <TError = ErrorType<HTTPValidationError>>(
	datasourceId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof powerCheck>>,
			TError,
			Key,
			PowerRequest,
			Awaited<ReturnType<typeof powerCheck>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getPowerCheckMutationKey(datasourceId);
	const swrFn = getPowerCheckMutationFetcher(datasourceId, requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
