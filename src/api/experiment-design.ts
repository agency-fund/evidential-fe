/**
 * Generated by orval v7.5.0 üç∫
 * Do not edit manually.
 * xngin: Experiments API
 * OpenAPI spec version: 0.9.0
 */
import useSwr from "swr";
import type { Key, SWRConfiguration } from "swr";
import useSWRMutation from "swr/mutation";
import type { SWRMutationConfiguration } from "swr/mutation";
import { orvalFetch } from "../services/orval-fetch";
import type {
	AssignRequest,
	AssignResponseOutput,
	AssignTreatmentParams,
	GetFiltersParams,
	GetFiltersResponse,
	GetMetricsParams,
	GetMetricsResponse,
	GetStrataParams,
	GetStrataResponse,
	HTTPValidationError,
	PowerRequest,
	PowerResponseOutput,
	PowercheckParams,
} from "./methods.schemas";

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

/**
 * Get possible strata covariates for a given unit type.
 * @summary Get possible strata covariates.
 */
export type getStrataResponse = {
	data: GetStrataResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getGetStrataUrl = (params: GetStrataParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	return normalizedParams.size
		? `/v1/strata?${normalizedParams.toString()}`
		: `/v1/strata`;
};

export const getStrata = async (
	params: GetStrataParams,
	options?: RequestInit,
): Promise<getStrataResponse> => {
	return orvalFetch<getStrataResponse>(getGetStrataUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetStrataKey = (params: GetStrataParams) =>
	[`/v1/strata`, ...(params ? [params] : [])] as const;

export type GetStrataQueryResult = NonNullable<
	Awaited<ReturnType<typeof getStrata>>
>;
export type GetStrataQueryError = HTTPValidationError;

/**
 * @summary Get possible strata covariates.
 */
export const useGetStrata = <TError = HTTPValidationError>(
	params: GetStrataParams,
	options?: {
		swr?: SWRConfiguration<Awaited<ReturnType<typeof getStrata>>, TError> & {
			swrKey?: Key;
			enabled?: boolean;
		};
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ?? (() => (isEnabled ? getGetStrataKey(params) : null));
	const swrFn = () => getStrata(params, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Get possible filters covariates for a given unit type.
 */
export type getFiltersResponse = {
	data: GetFiltersResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getGetFiltersUrl = (params: GetFiltersParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	return normalizedParams.size
		? `/v1/filters?${normalizedParams.toString()}`
		: `/v1/filters`;
};

export const getFilters = async (
	params: GetFiltersParams,
	options?: RequestInit,
): Promise<getFiltersResponse> => {
	return orvalFetch<getFiltersResponse>(getGetFiltersUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetFiltersKey = (params: GetFiltersParams) =>
	[`/v1/filters`, ...(params ? [params] : [])] as const;

export type GetFiltersQueryResult = NonNullable<
	Awaited<ReturnType<typeof getFilters>>
>;
export type GetFiltersQueryError = HTTPValidationError;

/**
 * @summary Get possible filters covariates for a given unit type.
 */
export const useGetFilters = <TError = HTTPValidationError>(
	params: GetFiltersParams,
	options?: {
		swr?: SWRConfiguration<Awaited<ReturnType<typeof getFilters>>, TError> & {
			swrKey?: Key;
			enabled?: boolean;
		};
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ?? (() => (isEnabled ? getGetFiltersKey(params) : null));
	const swrFn = () => getFilters(params, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Get possible metrics for a given unit type.
 * @summary Get possible metric covariates for a given unit type.
 */
export type getMetricsResponse = {
	data: GetMetricsResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getGetMetricsUrl = (params: GetMetricsParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	return normalizedParams.size
		? `/v1/metrics?${normalizedParams.toString()}`
		: `/v1/metrics`;
};

export const getMetrics = async (
	params: GetMetricsParams,
	options?: RequestInit,
): Promise<getMetricsResponse> => {
	return orvalFetch<getMetricsResponse>(getGetMetricsUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetMetricsKey = (params: GetMetricsParams) =>
	[`/v1/metrics`, ...(params ? [params] : [])] as const;

export type GetMetricsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getMetrics>>
>;
export type GetMetricsQueryError = HTTPValidationError;

/**
 * @summary Get possible metric covariates for a given unit type.
 */
export const useGetMetrics = <TError = HTTPValidationError>(
	params: GetMetricsParams,
	options?: {
		swr?: SWRConfiguration<Awaited<ReturnType<typeof getMetrics>>, TError> & {
			swrKey?: Key;
			enabled?: boolean;
		};
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ?? (() => (isEnabled ? getGetMetricsKey(params) : null));
	const swrFn = () => getMetrics(params, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Calculates statistical power given the PowerRequest details.
 * @summary Check power given an experiment and audience specification.
 */
export type powercheckResponse = {
	data: PowerResponseOutput | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getPowercheckUrl = (params?: PowercheckParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	return normalizedParams.size
		? `/v1/power?${normalizedParams.toString()}`
		: `/v1/power`;
};

export const powercheck = async (
	powerRequest: PowerRequest,
	params?: PowercheckParams,
	options?: RequestInit,
): Promise<powercheckResponse> => {
	return orvalFetch<powercheckResponse>(getPowercheckUrl(params), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(powerRequest),
	});
};

export const getPowercheckMutationFetcher = (
	params?: PowercheckParams,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: PowerRequest },
	): Promise<powercheckResponse> => {
		return powercheck(arg, params, options);
	};
};
export const getPowercheckMutationKey = (params?: PowercheckParams) =>
	[`/v1/power`, ...(params ? [params] : [])] as const;

export type PowercheckMutationResult = NonNullable<
	Awaited<ReturnType<typeof powercheck>>
>;
export type PowercheckMutationError = HTTPValidationError;

/**
 * @summary Check power given an experiment and audience specification.
 */
export const usePowercheck = <TError = HTTPValidationError>(
	params?: PowercheckParams,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof powercheck>>,
			TError,
			Key,
			PowerRequest,
			Awaited<ReturnType<typeof powercheck>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getPowercheckMutationKey(params);
	const swrFn = getPowercheckMutationFetcher(params, requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Assign treatment given experiment and audience specification.
 */
export type assignTreatmentResponse = {
	data: AssignResponseOutput | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getAssignTreatmentUrl = (params: AssignTreatmentParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	return normalizedParams.size
		? `/v1/assign?${normalizedParams.toString()}`
		: `/v1/assign`;
};

export const assignTreatment = async (
	assignRequest: AssignRequest,
	params: AssignTreatmentParams,
	options?: RequestInit,
): Promise<assignTreatmentResponse> => {
	return orvalFetch<assignTreatmentResponse>(getAssignTreatmentUrl(params), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(assignRequest),
	});
};

export const getAssignTreatmentMutationFetcher = (
	params: AssignTreatmentParams,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: AssignRequest },
	): Promise<assignTreatmentResponse> => {
		return assignTreatment(arg, params, options);
	};
};
export const getAssignTreatmentMutationKey = (params: AssignTreatmentParams) =>
	[`/v1/assign`, ...(params ? [params] : [])] as const;

export type AssignTreatmentMutationResult = NonNullable<
	Awaited<ReturnType<typeof assignTreatment>>
>;
export type AssignTreatmentMutationError = HTTPValidationError;

/**
 * @summary Assign treatment given experiment and audience specification.
 */
export const useAssignTreatment = <TError = HTTPValidationError>(
	params: AssignTreatmentParams,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof assignTreatment>>,
			TError,
			Key,
			AssignRequest,
			Awaited<ReturnType<typeof assignTreatment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getAssignTreatmentMutationKey(params);
	const swrFn = getAssignTreatmentMutationFetcher(params, requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
