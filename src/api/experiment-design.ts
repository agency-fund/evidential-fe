/**
 * Generated by orval v7.5.0 üç∫
 * Do not edit manually.
 * xngin: Experiments API
 * OpenAPI spec version: 0.9.0
 */
import useSwr from "swr";
import type { Key, SWRConfiguration } from "swr";
import useSWRMutation from "swr/mutation";
import type { SWRMutationConfiguration } from "swr/mutation";
import { orvalFetch } from "../services/orval-fetch";
import type {
	AltUpdateExperimentBody,
	AssignRequest,
	AssignResponseOutput,
	AssignTreatmentParams,
	AssignmentFileParams,
	CommitExperimentParams,
	CommitRequest,
	GetFiltersParams,
	GetFiltersResponse,
	GetMetricsParams,
	GetMetricsResponse,
	GetStrataParams,
	GetStrataResponse,
	HTTPValidationError,
	PowerRequest,
	PowerResponseOutput,
	UpdateExperimentParams,
	WebhookResponse,
	WebhookUpdateCommitRequest,
} from "./methods.schemas";

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

/**
 * Get possible strata covariates for a given unit type.
 * @summary Get possible strata covariates.
 */
export type getStrataResponse = {
	data: GetStrataResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getGetStrataUrl = (params: GetStrataParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	return normalizedParams.size
		? `/v1/strata?${normalizedParams.toString()}`
		: `/v1/strata`;
};

export const getStrata = async (
	params: GetStrataParams,
	options?: RequestInit,
): Promise<getStrataResponse> => {
	return orvalFetch<getStrataResponse>(getGetStrataUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetStrataKey = (params: GetStrataParams) =>
	[`/v1/strata`, ...(params ? [params] : [])] as const;

export type GetStrataQueryResult = NonNullable<
	Awaited<ReturnType<typeof getStrata>>
>;
export type GetStrataQueryError = HTTPValidationError;

/**
 * @summary Get possible strata covariates.
 */
export const useGetStrata = <TError = HTTPValidationError>(
	params: GetStrataParams,
	options?: {
		swr?: SWRConfiguration<Awaited<ReturnType<typeof getStrata>>, TError> & {
			swrKey?: Key;
			enabled?: boolean;
		};
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ?? (() => (isEnabled ? getGetStrataKey(params) : null));
	const swrFn = () => getStrata(params, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Get possible filters covariates for a given unit type.
 */
export type getFiltersResponse = {
	data: GetFiltersResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getGetFiltersUrl = (params: GetFiltersParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	return normalizedParams.size
		? `/v1/filters?${normalizedParams.toString()}`
		: `/v1/filters`;
};

export const getFilters = async (
	params: GetFiltersParams,
	options?: RequestInit,
): Promise<getFiltersResponse> => {
	return orvalFetch<getFiltersResponse>(getGetFiltersUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetFiltersKey = (params: GetFiltersParams) =>
	[`/v1/filters`, ...(params ? [params] : [])] as const;

export type GetFiltersQueryResult = NonNullable<
	Awaited<ReturnType<typeof getFilters>>
>;
export type GetFiltersQueryError = HTTPValidationError;

/**
 * @summary Get possible filters covariates for a given unit type.
 */
export const useGetFilters = <TError = HTTPValidationError>(
	params: GetFiltersParams,
	options?: {
		swr?: SWRConfiguration<Awaited<ReturnType<typeof getFilters>>, TError> & {
			swrKey?: Key;
			enabled?: boolean;
		};
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ?? (() => (isEnabled ? getGetFiltersKey(params) : null));
	const swrFn = () => getFilters(params, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Get possible metrics for a given unit type.
 * @summary Get possible metric covariates for a given unit type.
 */
export type getMetricsResponse = {
	data: GetMetricsResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getGetMetricsUrl = (params: GetMetricsParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	return normalizedParams.size
		? `/v1/metrics?${normalizedParams.toString()}`
		: `/v1/metrics`;
};

export const getMetrics = async (
	params: GetMetricsParams,
	options?: RequestInit,
): Promise<getMetricsResponse> => {
	return orvalFetch<getMetricsResponse>(getGetMetricsUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetMetricsKey = (params: GetMetricsParams) =>
	[`/v1/metrics`, ...(params ? [params] : [])] as const;

export type GetMetricsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getMetrics>>
>;
export type GetMetricsQueryError = HTTPValidationError;

/**
 * @summary Get possible metric covariates for a given unit type.
 */
export const useGetMetrics = <TError = HTTPValidationError>(
	params: GetMetricsParams,
	options?: {
		swr?: SWRConfiguration<Awaited<ReturnType<typeof getMetrics>>, TError> & {
			swrKey?: Key;
			enabled?: boolean;
		};
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ?? (() => (isEnabled ? getGetMetricsKey(params) : null));
	const swrFn = () => getMetrics(params, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * Calculates statistical power given the PowerRequest details.
 * @summary Check power given an experiment and audience specification.
 */
export type powercheckResponse = {
	data: PowerResponseOutput | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getPowercheckUrl = () => {
	return `/v1/power`;
};

export const powercheck = async (
	powerRequest: PowerRequest,
	options?: RequestInit,
): Promise<powercheckResponse> => {
	return orvalFetch<powercheckResponse>(getPowercheckUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(powerRequest),
	});
};

export const getPowercheckMutationFetcher = (
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: PowerRequest },
	): Promise<powercheckResponse> => {
		return powercheck(arg, options);
	};
};
export const getPowercheckMutationKey = () => [`/v1/power`] as const;

export type PowercheckMutationResult = NonNullable<
	Awaited<ReturnType<typeof powercheck>>
>;
export type PowercheckMutationError = HTTPValidationError;

/**
 * @summary Check power given an experiment and audience specification.
 */
export const usePowercheck = <TError = HTTPValidationError>(options?: {
	swr?: SWRMutationConfiguration<
		Awaited<ReturnType<typeof powercheck>>,
		TError,
		Key,
		PowerRequest,
		Awaited<ReturnType<typeof powercheck>>
	> & { swrKey?: string };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getPowercheckMutationKey();
	const swrFn = getPowercheckMutationFetcher(requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Assign treatment given experiment and audience specification.
 */
export type assignTreatmentResponse = {
	data: AssignResponseOutput | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getAssignTreatmentUrl = (params: AssignTreatmentParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	return normalizedParams.size
		? `/v1/assign?${normalizedParams.toString()}`
		: `/v1/assign`;
};

export const assignTreatment = async (
	assignRequest: AssignRequest,
	params: AssignTreatmentParams,
	options?: RequestInit,
): Promise<assignTreatmentResponse> => {
	return orvalFetch<assignTreatmentResponse>(getAssignTreatmentUrl(params), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(assignRequest),
	});
};

export const getAssignTreatmentMutationFetcher = (
	params: AssignTreatmentParams,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: AssignRequest },
	): Promise<assignTreatmentResponse> => {
		return assignTreatment(arg, params, options);
	};
};
export const getAssignTreatmentMutationKey = (params: AssignTreatmentParams) =>
	[`/v1/assign`, ...(params ? [params] : [])] as const;

export type AssignTreatmentMutationResult = NonNullable<
	Awaited<ReturnType<typeof assignTreatment>>
>;
export type AssignTreatmentMutationError = HTTPValidationError;

/**
 * @summary Assign treatment given experiment and audience specification.
 */
export const useAssignTreatment = <TError = HTTPValidationError>(
	params: AssignTreatmentParams,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof assignTreatment>>,
			TError,
			Key,
			AssignRequest,
			Awaited<ReturnType<typeof assignTreatment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getAssignTreatmentMutationKey(params);
	const swrFn = getAssignTreatmentMutationFetcher(params, requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Retrieve all participant assignments for the given experiment_id.
 */
export type assignmentFileResponse = {
	data: WebhookResponse | HTTPValidationError | WebhookResponse;
	status: number;
	headers: Headers;
};

export const getAssignmentFileUrl = (params: AssignmentFileParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	return normalizedParams.size
		? `/v1/assignment-file?${normalizedParams.toString()}`
		: `/v1/assignment-file`;
};

export const assignmentFile = async (
	params: AssignmentFileParams,
	options?: RequestInit,
): Promise<assignmentFileResponse> => {
	return orvalFetch<assignmentFileResponse>(getAssignmentFileUrl(params), {
		...options,
		method: "GET",
	});
};

export const getAssignmentFileKey = (params: AssignmentFileParams) =>
	[`/v1/assignment-file`, ...(params ? [params] : [])] as const;

export type AssignmentFileQueryResult = NonNullable<
	Awaited<ReturnType<typeof assignmentFile>>
>;
export type AssignmentFileQueryError = HTTPValidationError | WebhookResponse;

/**
 * @summary Retrieve all participant assignments for the given experiment_id.
 */
export const useAssignmentFile = <
	TError = HTTPValidationError | WebhookResponse,
>(
	params: AssignmentFileParams,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof assignmentFile>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getAssignmentFileKey(params) : null));
	const swrFn = () => assignmentFile(params, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Commit an experiment to the database.
 */
export type commitExperimentResponse = {
	data: WebhookResponse | HTTPValidationError | WebhookResponse;
	status: number;
	headers: Headers;
};

export const getCommitExperimentUrl = (params: CommitExperimentParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	return normalizedParams.size
		? `/v1/commit?${normalizedParams.toString()}`
		: `/v1/commit`;
};

export const commitExperiment = async (
	commitRequest: CommitRequest,
	params: CommitExperimentParams,
	options?: RequestInit,
): Promise<commitExperimentResponse> => {
	return orvalFetch<commitExperimentResponse>(getCommitExperimentUrl(params), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(commitRequest),
	});
};

export const getCommitExperimentMutationFetcher = (
	params: CommitExperimentParams,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: CommitRequest },
	): Promise<commitExperimentResponse> => {
		return commitExperiment(arg, params, options);
	};
};
export const getCommitExperimentMutationKey = (
	params: CommitExperimentParams,
) => [`/v1/commit`, ...(params ? [params] : [])] as const;

export type CommitExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof commitExperiment>>
>;
export type CommitExperimentMutationError =
	| HTTPValidationError
	| WebhookResponse;

/**
 * @summary Commit an experiment to the database.
 */
export const useCommitExperiment = <
	TError = HTTPValidationError | WebhookResponse,
>(
	params: CommitExperimentParams,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof commitExperiment>>,
			TError,
			Key,
			CommitRequest,
			Awaited<ReturnType<typeof commitExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getCommitExperimentMutationKey(params);
	const swrFn = getCommitExperimentMutationFetcher(params, requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Update an existing experiment's timestamps or description (experiment and arms)
 */
export type updateExperimentResponse = {
	data: WebhookResponse | HTTPValidationError | WebhookResponse;
	status: number;
	headers: Headers;
};

export const getUpdateExperimentUrl = (params: UpdateExperimentParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	return normalizedParams.size
		? `/v1/update-commit?${normalizedParams.toString()}`
		: `/v1/update-commit`;
};

export const updateExperiment = async (
	webhookUpdateCommitRequest: WebhookUpdateCommitRequest,
	params: UpdateExperimentParams,
	options?: RequestInit,
): Promise<updateExperimentResponse> => {
	return orvalFetch<updateExperimentResponse>(getUpdateExperimentUrl(params), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(webhookUpdateCommitRequest),
	});
};

export const getUpdateExperimentMutationFetcher = (
	params: UpdateExperimentParams,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: WebhookUpdateCommitRequest },
	): Promise<updateExperimentResponse> => {
		return updateExperiment(arg, params, options);
	};
};
export const getUpdateExperimentMutationKey = (
	params: UpdateExperimentParams,
) => [`/v1/update-commit`, ...(params ? [params] : [])] as const;

export type UpdateExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateExperiment>>
>;
export type UpdateExperimentMutationError =
	| HTTPValidationError
	| WebhookResponse;

/**
 * @summary Update an existing experiment's timestamps or description (experiment and arms)
 */
export const useUpdateExperiment = <
	TError = HTTPValidationError | WebhookResponse,
>(
	params: UpdateExperimentParams,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof updateExperiment>>,
			TError,
			Key,
			WebhookUpdateCommitRequest,
			Awaited<ReturnType<typeof updateExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey = swrOptions?.swrKey ?? getUpdateExperimentMutationKey(params);
	const swrFn = getUpdateExperimentMutationFetcher(params, requestOptions);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Update an existing experiment. (limited update capabilities)
 */
export type altUpdateExperimentResponse = {
	data: WebhookResponse | HTTPValidationError | WebhookResponse;
	status: number;
	headers: Headers;
};

export const getAltUpdateExperimentUrl = (experimentId: string) => {
	return `/v1/experiment/${experimentId}`;
};

export const altUpdateExperiment = async (
	experimentId: string,
	altUpdateExperimentBody: AltUpdateExperimentBody,
	options?: RequestInit,
): Promise<altUpdateExperimentResponse> => {
	return orvalFetch<altUpdateExperimentResponse>(
		getAltUpdateExperimentUrl(experimentId),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(altUpdateExperimentBody),
		},
	);
};

export const getAltUpdateExperimentMutationFetcher = (
	experimentId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: AltUpdateExperimentBody },
	): Promise<altUpdateExperimentResponse> => {
		return altUpdateExperiment(experimentId, arg, options);
	};
};
export const getAltUpdateExperimentMutationKey = (experimentId: string) =>
	[`/v1/experiment/${experimentId}`] as const;

export type AltUpdateExperimentMutationResult = NonNullable<
	Awaited<ReturnType<typeof altUpdateExperiment>>
>;
export type AltUpdateExperimentMutationError =
	| HTTPValidationError
	| WebhookResponse;

/**
 * @summary Update an existing experiment. (limited update capabilities)
 */
export const useAltUpdateExperiment = <
	TError = HTTPValidationError | WebhookResponse,
>(
	experimentId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof altUpdateExperiment>>,
			TError,
			Key,
			AltUpdateExperimentBody,
			Awaited<ReturnType<typeof altUpdateExperiment>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getAltUpdateExperimentMutationKey(experimentId);
	const swrFn = getAltUpdateExperimentMutationFetcher(
		experimentId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
