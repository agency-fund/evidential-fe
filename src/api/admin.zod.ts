/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Evidential Experiments API
 * OpenAPI spec version: 0.9.0
 */
import { z as zod } from "zod";

/**
 * Returns basic metadata about the authenticated caller of this method.
 * @summary Caller Identity
 */
export const callerIdentityResponse = zod
	.object({
		email: zod.string(),
		iss: zod.string(),
		sub: zod.string(),
		hd: zod.string(),
		is_privileged: zod.boolean(),
	})
	.describe(
		"Describes the user's identity in a format suitable for use in the frontend.",
	);

/**
 * Returns a list of organizations that the authenticated user is a member of.
 * @summary List Organizations
 */
export const listOrganizationsResponseItemsItemIdMax = 64;
export const listOrganizationsResponseItemsItemNameMax = 100;

export const listOrganizationsResponse = zod.object({
	items: zod.array(
		zod.object({
			id: zod.string().max(listOrganizationsResponseItemsItemIdMax),
			name: zod.string().max(listOrganizationsResponseItemsItemNameMax),
		}),
	),
});

/**
 * Creates a new organization.

Only privileged users can create organizations.
 * @summary Create Organizations
 */
export const createOrganizationsBodyNameMax = 100;

export const createOrganizationsBody = zod.object({
	name: zod.string().max(createOrganizationsBodyNameMax),
});

export const createOrganizationsResponseIdMax = 64;

export const createOrganizationsResponse = zod.object({
	id: zod.string().max(createOrganizationsResponseIdMax),
});

/**
 * Adds a Webhook to an organization.
 * @summary Add Webhook To Organization
 */
export const addWebhookToOrganizationParams = zod.object({
	organization_id: zod.string(),
});

export const addWebhookToOrganizationBodyNameMax = 100;
export const addWebhookToOrganizationBodyUrlMax = 500;

export const addWebhookToOrganizationBody = zod.object({
	type: zod.string(),
	name: zod
		.string()
		.max(addWebhookToOrganizationBodyNameMax)
		.describe(
			"User-friendly name for the webhook. This name is displayed in the UI and helps identify the webhook's purpose.",
		),
	url: zod
		.string()
		.max(addWebhookToOrganizationBodyUrlMax)
		.describe(
			"The HTTP or HTTPS URL that will receive webhook notifications when events occur.",
		),
});

export const addWebhookToOrganizationResponse = zod
	.object({
		id: zod.string().describe("The ID of the newly created webhook."),
		type: zod.string().describe("The type of webhook; e.g. experiment.created"),
		name: zod.string().describe("User-friendly name for the webhook."),
		url: zod.string().describe("The URL to notify."),
		auth_token: zod
			.string()
			.or(zod.null())
			.describe(
				"The value of the Webhook-Token: header that will be sent with the request to the configured URL.",
			),
	})
	.describe("Information on the successfully created webhook.");

/**
 * Lists all the webhooks for an organization.
 * @summary List Organization Webhooks
 */
export const listOrganizationWebhooksParams = zod.object({
	organization_id: zod.string(),
});

export const listOrganizationWebhooksResponse = zod.object({
	items: zod.array(
		zod
			.object({
				id: zod.string().describe("The ID of the webhook."),
				type: zod
					.string()
					.describe("The type of webhook; e.g. experiment.created"),
				name: zod.string().describe("User-friendly name for the webhook."),
				url: zod.string().describe("The URL to notify."),
				auth_token: zod
					.string()
					.or(zod.null())
					.describe(
						"The value of the Webhook-Token: header that will be sent with the request to the configured URL.",
					),
			})
			.describe("Summarizes a Webhook configuration for an organization."),
	),
});

/**
 * Updates a webhook's name and URL in an organization.
 * @summary Update Organization Webhook
 */
export const updateOrganizationWebhookParams = zod.object({
	organization_id: zod.string(),
	webhook_id: zod.string(),
});

export const updateOrganizationWebhookBodyNameMax = 100;
export const updateOrganizationWebhookBodyUrlMax = 500;

export const updateOrganizationWebhookBody = zod
	.object({
		name: zod
			.string()
			.max(updateOrganizationWebhookBodyNameMax)
			.describe(
				"User-friendly name for the webhook. This name is displayed in the UI and helps identify the webhook's purpose.",
			),
		url: zod
			.string()
			.max(updateOrganizationWebhookBodyUrlMax)
			.describe(
				"The HTTP or HTTPS URL that will receive webhook notifications when events occur.",
			),
	})
	.describe("Request to update a webhook's name and URL.");

/**
 * Removes a Webhook from an organization.
 * @summary Delete Webhook From Organization
 */
export const deleteWebhookFromOrganizationParams = zod.object({
	organization_id: zod.string(),
	webhook_id: zod.string(),
});

export const deleteWebhookFromOrganizationQueryAllowMissingDefault = false;

export const deleteWebhookFromOrganizationQueryParams = zod.object({
	allow_missing: zod
		.boolean()
		.optional()
		.describe("If true, return a 204 even if the resource does not exist."),
});

/**
 * Regenerates the auth token for a webhook in an organization.
 * @summary Regenerate Webhook Auth Token
 */
export const regenerateWebhookAuthTokenParams = zod.object({
	organization_id: zod.string(),
	webhook_id: zod.string(),
});

/**
 * Returns the most recent 200 events in an organization.
 * @summary List Organization Events
 */
export const listOrganizationEventsParams = zod.object({
	organization_id: zod.string(),
});

export const listOrganizationEventsResponse = zod.object({
	items: zod.array(
		zod
			.object({
				id: zod.string().describe("The ID of the event."),
				created_at: zod
					.string()
					.datetime({})
					.describe("The time the event was created."),
				type: zod.string().describe("The type of event."),
				summary: zod.string().describe("Human-readable summary of the event."),
				link: zod
					.string()
					.or(zod.null())
					.optional()
					.describe("A navigable link to related information."),
				details: zod
					.record(zod.string(), zod.any())
					.or(zod.null())
					.describe("Details"),
			})
			.describe("Describes an event."),
	),
});

/**
 * Adds a new member to an organization.

The authenticated user must be part of the organization to add members.
 * @summary Add Member To Organization
 */
export const addMemberToOrganizationParams = zod.object({
	organization_id: zod.string(),
});

export const addMemberToOrganizationBody = zod.object({
	email: zod.string(),
});

/**
 * Removes a member from an organization.

The authenticated user must be part of the organization to remove members.
 * @summary Remove Member From Organization
 */
export const removeMemberFromOrganizationParams = zod.object({
	organization_id: zod.string(),
	user_id: zod.string(),
});

/**
 * Updates an organization's properties.

The authenticated user must be a member of the organization.
Currently only supports updating the organization name.
 * @summary Update Organization
 */
export const updateOrganizationParams = zod.object({
	organization_id: zod.string(),
});

export const updateOrganizationBodyNameMaxOne = 100;

export const updateOrganizationBody = zod.object({
	name: zod
		.string()
		.max(updateOrganizationBodyNameMaxOne)
		.or(zod.null())
		.optional(),
});

export const updateOrganizationResponse = zod.any();

/**
 * Returns detailed information about a specific organization.

The authenticated user must be a member of the organization.
 * @summary Get Organization
 */
export const getOrganizationParams = zod.object({
	organization_id: zod.string(),
});

export const getOrganizationResponseIdMax = 64;
export const getOrganizationResponseNameMax = 100;
export const getOrganizationResponseUsersItemIdMax = 64;
export const getOrganizationResponseUsersItemEmailMax = 64;
export const getOrganizationResponseDatasourcesItemIdMax = 64;
export const getOrganizationResponseDatasourcesItemNameMax = 100;
export const getOrganizationResponseDatasourcesItemOrganizationIdMax = 64;
export const getOrganizationResponseDatasourcesItemOrganizationNameMax = 100;

export const getOrganizationResponse = zod.object({
	id: zod.string().max(getOrganizationResponseIdMax),
	name: zod.string().max(getOrganizationResponseNameMax),
	users: zod.array(
		zod.object({
			id: zod.string().max(getOrganizationResponseUsersItemIdMax),
			email: zod.string().max(getOrganizationResponseUsersItemEmailMax),
		}),
	),
	datasources: zod.array(
		zod.object({
			id: zod.string().max(getOrganizationResponseDatasourcesItemIdMax),
			name: zod.string().max(getOrganizationResponseDatasourcesItemNameMax),
			driver: zod.string(),
			type: zod.string(),
			organization_id: zod
				.string()
				.max(getOrganizationResponseDatasourcesItemOrganizationIdMax),
			organization_name: zod
				.string()
				.max(getOrganizationResponseDatasourcesItemOrganizationNameMax),
		}),
	),
});

/**
 * Returns a list of datasources accessible to the authenticated user for an org.
 * @summary List Organization Datasources
 */
export const listOrganizationDatasourcesParams = zod.object({
	organization_id: zod.string(),
});

export const listOrganizationDatasourcesResponseItemsItemIdMax = 64;
export const listOrganizationDatasourcesResponseItemsItemNameMax = 100;
export const listOrganizationDatasourcesResponseItemsItemOrganizationIdMax = 64;
export const listOrganizationDatasourcesResponseItemsItemOrganizationNameMax = 100;

export const listOrganizationDatasourcesResponse = zod.object({
	items: zod.array(
		zod.object({
			id: zod.string().max(listOrganizationDatasourcesResponseItemsItemIdMax),
			name: zod
				.string()
				.max(listOrganizationDatasourcesResponseItemsItemNameMax),
			driver: zod.string(),
			type: zod.string(),
			organization_id: zod
				.string()
				.max(listOrganizationDatasourcesResponseItemsItemOrganizationIdMax),
			organization_name: zod
				.string()
				.max(listOrganizationDatasourcesResponseItemsItemOrganizationNameMax),
		}),
	),
});

/**
 * Creates a new datasource for the specified organization.
 * @summary Create Datasource
 */
export const createDatasourceBodyOrganizationIdMax = 64;
export const createDatasourceBodyDwhPortDefault = 5432;
export const createDatasourceBodyDwhPortMin = 1024;

export const createDatasourceBodyDwhPortMax = 65535;
export const createDatasourceBodyDwhProjectIdMin = 6;

export const createDatasourceBodyDwhProjectIdMax = 30;

export const createDatasourceBodyDwhProjectIdRegExp = new RegExp(
	"^[a-z0-9-]+$",
);
export const createDatasourceBodyDwhDatasetIdMax = 1024;

export const createDatasourceBodyDwhDatasetIdRegExp = new RegExp(
	"^[a-zA-Z0-9_]+$",
);
export const createDatasourceBodyDwhCredentialsContentBase64Min = 4;

export const createDatasourceBodyDwhCredentialsContentBase64Max = 8000;

export const createDatasourceBody = zod.object({
	organization_id: zod.string().max(createDatasourceBodyOrganizationIdMax),
	name: zod.string(),
	dwh: zod.discriminatedUnion("driver", [
		zod
			.object({
				driver: zod.enum(["postgresql+psycopg", "postgresql+psycopg2"]),
				host: zod.string(),
				port: zod
					.number()
					.min(createDatasourceBodyDwhPortMin)
					.max(createDatasourceBodyDwhPortMax)
					.default(createDatasourceBodyDwhPortDefault),
				user: zod.string(),
				password: zod.string(),
				dbname: zod.string(),
				sslmode: zod.enum(["disable", "require", "verify-ca", "verify-full"]),
				search_path: zod.string().or(zod.null()).optional(),
			})
			.describe(
				"Describes a set of parameters suitable for connecting to most types of remote databases.",
			),
		zod
			.object({
				driver: zod.enum(["bigquery"]),
				project_id: zod
					.string()
					.min(createDatasourceBodyDwhProjectIdMin)
					.max(createDatasourceBodyDwhProjectIdMax)
					.regex(createDatasourceBodyDwhProjectIdRegExp)
					.describe("The Google Cloud Project ID containing the dataset."),
				dataset_id: zod
					.string()
					.min(1)
					.max(createDatasourceBodyDwhDatasetIdMax)
					.regex(createDatasourceBodyDwhDatasetIdRegExp)
					.describe("The dataset name."),
				credentials: zod
					.discriminatedUnion("type", [
						zod
							.object({
								type: zod.enum(["serviceaccountinfo"]),
								content_base64: zod
									.string()
									.min(createDatasourceBodyDwhCredentialsContentBase64Min)
									.max(createDatasourceBodyDwhCredentialsContentBase64Max)
									.describe(
										"The base64-encoded service account info in the canonical JSON form.",
									),
							})
							.describe("Describes a Google Cloud Service Account credential."),
						zod
							.object({
								type: zod.enum(["serviceaccountfile"]),
								path: zod
									.string()
									.describe(
										"The path to the service account credentials file containing the credentials in canonical JSON form.",
									),
							})
							.describe(
								"Describes a file path to a Google Cloud Service Account credential file.",
							),
					])
					.describe("The Google Cloud Service Account credentials."),
			})
			.describe("Describes a BigQuery connection."),
		zod
			.object({
				driver: zod.enum(["none"]),
			})
			.describe(
				"NoDwh is used to indicate that no data warehouse is configured.",
			),
	]),
});

export const createDatasourceResponseIdMax = 64;

export const createDatasourceResponse = zod.object({
	id: zod.string().max(createDatasourceResponseIdMax),
});

/**
 * @summary Update Datasource
 */
export const updateDatasourceParams = zod.object({
	datasource_id: zod.string(),
});

export const updateDatasourceBodyNameMaxOne = 100;
export const updateDatasourceBodyDwhPortDefault = 5432;
export const updateDatasourceBodyDwhPortMin = 1024;

export const updateDatasourceBodyDwhPortMax = 65535;
export const updateDatasourceBodyDwhProjectIdMin = 6;

export const updateDatasourceBodyDwhProjectIdMax = 30;

export const updateDatasourceBodyDwhProjectIdRegExp = new RegExp(
	"^[a-z0-9-]+$",
);
export const updateDatasourceBodyDwhDatasetIdMax = 1024;

export const updateDatasourceBodyDwhDatasetIdRegExp = new RegExp(
	"^[a-zA-Z0-9_]+$",
);
export const updateDatasourceBodyDwhCredentialsContentBase64Min = 4;

export const updateDatasourceBodyDwhCredentialsContentBase64Max = 8000;

export const updateDatasourceBody = zod.object({
	name: zod
		.string()
		.max(updateDatasourceBodyNameMaxOne)
		.or(zod.null())
		.optional(),
	dwh: zod
		.discriminatedUnion("driver", [
			zod
				.object({
					driver: zod.enum(["postgresql+psycopg", "postgresql+psycopg2"]),
					host: zod.string(),
					port: zod
						.number()
						.min(updateDatasourceBodyDwhPortMin)
						.max(updateDatasourceBodyDwhPortMax)
						.default(updateDatasourceBodyDwhPortDefault),
					user: zod.string(),
					password: zod.string(),
					dbname: zod.string(),
					sslmode: zod.enum(["disable", "require", "verify-ca", "verify-full"]),
					search_path: zod.string().or(zod.null()).optional(),
				})
				.describe(
					"Describes a set of parameters suitable for connecting to most types of remote databases.",
				),
			zod
				.object({
					driver: zod.enum(["bigquery"]),
					project_id: zod
						.string()
						.min(updateDatasourceBodyDwhProjectIdMin)
						.max(updateDatasourceBodyDwhProjectIdMax)
						.regex(updateDatasourceBodyDwhProjectIdRegExp)
						.describe("The Google Cloud Project ID containing the dataset."),
					dataset_id: zod
						.string()
						.min(1)
						.max(updateDatasourceBodyDwhDatasetIdMax)
						.regex(updateDatasourceBodyDwhDatasetIdRegExp)
						.describe("The dataset name."),
					credentials: zod
						.discriminatedUnion("type", [
							zod
								.object({
									type: zod.enum(["serviceaccountinfo"]),
									content_base64: zod
										.string()
										.min(updateDatasourceBodyDwhCredentialsContentBase64Min)
										.max(updateDatasourceBodyDwhCredentialsContentBase64Max)
										.describe(
											"The base64-encoded service account info in the canonical JSON form.",
										),
								})
								.describe(
									"Describes a Google Cloud Service Account credential.",
								),
							zod
								.object({
									type: zod.enum(["serviceaccountfile"]),
									path: zod
										.string()
										.describe(
											"The path to the service account credentials file containing the credentials in canonical JSON form.",
										),
								})
								.describe(
									"Describes a file path to a Google Cloud Service Account credential file.",
								),
						])
						.describe("The Google Cloud Service Account credentials."),
				})
				.describe("Describes a BigQuery connection."),
			zod
				.object({
					driver: zod.enum(["none"]),
				})
				.describe(
					"NoDwh is used to indicate that no data warehouse is configured.",
				),
		])
		.or(zod.null())
		.optional(),
});

export const updateDatasourceResponse = zod.any();

/**
 * Returns detailed information about a specific datasource.
 * @summary Get Datasource
 */
export const getDatasourceParams = zod.object({
	datasource_id: zod.string(),
});

export const getDatasourceResponseIdMax = 64;
export const getDatasourceResponseNameMax = 100;
export const getDatasourceResponseConfigParticipantsItemFieldsItemDescriptionDefault =
	"";
export const getDatasourceResponseConfigParticipantsItemFieldsItemIsUniqueIdDefault = false;
export const getDatasourceResponseConfigParticipantsItemFieldsItemIsStrataDefault = false;
export const getDatasourceResponseConfigParticipantsItemFieldsItemIsFilterDefault = false;
export const getDatasourceResponseConfigParticipantsItemFieldsItemIsMetricDefault = false;
export const getDatasourceResponseConfigDwhPortDefault = 5432;
export const getDatasourceResponseConfigDwhPortMin = 1024;

export const getDatasourceResponseConfigDwhPortMax = 65535;
export const getDatasourceResponseConfigDwhProjectIdMin = 6;

export const getDatasourceResponseConfigDwhProjectIdMax = 30;

export const getDatasourceResponseConfigDwhProjectIdRegExp = new RegExp(
	"^[a-z0-9-]+$",
);
export const getDatasourceResponseConfigDwhDatasetIdMax = 1024;

export const getDatasourceResponseConfigDwhDatasetIdRegExp = new RegExp(
	"^[a-zA-Z0-9_]+$",
);
export const getDatasourceResponseConfigDwhCredentialsContentBase64Min = 4;

export const getDatasourceResponseConfigDwhCredentialsContentBase64Max = 8000;
export const getDatasourceResponseOrganizationIdMax = 64;
export const getDatasourceResponseOrganizationNameMax = 100;

export const getDatasourceResponse = zod.object({
	id: zod.string().max(getDatasourceResponseIdMax),
	name: zod.string().max(getDatasourceResponseNameMax),
	config: zod
		.object({
			participants: zod.array(
				zod.discriminatedUnion("type", [
					zod.object({
						table_name: zod
							.string()
							.describe("Name of the table in the data warehouse"),
						fields: zod
							.array(
								zod.object({
									field_name: zod
										.string()
										.describe("Name of the field in the data source"),
									data_type: zod
										.enum([
											"boolean",
											"character varying",
											"uuid",
											"date",
											"integer",
											"double precision",
											"numeric",
											"timestamp without time zone",
											"timestamp with time zone",
											"bigint",
											"jsonb (unsupported)",
											"json (unsupported)",
											"unsupported",
										])
										.describe(
											"Defines the supported data types for fields in the data source.",
										),
									description: zod
										.string()
										.optional()
										.describe("Human-readable description of the field"),
									is_unique_id: zod
										.boolean()
										.optional()
										.describe("Whether this field uniquely identifies records"),
									is_strata: zod
										.boolean()
										.optional()
										.describe(
											"Whether this field should be used for stratification",
										),
									is_filter: zod
										.boolean()
										.optional()
										.describe("Whether this field can be used as a filter"),
									is_metric: zod
										.boolean()
										.optional()
										.describe("Whether this field can be used as a metric"),
									extra: zod
										.record(zod.string(), zod.string())
										.or(zod.null())
										.optional()
										.describe("Additional field metadata"),
								}),
							)
							.describe("List of fields available in this table"),
						participant_type: zod
							.string()
							.describe(
								"The name of the set of participants defined by the filters. This name must be unique within a datasource.",
							),
						type: zod.enum(["schema"]),
					}),
				]),
			),
			webhook_config: zod
				.object({
					actions: zod
						.object({
							commit: zod
								.object({
									method: zod.enum(["GET", "POST", "PUT", "PATCH", "DELETE"]),
									url: zod.string(),
								})
								.describe("Represents a url and HTTP method to use with it.")
								.or(zod.null())
								.optional(),
						})
						.describe(
							"The set of supported actions that trigger a user callback.",
						),
					common_headers: zod
						.object({
							authorization: zod.string().or(zod.null()),
						})
						.describe(
							"Enumerates supported headers to attach to all webhook requests.",
						),
				})
				.describe("Top-level configuration object for user-defined webhooks.")
				.or(zod.null())
				.optional(),
			type: zod.string(),
			dwh: zod.discriminatedUnion("driver", [
				zod
					.object({
						driver: zod.enum(["postgresql+psycopg", "postgresql+psycopg2"]),
						host: zod.string(),
						port: zod
							.number()
							.min(getDatasourceResponseConfigDwhPortMin)
							.max(getDatasourceResponseConfigDwhPortMax)
							.default(getDatasourceResponseConfigDwhPortDefault),
						user: zod.string(),
						password: zod.string(),
						dbname: zod.string(),
						sslmode: zod.enum([
							"disable",
							"require",
							"verify-ca",
							"verify-full",
						]),
						search_path: zod.string().or(zod.null()).optional(),
					})
					.describe(
						"Describes a set of parameters suitable for connecting to most types of remote databases.",
					),
				zod
					.object({
						driver: zod.enum(["bigquery"]),
						project_id: zod
							.string()
							.min(getDatasourceResponseConfigDwhProjectIdMin)
							.max(getDatasourceResponseConfigDwhProjectIdMax)
							.regex(getDatasourceResponseConfigDwhProjectIdRegExp)
							.describe("The Google Cloud Project ID containing the dataset."),
						dataset_id: zod
							.string()
							.min(1)
							.max(getDatasourceResponseConfigDwhDatasetIdMax)
							.regex(getDatasourceResponseConfigDwhDatasetIdRegExp)
							.describe("The dataset name."),
						credentials: zod
							.discriminatedUnion("type", [
								zod
									.object({
										type: zod.enum(["serviceaccountinfo"]),
										content_base64: zod
											.string()
											.min(
												getDatasourceResponseConfigDwhCredentialsContentBase64Min,
											)
											.max(
												getDatasourceResponseConfigDwhCredentialsContentBase64Max,
											)
											.describe(
												"The base64-encoded service account info in the canonical JSON form.",
											),
									})
									.describe(
										"Describes a Google Cloud Service Account credential.",
									),
								zod
									.object({
										type: zod.enum(["serviceaccountfile"]),
										path: zod
											.string()
											.describe(
												"The path to the service account credentials file containing the credentials in canonical JSON form.",
											),
									})
									.describe(
										"Describes a file path to a Google Cloud Service Account credential file.",
									),
							])
							.describe("The Google Cloud Service Account credentials."),
					})
					.describe("Describes a BigQuery connection."),
				zod
					.object({
						driver: zod.enum(["none"]),
					})
					.describe(
						"NoDwh is used to indicate that no data warehouse is configured.",
					),
			]),
		})
		.describe(
			"RemoteDatabaseConfig defines a configuration for a remote data warehouse.",
		),
	organization_id: zod.string().max(getDatasourceResponseOrganizationIdMax),
	organization_name: zod.string().max(getDatasourceResponseOrganizationNameMax),
});

/**
 * Verifies connectivity to a datasource and returns a list of readable tables.
 * @summary Inspect Datasource
 */
export const inspectDatasourceParams = zod.object({
	datasource_id: zod.string(),
});

export const inspectDatasourceQueryRefreshDefault = false;

export const inspectDatasourceQueryParams = zod.object({
	refresh: zod.boolean().optional().describe("Refresh the cache."),
});

export const inspectDatasourceResponse = zod.object({
	tables: zod.array(zod.string()),
});

/**
 * Inspects a single table in a datasource and returns a summary of its fields.
 * @summary Inspect Table In Datasource
 */
export const inspectTableInDatasourceParams = zod.object({
	datasource_id: zod.string(),
	table_name: zod.string(),
});

export const inspectTableInDatasourceQueryRefreshDefault = false;

export const inspectTableInDatasourceQueryParams = zod.object({
	refresh: zod.boolean().optional().describe("Refresh the cache."),
});

export const inspectTableInDatasourceResponseFieldsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectTableInDatasourceResponseFieldsItemDescriptionMax = 2000;

export const inspectTableInDatasourceResponse = zod
	.object({
		detected_unique_id_fields: zod
			.array(zod.string())
			.describe("Fields that are possibly candidates for unique IDs."),
		fields: zod
			.array(
				zod
					.object({
						field_name: zod
							.string()
							.regex(inspectTableInDatasourceResponseFieldsItemFieldNameRegExp),
						data_type: zod
							.enum([
								"boolean",
								"character varying",
								"uuid",
								"date",
								"integer",
								"double precision",
								"numeric",
								"timestamp without time zone",
								"timestamp with time zone",
								"bigint",
								"jsonb (unsupported)",
								"json (unsupported)",
								"unsupported",
							])
							.describe(
								"Defines the supported data types for fields in the data source.",
							),
						description: zod
							.string()
							.max(inspectTableInDatasourceResponseFieldsItemDescriptionMax),
					})
					.describe("Concise summary of fields in the table."),
			)
			.describe("Fields in the table."),
	})
	.describe("Describes a table in the datasource.");

/**
 * Deletes a datasource.

The user must be a member of the organization that owns the datasource.
 * @summary Delete Datasource
 */
export const deleteDatasourceParams = zod.object({
	organization_id: zod.string(),
	datasource_id: zod.string(),
});

export const deleteDatasourceQueryAllowMissingDefault = false;

export const deleteDatasourceQueryParams = zod.object({
	allow_missing: zod
		.boolean()
		.optional()
		.describe("If true, return a 204 even if the resource does not exist."),
});

/**
 * @summary List Participant Types
 */
export const listParticipantTypesParams = zod.object({
	datasource_id: zod.string(),
});

export const listParticipantTypesResponseItemsItemFieldsItemDescriptionDefault =
	"";
export const listParticipantTypesResponseItemsItemFieldsItemIsUniqueIdDefault = false;
export const listParticipantTypesResponseItemsItemFieldsItemIsStrataDefault = false;
export const listParticipantTypesResponseItemsItemFieldsItemIsFilterDefault = false;
export const listParticipantTypesResponseItemsItemFieldsItemIsMetricDefault = false;

export const listParticipantTypesResponse = zod.object({
	items: zod.array(
		zod.discriminatedUnion("type", [
			zod.object({
				table_name: zod
					.string()
					.describe("Name of the table in the data warehouse"),
				fields: zod
					.array(
						zod.object({
							field_name: zod
								.string()
								.describe("Name of the field in the data source"),
							data_type: zod
								.enum([
									"boolean",
									"character varying",
									"uuid",
									"date",
									"integer",
									"double precision",
									"numeric",
									"timestamp without time zone",
									"timestamp with time zone",
									"bigint",
									"jsonb (unsupported)",
									"json (unsupported)",
									"unsupported",
								])
								.describe(
									"Defines the supported data types for fields in the data source.",
								),
							description: zod
								.string()
								.optional()
								.describe("Human-readable description of the field"),
							is_unique_id: zod
								.boolean()
								.optional()
								.describe("Whether this field uniquely identifies records"),
							is_strata: zod
								.boolean()
								.optional()
								.describe(
									"Whether this field should be used for stratification",
								),
							is_filter: zod
								.boolean()
								.optional()
								.describe("Whether this field can be used as a filter"),
							is_metric: zod
								.boolean()
								.optional()
								.describe("Whether this field can be used as a metric"),
							extra: zod
								.record(zod.string(), zod.string())
								.or(zod.null())
								.optional()
								.describe("Additional field metadata"),
						}),
					)
					.describe("List of fields available in this table"),
				participant_type: zod
					.string()
					.describe(
						"The name of the set of participants defined by the filters. This name must be unique within a datasource.",
					),
				type: zod.enum(["schema"]),
			}),
		]),
	),
});

/**
 * @summary Create Participant Type
 */
export const createParticipantTypeParams = zod.object({
	datasource_id: zod.string(),
});

export const createParticipantTypeBodyParticipantTypeMax = 100;
export const createParticipantTypeBodySchemaDefFieldsItemDescriptionDefault =
	"";
export const createParticipantTypeBodySchemaDefFieldsItemIsUniqueIdDefault = false;
export const createParticipantTypeBodySchemaDefFieldsItemIsStrataDefault = false;
export const createParticipantTypeBodySchemaDefFieldsItemIsFilterDefault = false;
export const createParticipantTypeBodySchemaDefFieldsItemIsMetricDefault = false;

export const createParticipantTypeBody = zod.object({
	participant_type: zod
		.string()
		.max(createParticipantTypeBodyParticipantTypeMax),
	schema_def: zod
		.object({
			table_name: zod
				.string()
				.describe("Name of the table in the data warehouse"),
			fields: zod
				.array(
					zod.object({
						field_name: zod
							.string()
							.describe("Name of the field in the data source"),
						data_type: zod
							.enum([
								"boolean",
								"character varying",
								"uuid",
								"date",
								"integer",
								"double precision",
								"numeric",
								"timestamp without time zone",
								"timestamp with time zone",
								"bigint",
								"jsonb (unsupported)",
								"json (unsupported)",
								"unsupported",
							])
							.describe(
								"Defines the supported data types for fields in the data source.",
							),
						description: zod
							.string()
							.optional()
							.describe("Human-readable description of the field"),
						is_unique_id: zod
							.boolean()
							.optional()
							.describe("Whether this field uniquely identifies records"),
						is_strata: zod
							.boolean()
							.optional()
							.describe("Whether this field should be used for stratification"),
						is_filter: zod
							.boolean()
							.optional()
							.describe("Whether this field can be used as a filter"),
						is_metric: zod
							.boolean()
							.optional()
							.describe("Whether this field can be used as a metric"),
						extra: zod
							.record(zod.string(), zod.string())
							.or(zod.null())
							.optional()
							.describe("Additional field metadata"),
					}),
				)
				.describe("List of fields available in this table"),
		})
		.describe(
			"Represents a single worksheet describing metadata about a type of Participant.",
		),
});

export const createParticipantTypeResponseParticipantTypeMax = 100;
export const createParticipantTypeResponseSchemaDefFieldsItemDescriptionDefault =
	"";
export const createParticipantTypeResponseSchemaDefFieldsItemIsUniqueIdDefault = false;
export const createParticipantTypeResponseSchemaDefFieldsItemIsStrataDefault = false;
export const createParticipantTypeResponseSchemaDefFieldsItemIsFilterDefault = false;
export const createParticipantTypeResponseSchemaDefFieldsItemIsMetricDefault = false;

export const createParticipantTypeResponse = zod.object({
	participant_type: zod
		.string()
		.max(createParticipantTypeResponseParticipantTypeMax),
	schema_def: zod
		.object({
			table_name: zod
				.string()
				.describe("Name of the table in the data warehouse"),
			fields: zod
				.array(
					zod.object({
						field_name: zod
							.string()
							.describe("Name of the field in the data source"),
						data_type: zod
							.enum([
								"boolean",
								"character varying",
								"uuid",
								"date",
								"integer",
								"double precision",
								"numeric",
								"timestamp without time zone",
								"timestamp with time zone",
								"bigint",
								"jsonb (unsupported)",
								"json (unsupported)",
								"unsupported",
							])
							.describe(
								"Defines the supported data types for fields in the data source.",
							),
						description: zod
							.string()
							.optional()
							.describe("Human-readable description of the field"),
						is_unique_id: zod
							.boolean()
							.optional()
							.describe("Whether this field uniquely identifies records"),
						is_strata: zod
							.boolean()
							.optional()
							.describe("Whether this field should be used for stratification"),
						is_filter: zod
							.boolean()
							.optional()
							.describe("Whether this field can be used as a filter"),
						is_metric: zod
							.boolean()
							.optional()
							.describe("Whether this field can be used as a metric"),
						extra: zod
							.record(zod.string(), zod.string())
							.or(zod.null())
							.optional()
							.describe("Additional field metadata"),
					}),
				)
				.describe("List of fields available in this table"),
		})
		.describe(
			"Represents a single worksheet describing metadata about a type of Participant.",
		),
});

/**
 * Returns filter, strata, and metric field metadata for a participant type, including exemplars for filter fields.
 * @summary Inspect Participant Types
 */
export const inspectParticipantTypesParams = zod.object({
	datasource_id: zod.string(),
	participant_id: zod.string(),
});

export const inspectParticipantTypesQueryRefreshDefault = false;

export const inspectParticipantTypesQueryParams = zod.object({
	refresh: zod.boolean().optional().describe("Refresh the cache."),
});

export const inspectParticipantTypesResponseFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectParticipantTypesResponseFiltersItemRelationsMax = 20;
export const inspectParticipantTypesResponseFiltersItemDescriptionMax = 2000;
export const inspectParticipantTypesResponseFiltersItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectParticipantTypesResponseFiltersItemRelationsMaxOne = 20;
export const inspectParticipantTypesResponseFiltersItemDescriptionMaxOne = 2000;
export const inspectParticipantTypesResponseMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectParticipantTypesResponseMetricsItemDescriptionMax = 2000;
export const inspectParticipantTypesResponseStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectParticipantTypesResponseStrataItemDescriptionMax = 2000;

export const inspectParticipantTypesResponse = zod
	.object({
		filters: zod.array(
			zod
				.object({
					field_name: zod
						.string()
						.regex(inspectParticipantTypesResponseFiltersItemFieldNameRegExp)
						.describe("Name of the field."),
					data_type: zod
						.enum([
							"boolean",
							"character varying",
							"uuid",
							"date",
							"integer",
							"double precision",
							"numeric",
							"timestamp without time zone",
							"timestamp with time zone",
							"bigint",
							"jsonb (unsupported)",
							"json (unsupported)",
							"unsupported",
						])
						.describe(
							"Defines the supported data types for fields in the data source.",
						),
					relations: zod
						.array(
							zod
								.enum(["includes", "excludes", "between"])
								.describe(
									"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
								),
						)
						.min(1)
						.max(inspectParticipantTypesResponseFiltersItemRelationsMax),
					description: zod
						.string()
						.max(inspectParticipantTypesResponseFiltersItemDescriptionMax),
					min: zod
						.string()
						.datetime({})
						.or(zod.string().date())
						.or(zod.number())
						.or(zod.number())
						.or(zod.null())
						.describe("The minimum observed value."),
					max: zod
						.string()
						.datetime({})
						.or(zod.string().date())
						.or(zod.number())
						.or(zod.number())
						.or(zod.null())
						.describe("The maximum observed value."),
				})
				.describe("Describes a numeric or date filter variable.")
				.or(
					zod
						.object({
							field_name: zod
								.string()
								.regex(
									inspectParticipantTypesResponseFiltersItemFieldNameRegExpOne,
								)
								.describe("Name of the field."),
							data_type: zod
								.enum([
									"boolean",
									"character varying",
									"uuid",
									"date",
									"integer",
									"double precision",
									"numeric",
									"timestamp without time zone",
									"timestamp with time zone",
									"bigint",
									"jsonb (unsupported)",
									"json (unsupported)",
									"unsupported",
								])
								.describe(
									"Defines the supported data types for fields in the data source.",
								),
							relations: zod
								.array(
									zod
										.enum(["includes", "excludes", "between"])
										.describe(
											"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
										),
								)
								.min(1)
								.max(inspectParticipantTypesResponseFiltersItemRelationsMaxOne),
							description: zod
								.string()
								.max(
									inspectParticipantTypesResponseFiltersItemDescriptionMaxOne,
								),
							distinct_values: zod
								.array(zod.string())
								.or(zod.null())
								.describe("Sorted list of unique values."),
						})
						.describe("Describes a discrete filter variable."),
				),
		),
		metrics: zod.array(
			zod
				.object({
					field_name: zod
						.string()
						.regex(inspectParticipantTypesResponseMetricsItemFieldNameRegExp),
					data_type: zod
						.enum([
							"boolean",
							"character varying",
							"uuid",
							"date",
							"integer",
							"double precision",
							"numeric",
							"timestamp without time zone",
							"timestamp with time zone",
							"bigint",
							"jsonb (unsupported)",
							"json (unsupported)",
							"unsupported",
						])
						.describe(
							"Defines the supported data types for fields in the data source.",
						),
					description: zod
						.string()
						.max(inspectParticipantTypesResponseMetricsItemDescriptionMax),
				})
				.describe("Describes a metric."),
		),
		strata: zod.array(
			zod
				.object({
					data_type: zod
						.enum([
							"boolean",
							"character varying",
							"uuid",
							"date",
							"integer",
							"double precision",
							"numeric",
							"timestamp without time zone",
							"timestamp with time zone",
							"bigint",
							"jsonb (unsupported)",
							"json (unsupported)",
							"unsupported",
						])
						.describe(
							"Defines the supported data types for fields in the data source.",
						),
					field_name: zod
						.string()
						.regex(inspectParticipantTypesResponseStrataItemFieldNameRegExp),
					description: zod
						.string()
						.max(inspectParticipantTypesResponseStrataItemDescriptionMax),
					extra: zod
						.record(zod.string(), zod.string())
						.or(zod.null())
						.optional(),
				})
				.describe("Describes a stratification variable."),
		),
	})
	.describe(
		"Describes a participant type's strata, metrics, and filters (including exemplar values).",
	);

/**
 * @summary Get Participant Types
 */
export const getParticipantTypesParams = zod.object({
	datasource_id: zod.string(),
	participant_id: zod.string(),
});

export const getParticipantTypesResponseFieldsItemDescriptionDefault = "";
export const getParticipantTypesResponseFieldsItemIsUniqueIdDefault = false;
export const getParticipantTypesResponseFieldsItemIsStrataDefault = false;
export const getParticipantTypesResponseFieldsItemIsFilterDefault = false;
export const getParticipantTypesResponseFieldsItemIsMetricDefault = false;

export const getParticipantTypesResponse = zod.discriminatedUnion("type", [
	zod.object({
		table_name: zod
			.string()
			.describe("Name of the table in the data warehouse"),
		fields: zod
			.array(
				zod.object({
					field_name: zod
						.string()
						.describe("Name of the field in the data source"),
					data_type: zod
						.enum([
							"boolean",
							"character varying",
							"uuid",
							"date",
							"integer",
							"double precision",
							"numeric",
							"timestamp without time zone",
							"timestamp with time zone",
							"bigint",
							"jsonb (unsupported)",
							"json (unsupported)",
							"unsupported",
						])
						.describe(
							"Defines the supported data types for fields in the data source.",
						),
					description: zod
						.string()
						.optional()
						.describe("Human-readable description of the field"),
					is_unique_id: zod
						.boolean()
						.optional()
						.describe("Whether this field uniquely identifies records"),
					is_strata: zod
						.boolean()
						.optional()
						.describe("Whether this field should be used for stratification"),
					is_filter: zod
						.boolean()
						.optional()
						.describe("Whether this field can be used as a filter"),
					is_metric: zod
						.boolean()
						.optional()
						.describe("Whether this field can be used as a metric"),
					extra: zod
						.record(zod.string(), zod.string())
						.or(zod.null())
						.optional()
						.describe("Additional field metadata"),
				}),
			)
			.describe("List of fields available in this table"),
		participant_type: zod
			.string()
			.describe(
				"The name of the set of participants defined by the filters. This name must be unique within a datasource.",
			),
		type: zod.enum(["schema"]),
	}),
]);

/**
 * @summary Update Participant Type
 */
export const updateParticipantTypeParams = zod.object({
	datasource_id: zod.string(),
	participant_id: zod.string(),
});

export const updateParticipantTypeBodyParticipantTypeMaxOne = 100;
export const updateParticipantTypeBodyTableNameRegExpOne = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const updateParticipantTypeBodyFieldsItemDescriptionDefault = "";
export const updateParticipantTypeBodyFieldsItemIsUniqueIdDefault = false;
export const updateParticipantTypeBodyFieldsItemIsStrataDefault = false;
export const updateParticipantTypeBodyFieldsItemIsFilterDefault = false;
export const updateParticipantTypeBodyFieldsItemIsMetricDefault = false;
export const updateParticipantTypeBodyFieldsMaxOne = 150;

export const updateParticipantTypeBody = zod.object({
	participant_type: zod
		.string()
		.max(updateParticipantTypeBodyParticipantTypeMaxOne)
		.or(zod.null())
		.optional(),
	table_name: zod
		.string()
		.regex(updateParticipantTypeBodyTableNameRegExpOne)
		.or(zod.null())
		.optional(),
	fields: zod
		.array(
			zod.object({
				field_name: zod
					.string()
					.describe("Name of the field in the data source"),
				data_type: zod
					.enum([
						"boolean",
						"character varying",
						"uuid",
						"date",
						"integer",
						"double precision",
						"numeric",
						"timestamp without time zone",
						"timestamp with time zone",
						"bigint",
						"jsonb (unsupported)",
						"json (unsupported)",
						"unsupported",
					])
					.describe(
						"Defines the supported data types for fields in the data source.",
					),
				description: zod
					.string()
					.optional()
					.describe("Human-readable description of the field"),
				is_unique_id: zod
					.boolean()
					.optional()
					.describe("Whether this field uniquely identifies records"),
				is_strata: zod
					.boolean()
					.optional()
					.describe("Whether this field should be used for stratification"),
				is_filter: zod
					.boolean()
					.optional()
					.describe("Whether this field can be used as a filter"),
				is_metric: zod
					.boolean()
					.optional()
					.describe("Whether this field can be used as a metric"),
				extra: zod
					.record(zod.string(), zod.string())
					.or(zod.null())
					.optional()
					.describe("Additional field metadata"),
			}),
		)
		.max(updateParticipantTypeBodyFieldsMaxOne)
		.or(zod.null())
		.optional(),
});

export const updateParticipantTypeResponseParticipantTypeMax = 100;
export const updateParticipantTypeResponseTableNameRegExpOne = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const updateParticipantTypeResponseFieldsItemDescriptionDefault = "";
export const updateParticipantTypeResponseFieldsItemIsUniqueIdDefault = false;
export const updateParticipantTypeResponseFieldsItemIsStrataDefault = false;
export const updateParticipantTypeResponseFieldsItemIsFilterDefault = false;
export const updateParticipantTypeResponseFieldsItemIsMetricDefault = false;
export const updateParticipantTypeResponseFieldsMaxOne = 150;

export const updateParticipantTypeResponse = zod.object({
	participant_type: zod
		.string()
		.max(updateParticipantTypeResponseParticipantTypeMax),
	table_name: zod
		.string()
		.regex(updateParticipantTypeResponseTableNameRegExpOne)
		.or(zod.null())
		.optional(),
	fields: zod
		.array(
			zod.object({
				field_name: zod
					.string()
					.describe("Name of the field in the data source"),
				data_type: zod
					.enum([
						"boolean",
						"character varying",
						"uuid",
						"date",
						"integer",
						"double precision",
						"numeric",
						"timestamp without time zone",
						"timestamp with time zone",
						"bigint",
						"jsonb (unsupported)",
						"json (unsupported)",
						"unsupported",
					])
					.describe(
						"Defines the supported data types for fields in the data source.",
					),
				description: zod
					.string()
					.optional()
					.describe("Human-readable description of the field"),
				is_unique_id: zod
					.boolean()
					.optional()
					.describe("Whether this field uniquely identifies records"),
				is_strata: zod
					.boolean()
					.optional()
					.describe("Whether this field should be used for stratification"),
				is_filter: zod
					.boolean()
					.optional()
					.describe("Whether this field can be used as a filter"),
				is_metric: zod
					.boolean()
					.optional()
					.describe("Whether this field can be used as a metric"),
				extra: zod
					.record(zod.string(), zod.string())
					.or(zod.null())
					.optional()
					.describe("Additional field metadata"),
			}),
		)
		.max(updateParticipantTypeResponseFieldsMaxOne)
		.or(zod.null())
		.optional(),
});

/**
 * @summary Delete Participant
 */
export const deleteParticipantParams = zod.object({
	datasource_id: zod.string(),
	participant_id: zod.string(),
});

export const deleteParticipantQueryAllowMissingDefault = false;

export const deleteParticipantQueryParams = zod.object({
	allow_missing: zod
		.boolean()
		.optional()
		.describe("If true, return a 204 even if the resource does not exist."),
});

/**
 * Returns API keys that have access to the datasource.
 * @summary List Api Keys
 */
export const listApiKeysParams = zod.object({
	datasource_id: zod.string(),
});

export const listApiKeysResponseItemsItemIdMax = 64;
export const listApiKeysResponseItemsItemDatasourceIdMax = 64;
export const listApiKeysResponseItemsItemOrganizationIdMax = 64;
export const listApiKeysResponseItemsItemOrganizationNameMax = 100;

export const listApiKeysResponse = zod.object({
	items: zod.array(
		zod.object({
			id: zod.string().max(listApiKeysResponseItemsItemIdMax),
			datasource_id: zod
				.string()
				.max(listApiKeysResponseItemsItemDatasourceIdMax),
			organization_id: zod
				.string()
				.max(listApiKeysResponseItemsItemOrganizationIdMax),
			organization_name: zod
				.string()
				.max(listApiKeysResponseItemsItemOrganizationNameMax),
		}),
	),
});

/**
 * Creates an API key for the specified datasource.

The user must belong to the organization that owns the requested datasource.
 * @summary Create Api Key
 */
export const createApiKeyParams = zod.object({
	datasource_id: zod.string(),
});

export const createApiKeyResponseIdMax = 64;

export const createApiKeyResponse = zod.object({
	id: zod.string().max(createApiKeyResponseIdMax),
	datasource_id: zod.string(),
	key: zod.string(),
});

/**
 * Deletes the specified API key.
 * @summary Delete Api Key
 */
export const deleteApiKeyParams = zod.object({
	datasource_id: zod.string(),
	api_key_id: zod.string(),
});

export const deleteApiKeyQueryAllowMissingDefault = false;

export const deleteApiKeyQueryParams = zod.object({
	allow_missing: zod
		.boolean()
		.optional()
		.describe("If true, return a 204 even if the resource does not exist."),
});

/**
 * Creates a new experiment in the specified datasource.
 * @summary Create Experiment
 */
export const createExperimentParams = zod.object({
	datasource_id: zod.string(),
});

export const createExperimentQueryStratifyOnMetricsDefault = true;

export const createExperimentQueryParams = zod.object({
	chosen_n: zod
		.number()
		.or(zod.null())
		.optional()
		.describe("Number of participants to assign."),
	stratify_on_metrics: zod
		.boolean()
		.default(createExperimentQueryStratifyOnMetricsDefault)
		.describe("Whether to also stratify on metrics during assignment."),
});

export const createExperimentBodyDesignSpecParticipantTypeMax = 100;
export const createExperimentBodyDesignSpecExperimentNameMax = 100;
export const createExperimentBodyDesignSpecDescriptionMax = 2000;
export const createExperimentBodyDesignSpecArmsItemArmNameMax = 100;
export const createExperimentBodyDesignSpecArmsItemArmDescriptionMaxOne = 2000;
export const createExperimentBodyDesignSpecArmsMin = 2;

export const createExperimentBodyDesignSpecArmsMax = 10;
export const createExperimentBodyDesignSpecStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyDesignSpecStrataMax = 150;
export const createExperimentBodyDesignSpecMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyDesignSpecMetricsMax = 150;
export const createExperimentBodyDesignSpecFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyDesignSpecFiltersMax = 20;
export const createExperimentBodyDesignSpecPowerDefault = 0.8;
export const createExperimentBodyDesignSpecPowerMin = 0;

export const createExperimentBodyDesignSpecPowerMax = 1;
export const createExperimentBodyDesignSpecAlphaDefault = 0.05;
export const createExperimentBodyDesignSpecAlphaMin = 0;

export const createExperimentBodyDesignSpecAlphaMax = 1;
export const createExperimentBodyDesignSpecFstatThreshDefault = 0.6;
export const createExperimentBodyDesignSpecFstatThreshMin = 0;

export const createExperimentBodyDesignSpecFstatThreshMax = 1;
export const createExperimentBodyDesignSpecParticipantTypeMaxOne = 100;
export const createExperimentBodyDesignSpecExperimentNameMaxOne = 100;
export const createExperimentBodyDesignSpecDescriptionMaxOne = 2000;
export const createExperimentBodyDesignSpecArmsItemArmNameMaxOne = 100;
export const createExperimentBodyDesignSpecArmsItemArmDescriptionMaxFour = 2000;
export const createExperimentBodyDesignSpecArmsMinOne = 2;

export const createExperimentBodyDesignSpecArmsMaxOne = 10;
export const createExperimentBodyDesignSpecStrataItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyDesignSpecStrataMaxOne = 150;
export const createExperimentBodyDesignSpecMetricsItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyDesignSpecMetricsMaxOne = 150;
export const createExperimentBodyDesignSpecFiltersItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyDesignSpecFiltersMaxOne = 20;
export const createExperimentBodyDesignSpecPowerDefaultOne = 0.8;
export const createExperimentBodyDesignSpecPowerMinOne = 0;

export const createExperimentBodyDesignSpecPowerMaxOne = 1;
export const createExperimentBodyDesignSpecAlphaDefaultOne = 0.05;
export const createExperimentBodyDesignSpecAlphaMinOne = 0;

export const createExperimentBodyDesignSpecAlphaMaxOne = 1;
export const createExperimentBodyDesignSpecFstatThreshDefaultOne = 0.6;
export const createExperimentBodyDesignSpecFstatThreshMinOne = 0;

export const createExperimentBodyDesignSpecFstatThreshMaxOne = 1;
export const createExperimentBodyDesignSpecParticipantTypeMaxTwo = 100;
export const createExperimentBodyDesignSpecExperimentNameMaxTwo = 100;
export const createExperimentBodyDesignSpecDescriptionMaxTwo = 2000;
export const createExperimentBodyDesignSpecArmsItemArmNameMaxTwo = 100;
export const createExperimentBodyDesignSpecArmsItemArmDescriptionMaxSeven = 2000;
export const createExperimentBodyDesignSpecArmsMinTwo = 2;

export const createExperimentBodyDesignSpecArmsMaxTwo = 10;
export const createExperimentBodyDesignSpecContextsItemContextNameMax = 100;
export const createExperimentBodyDesignSpecContextsItemContextDescriptionMaxOne = 2000;
export const createExperimentBodyDesignSpecContextsMaxOne = 150;
export const createExperimentBodyDesignSpecParticipantTypeMaxThree = 100;
export const createExperimentBodyDesignSpecExperimentNameMaxThree = 100;
export const createExperimentBodyDesignSpecDescriptionMaxThree = 2000;
export const createExperimentBodyDesignSpecArmsItemArmNameMaxThree = 100;
export const createExperimentBodyDesignSpecArmsItemArmDescriptionMaxOnezero = 2000;
export const createExperimentBodyDesignSpecArmsMinThree = 2;

export const createExperimentBodyDesignSpecArmsMaxThree = 10;
export const createExperimentBodyDesignSpecContextsItemContextNameMaxOne = 100;
export const createExperimentBodyDesignSpecContextsItemContextDescriptionMaxFour = 2000;
export const createExperimentBodyDesignSpecContextsMaxFour = 150;
export const createExperimentBodyDesignSpecParticipantTypeMaxFour = 100;
export const createExperimentBodyDesignSpecExperimentNameMaxFour = 100;
export const createExperimentBodyDesignSpecDescriptionMaxFour = 2000;
export const createExperimentBodyDesignSpecArmsItemArmNameMaxFour = 100;
export const createExperimentBodyDesignSpecArmsItemArmDescriptionMaxOnethree = 2000;
export const createExperimentBodyDesignSpecArmsMinFour = 2;

export const createExperimentBodyDesignSpecArmsMaxFour = 10;
export const createExperimentBodyDesignSpecContextsItemContextNameMaxTwo = 100;
export const createExperimentBodyDesignSpecContextsItemContextDescriptionMaxSeven = 2000;
export const createExperimentBodyDesignSpecContextsMaxSeven = 150;
export const createExperimentBodyPowerAnalysesAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyPowerAnalysesAnalysesMax = 150;
export const createExperimentBodyWebhooksDefault = [];

export const createExperimentBody = zod.object({
	design_spec: zod
		.discriminatedUnion("experiment_type", [
			zod
				.object({
					participant_type: zod
						.string()
						.max(createExperimentBodyDesignSpecParticipantTypeMax),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
						),
					experiment_type: zod.enum(["freq_preassigned"]),
					experiment_name: zod
						.string()
						.max(createExperimentBodyDesignSpecExperimentNameMax),
					description: zod
						.string()
						.max(createExperimentBodyDesignSpecDescriptionMax),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(createExperimentBodyDesignSpecArmsItemArmNameMax),
									arm_description: zod
										.string()
										.max(
											createExperimentBodyDesignSpecArmsItemArmDescriptionMaxOne,
										)
										.or(zod.null())
										.optional(),
								})
								.describe("Describes an experiment treatment arm."),
						)
						.min(createExperimentBodyDesignSpecArmsMin)
						.max(createExperimentBodyDesignSpecArmsMax),
					strata: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											createExperimentBodyDesignSpecStrataItemFieldNameRegExp,
										),
								})
								.describe("Describes a variable used for stratification."),
						)
						.max(createExperimentBodyDesignSpecStrataMax)
						.describe(
							"Optional participant_type fields to use for stratified assignment.",
						),
					metrics: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											createExperimentBodyDesignSpecMetricsItemFieldNameRegExp,
										),
									metric_pct_change: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
										),
									metric_target: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
										),
								})
								.describe(
									"Defines a request to look up baseline stats for a metric to measure in an experiment.",
								),
						)
						.min(1)
						.max(createExperimentBodyDesignSpecMetricsMax)
						.describe("Primary and optional secondary metrics to target."),
					filters: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											createExperimentBodyDesignSpecFiltersItemFieldNameRegExp,
										),
									relation: zod
										.enum(["includes", "excludes", "between"])
										.describe(
											"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
										),
									value: zod
										.array(zod.number().or(zod.null()))
										.or(zod.array(zod.number().or(zod.null())))
										.or(zod.array(zod.string().or(zod.null())))
										.or(zod.array(zod.boolean().or(zod.null()))),
								})
								.describe(
									'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value       | logical Result                                    |\n|----------|-------------|---------------------------------------------------|\n| INCLUDES | [None]      | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |\n\nString comparisons are case-sensitive.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of datetime and timestamp values\n\nDATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
								),
						)
						.max(createExperimentBodyDesignSpecFiltersMax)
						.describe(
							"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
						),
					power: zod
						.number()
						.min(createExperimentBodyDesignSpecPowerMin)
						.max(createExperimentBodyDesignSpecPowerMax)
						.default(createExperimentBodyDesignSpecPowerDefault)
						.describe(
							"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
						),
					alpha: zod
						.number()
						.min(createExperimentBodyDesignSpecAlphaMin)
						.max(createExperimentBodyDesignSpecAlphaMax)
						.default(createExperimentBodyDesignSpecAlphaDefault)
						.describe(
							"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
						),
					fstat_thresh: zod
						.number()
						.min(createExperimentBodyDesignSpecFstatThreshMin)
						.max(createExperimentBodyDesignSpecFstatThreshMax)
						.default(createExperimentBodyDesignSpecFstatThreshDefault)
						.describe(
							'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
						),
				})
				.describe(
					"Use this type to randomly select and assign from existing participants at design time with frequentist A/B experiments.",
				),
			zod
				.object({
					participant_type: zod
						.string()
						.max(createExperimentBodyDesignSpecParticipantTypeMaxOne),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
						),
					experiment_type: zod.enum(["freq_online"]),
					experiment_name: zod
						.string()
						.max(createExperimentBodyDesignSpecExperimentNameMaxOne),
					description: zod
						.string()
						.max(createExperimentBodyDesignSpecDescriptionMaxOne),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(createExperimentBodyDesignSpecArmsItemArmNameMaxOne),
									arm_description: zod
										.string()
										.max(
											createExperimentBodyDesignSpecArmsItemArmDescriptionMaxFour,
										)
										.or(zod.null())
										.optional(),
								})
								.describe("Describes an experiment treatment arm."),
						)
						.min(createExperimentBodyDesignSpecArmsMinOne)
						.max(createExperimentBodyDesignSpecArmsMaxOne),
					strata: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											createExperimentBodyDesignSpecStrataItemFieldNameRegExpOne,
										),
								})
								.describe("Describes a variable used for stratification."),
						)
						.max(createExperimentBodyDesignSpecStrataMaxOne)
						.describe(
							"Optional participant_type fields to use for stratified assignment.",
						),
					metrics: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											createExperimentBodyDesignSpecMetricsItemFieldNameRegExpOne,
										),
									metric_pct_change: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
										),
									metric_target: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
										),
								})
								.describe(
									"Defines a request to look up baseline stats for a metric to measure in an experiment.",
								),
						)
						.min(1)
						.max(createExperimentBodyDesignSpecMetricsMaxOne)
						.describe("Primary and optional secondary metrics to target."),
					filters: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											createExperimentBodyDesignSpecFiltersItemFieldNameRegExpOne,
										),
									relation: zod
										.enum(["includes", "excludes", "between"])
										.describe(
											"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
										),
									value: zod
										.array(zod.number().or(zod.null()))
										.or(zod.array(zod.number().or(zod.null())))
										.or(zod.array(zod.string().or(zod.null())))
										.or(zod.array(zod.boolean().or(zod.null()))),
								})
								.describe(
									'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value       | logical Result                                    |\n|----------|-------------|---------------------------------------------------|\n| INCLUDES | [None]      | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |\n\nString comparisons are case-sensitive.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of datetime and timestamp values\n\nDATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
								),
						)
						.max(createExperimentBodyDesignSpecFiltersMaxOne)
						.describe(
							"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
						),
					power: zod
						.number()
						.min(createExperimentBodyDesignSpecPowerMinOne)
						.max(createExperimentBodyDesignSpecPowerMaxOne)
						.default(createExperimentBodyDesignSpecPowerDefaultOne)
						.describe(
							"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
						),
					alpha: zod
						.number()
						.min(createExperimentBodyDesignSpecAlphaMinOne)
						.max(createExperimentBodyDesignSpecAlphaMaxOne)
						.default(createExperimentBodyDesignSpecAlphaDefaultOne)
						.describe(
							"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
						),
					fstat_thresh: zod
						.number()
						.min(createExperimentBodyDesignSpecFstatThreshMinOne)
						.max(createExperimentBodyDesignSpecFstatThreshMaxOne)
						.default(createExperimentBodyDesignSpecFstatThreshDefaultOne)
						.describe(
							'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
						),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution with frequentist A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
			zod
				.object({
					participant_type: zod
						.string()
						.max(createExperimentBodyDesignSpecParticipantTypeMaxTwo),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
						),
					experiment_type: zod.enum(["mab_online"]),
					experiment_name: zod
						.string()
						.max(createExperimentBodyDesignSpecExperimentNameMaxTwo),
					description: zod
						.string()
						.max(createExperimentBodyDesignSpecDescriptionMaxTwo),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(createExperimentBodyDesignSpecArmsItemArmNameMaxTwo),
									arm_description: zod
										.string()
										.max(
											createExperimentBodyDesignSpecArmsItemArmDescriptionMaxSeven,
										)
										.or(zod.null())
										.optional(),
									alpha_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial alpha parameter for Beta prior"),
									beta_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial beta parameter for Beta prior"),
									mu_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial mean parameter for Normal prior"),
									sigma_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Initial standard deviation parameter for Normal prior",
										),
									alpha: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated alpha parameter for Beta prior"),
									beta: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated beta parameter for Beta prior"),
									mu: zod
										.array(zod.number())
										.or(zod.null())
										.optional()
										.describe("Updated mean vector for Normal prior"),
									covariance: zod
										.array(zod.array(zod.number()))
										.or(zod.null())
										.optional()
										.describe("Updated covariance matrix for Normal prior"),
								})
								.describe(
									"Describes an experiment arm for bandit experiments.",
								),
						)
						.min(createExperimentBodyDesignSpecArmsMinTwo)
						.max(createExperimentBodyDesignSpecArmsMaxTwo),
					contexts: zod
						.array(
							zod
								.object({
									context_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"Unique identifier for the context, you should NOT set this when creating a new context.",
										),
									context_name: zod
										.string()
										.max(
											createExperimentBodyDesignSpecContextsItemContextNameMax,
										),
									context_description: zod
										.string()
										.max(
											createExperimentBodyDesignSpecContextsItemContextDescriptionMaxOne,
										)
										.or(zod.null())
										.optional(),
									value_type: zod
										.enum(["binary", "real-valued"])
										.optional()
										.describe("Enum for the type of context."),
								})
								.describe("Pydantic model for context of the experiment."),
						)
						.max(createExperimentBodyDesignSpecContextsMaxOne)
						.or(zod.null())
						.optional()
						.describe(
							"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
						),
					prior_type: zod
						.enum(["beta", "normal"])
						.optional()
						.describe("Enum for the prior distribution of the arm."),
					reward_type: zod
						.enum(["binary", "real-valued"])
						.optional()
						.describe("Enum for the likelihood distribution of the reward."),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution with MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
			zod
				.object({
					participant_type: zod
						.string()
						.max(createExperimentBodyDesignSpecParticipantTypeMaxThree),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
						),
					experiment_type: zod.enum(["cmab_online"]),
					experiment_name: zod
						.string()
						.max(createExperimentBodyDesignSpecExperimentNameMaxThree),
					description: zod
						.string()
						.max(createExperimentBodyDesignSpecDescriptionMaxThree),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(createExperimentBodyDesignSpecArmsItemArmNameMaxThree),
									arm_description: zod
										.string()
										.max(
											createExperimentBodyDesignSpecArmsItemArmDescriptionMaxOnezero,
										)
										.or(zod.null())
										.optional(),
									alpha_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial alpha parameter for Beta prior"),
									beta_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial beta parameter for Beta prior"),
									mu_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial mean parameter for Normal prior"),
									sigma_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Initial standard deviation parameter for Normal prior",
										),
									alpha: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated alpha parameter for Beta prior"),
									beta: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated beta parameter for Beta prior"),
									mu: zod
										.array(zod.number())
										.or(zod.null())
										.optional()
										.describe("Updated mean vector for Normal prior"),
									covariance: zod
										.array(zod.array(zod.number()))
										.or(zod.null())
										.optional()
										.describe("Updated covariance matrix for Normal prior"),
								})
								.describe(
									"Describes an experiment arm for bandit experiments.",
								),
						)
						.min(createExperimentBodyDesignSpecArmsMinThree)
						.max(createExperimentBodyDesignSpecArmsMaxThree),
					contexts: zod
						.array(
							zod
								.object({
									context_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"Unique identifier for the context, you should NOT set this when creating a new context.",
										),
									context_name: zod
										.string()
										.max(
											createExperimentBodyDesignSpecContextsItemContextNameMaxOne,
										),
									context_description: zod
										.string()
										.max(
											createExperimentBodyDesignSpecContextsItemContextDescriptionMaxFour,
										)
										.or(zod.null())
										.optional(),
									value_type: zod
										.enum(["binary", "real-valued"])
										.optional()
										.describe("Enum for the type of context."),
								})
								.describe("Pydantic model for context of the experiment."),
						)
						.max(createExperimentBodyDesignSpecContextsMaxFour)
						.or(zod.null())
						.optional()
						.describe(
							"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
						),
					prior_type: zod
						.enum(["beta", "normal"])
						.optional()
						.describe("Enum for the prior distribution of the arm."),
					reward_type: zod
						.enum(["binary", "real-valued"])
						.optional()
						.describe("Enum for the likelihood distribution of the reward."),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution with contextual MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
			zod
				.object({
					participant_type: zod
						.string()
						.max(createExperimentBodyDesignSpecParticipantTypeMaxFour),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
						),
					experiment_type: zod.enum(["bayes_ab_online"]),
					experiment_name: zod
						.string()
						.max(createExperimentBodyDesignSpecExperimentNameMaxFour),
					description: zod
						.string()
						.max(createExperimentBodyDesignSpecDescriptionMaxFour),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(createExperimentBodyDesignSpecArmsItemArmNameMaxFour),
									arm_description: zod
										.string()
										.max(
											createExperimentBodyDesignSpecArmsItemArmDescriptionMaxOnethree,
										)
										.or(zod.null())
										.optional(),
									alpha_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial alpha parameter for Beta prior"),
									beta_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial beta parameter for Beta prior"),
									mu_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial mean parameter for Normal prior"),
									sigma_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Initial standard deviation parameter for Normal prior",
										),
									alpha: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated alpha parameter for Beta prior"),
									beta: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated beta parameter for Beta prior"),
									mu: zod
										.array(zod.number())
										.or(zod.null())
										.optional()
										.describe("Updated mean vector for Normal prior"),
									covariance: zod
										.array(zod.array(zod.number()))
										.or(zod.null())
										.optional()
										.describe("Updated covariance matrix for Normal prior"),
								})
								.describe(
									"Describes an experiment arm for bandit experiments.",
								),
						)
						.min(createExperimentBodyDesignSpecArmsMinFour)
						.max(createExperimentBodyDesignSpecArmsMaxFour),
					contexts: zod
						.array(
							zod
								.object({
									context_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"Unique identifier for the context, you should NOT set this when creating a new context.",
										),
									context_name: zod
										.string()
										.max(
											createExperimentBodyDesignSpecContextsItemContextNameMaxTwo,
										),
									context_description: zod
										.string()
										.max(
											createExperimentBodyDesignSpecContextsItemContextDescriptionMaxSeven,
										)
										.or(zod.null())
										.optional(),
									value_type: zod
										.enum(["binary", "real-valued"])
										.optional()
										.describe("Enum for the type of context."),
								})
								.describe("Pydantic model for context of the experiment."),
						)
						.max(createExperimentBodyDesignSpecContextsMaxSeven)
						.or(zod.null())
						.optional()
						.describe(
							"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
						),
					prior_type: zod
						.enum(["beta", "normal"])
						.optional()
						.describe("Enum for the prior distribution of the arm."),
					reward_type: zod
						.enum(["binary", "real-valued"])
						.optional()
						.describe("Enum for the likelihood distribution of the reward."),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution with Bayesian A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
		])
		.describe("The type of assignment and experiment design."),
	power_analyses: zod
		.object({
			analyses: zod
				.array(
					zod
						.object({
							metric_spec: zod
								.object({
									field_name: zod
										.string()
										.regex(
											createExperimentBodyPowerAnalysesAnalysesItemMetricSpecFieldNameRegExp,
										),
									metric_pct_change: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Percent change target relative to the metric_baseline.",
										),
									metric_target: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Absolute target value = metric_baseline*(1 + metric_pct_change)",
										),
									metric_type: zod
										.enum(["binary", "numeric"])
										.describe("Classifies metrics by their value type.")
										.or(zod.null())
										.optional()
										.describe("Inferred from dwh type."),
									metric_baseline: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Mean of the tracked metric."),
									metric_stddev: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Standard deviation is set only for metric_type.NUMERIC metrics. Must be set for numeric metrics when available_n > 0.",
										),
									available_nonnull_n: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"The number of participants meeting the filtering criteria with a *non-null* value for this metric.",
										),
									available_n: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n.",
										),
								})
								.describe(
									"Defines a metric to measure in an experiment with its baseline stats.",
								),
							target_n: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"Minimum sample size needed to meet the design specs.",
								),
							sufficient_n: zod
								.boolean()
								.or(zod.null())
								.optional()
								.describe(
									"Whether or not there are enough available units to sample from to meet target_n.",
								),
							target_possible: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.",
								),
							pct_change_possible: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.",
								),
							msg: zod
								.object({
									type: zod
										.enum([
											"sufficient",
											"insufficient",
											"no baseline",
											"no available n",
											"zero effect size",
											"zero variation",
										])
										.describe("Classifies metric power analysis results."),
									msg: zod
										.string()
										.describe(
											"Main power analysis result stated in human-friendly English.",
										),
									source_msg: zod
										.string()
										.describe(
											"Power analysis result formatted as a template string with curly-braced {} named placeholders. Use with the dictionary of values to support localization of messages.",
										),
									values: zod
										.record(zod.string(), zod.number().or(zod.number()))
										.or(zod.null())
										.optional(),
								})
								.describe("Describes interpretation of power analysis results.")
								.or(zod.null())
								.optional()
								.describe("Human friendly message about the above results."),
						})
						.describe("Describes analysis results of a single metric."),
				)
				.max(createExperimentBodyPowerAnalysesAnalysesMax),
		})
		.or(zod.null())
		.optional(),
	webhooks: zod
		.array(zod.string())
		.default(createExperimentBodyWebhooksDefault)
		.describe(
			"List of webhook IDs to associate with this experiment. When the experiment is committed, these webhooks will be triggered with experiment details. Must contain unique values.",
		),
});

export const createExperimentResponseDesignSpecParticipantTypeMax = 100;
export const createExperimentResponseDesignSpecExperimentNameMax = 100;
export const createExperimentResponseDesignSpecDescriptionMax = 2000;
export const createExperimentResponseDesignSpecArmsItemArmNameMax = 100;
export const createExperimentResponseDesignSpecArmsItemArmDescriptionMaxOne = 2000;
export const createExperimentResponseDesignSpecArmsMin = 2;

export const createExperimentResponseDesignSpecArmsMax = 10;
export const createExperimentResponseDesignSpecStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponseDesignSpecStrataMax = 150;
export const createExperimentResponseDesignSpecMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponseDesignSpecMetricsMax = 150;
export const createExperimentResponseDesignSpecFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponseDesignSpecFiltersMax = 20;
export const createExperimentResponseDesignSpecPowerDefault = 0.8;
export const createExperimentResponseDesignSpecPowerMin = 0;

export const createExperimentResponseDesignSpecPowerMax = 1;
export const createExperimentResponseDesignSpecAlphaDefault = 0.05;
export const createExperimentResponseDesignSpecAlphaMin = 0;

export const createExperimentResponseDesignSpecAlphaMax = 1;
export const createExperimentResponseDesignSpecFstatThreshDefault = 0.6;
export const createExperimentResponseDesignSpecFstatThreshMin = 0;

export const createExperimentResponseDesignSpecFstatThreshMax = 1;
export const createExperimentResponseDesignSpecParticipantTypeMaxOne = 100;
export const createExperimentResponseDesignSpecExperimentNameMaxOne = 100;
export const createExperimentResponseDesignSpecDescriptionMaxOne = 2000;
export const createExperimentResponseDesignSpecArmsItemArmNameMaxOne = 100;
export const createExperimentResponseDesignSpecArmsItemArmDescriptionMaxFour = 2000;
export const createExperimentResponseDesignSpecArmsMinOne = 2;

export const createExperimentResponseDesignSpecArmsMaxOne = 10;
export const createExperimentResponseDesignSpecStrataItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponseDesignSpecStrataMaxOne = 150;
export const createExperimentResponseDesignSpecMetricsItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponseDesignSpecMetricsMaxOne = 150;
export const createExperimentResponseDesignSpecFiltersItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponseDesignSpecFiltersMaxOne = 20;
export const createExperimentResponseDesignSpecPowerDefaultOne = 0.8;
export const createExperimentResponseDesignSpecPowerMinOne = 0;

export const createExperimentResponseDesignSpecPowerMaxOne = 1;
export const createExperimentResponseDesignSpecAlphaDefaultOne = 0.05;
export const createExperimentResponseDesignSpecAlphaMinOne = 0;

export const createExperimentResponseDesignSpecAlphaMaxOne = 1;
export const createExperimentResponseDesignSpecFstatThreshDefaultOne = 0.6;
export const createExperimentResponseDesignSpecFstatThreshMinOne = 0;

export const createExperimentResponseDesignSpecFstatThreshMaxOne = 1;
export const createExperimentResponseDesignSpecParticipantTypeMaxTwo = 100;
export const createExperimentResponseDesignSpecExperimentNameMaxTwo = 100;
export const createExperimentResponseDesignSpecDescriptionMaxTwo = 2000;
export const createExperimentResponseDesignSpecArmsItemArmNameMaxTwo = 100;
export const createExperimentResponseDesignSpecArmsItemArmDescriptionMaxSeven = 2000;
export const createExperimentResponseDesignSpecArmsMinTwo = 2;

export const createExperimentResponseDesignSpecArmsMaxTwo = 10;
export const createExperimentResponseDesignSpecContextsItemContextNameMax = 100;
export const createExperimentResponseDesignSpecContextsItemContextDescriptionMaxOne = 2000;
export const createExperimentResponseDesignSpecContextsMaxOne = 150;
export const createExperimentResponseDesignSpecParticipantTypeMaxThree = 100;
export const createExperimentResponseDesignSpecExperimentNameMaxThree = 100;
export const createExperimentResponseDesignSpecDescriptionMaxThree = 2000;
export const createExperimentResponseDesignSpecArmsItemArmNameMaxThree = 100;
export const createExperimentResponseDesignSpecArmsItemArmDescriptionMaxOnezero = 2000;
export const createExperimentResponseDesignSpecArmsMinThree = 2;

export const createExperimentResponseDesignSpecArmsMaxThree = 10;
export const createExperimentResponseDesignSpecContextsItemContextNameMaxOne = 100;
export const createExperimentResponseDesignSpecContextsItemContextDescriptionMaxFour = 2000;
export const createExperimentResponseDesignSpecContextsMaxFour = 150;
export const createExperimentResponseDesignSpecParticipantTypeMaxFour = 100;
export const createExperimentResponseDesignSpecExperimentNameMaxFour = 100;
export const createExperimentResponseDesignSpecDescriptionMaxFour = 2000;
export const createExperimentResponseDesignSpecArmsItemArmNameMaxFour = 100;
export const createExperimentResponseDesignSpecArmsItemArmDescriptionMaxOnethree = 2000;
export const createExperimentResponseDesignSpecArmsMinFour = 2;

export const createExperimentResponseDesignSpecArmsMaxFour = 10;
export const createExperimentResponseDesignSpecContextsItemContextNameMaxTwo = 100;
export const createExperimentResponseDesignSpecContextsItemContextDescriptionMaxSeven = 2000;
export const createExperimentResponseDesignSpecContextsMaxSeven = 150;
export const createExperimentResponsePowerAnalysesAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponsePowerAnalysesAnalysesMax = 150;
export const createExperimentResponseAssignSummaryArmSizesItemArmArmNameMax = 100;
export const createExperimentResponseAssignSummaryArmSizesItemArmArmDescriptionMaxOne = 2000;
export const createExperimentResponseAssignSummaryArmSizesItemSizeDefault = 0;
export const createExperimentResponseAssignSummaryArmSizesMaxOne = 10;
export const createExperimentResponseWebhooksDefault = [];

export const createExperimentResponse = zod
	.object({
		datasource_id: zod.string(),
		state: zod
			.enum(["designing", "assigned", "abandoned", "committed", "aborted"])
			.describe(
				"Experiment lifecycle states.\n\nnote: [starting state], [[terminal state]]\n[DESIGNING]->[ASSIGNED]->{[[ABANDONED]], COMMITTED}->[[ABORTED]]",
			),
		stopped_assignments_at: zod
			.string()
			.datetime({})
			.or(zod.null())
			.describe(
				"The date and time assignments were stopped. Null if assignments are still allowed to be made.",
			),
		stopped_assignments_reason: zod
			.enum(["preassigned", "end_date", "manual", "target_n"])
			.describe("The reason assignments were stopped.")
			.or(zod.null())
			.describe(
				"The reason assignments were stopped. Null if assignments are still allowed to be made.",
			),
		design_spec: zod
			.discriminatedUnion("experiment_type", [
				zod
					.object({
						participant_type: zod
							.string()
							.max(createExperimentResponseDesignSpecParticipantTypeMax),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
							),
						experiment_type: zod.enum(["freq_preassigned"]),
						experiment_name: zod
							.string()
							.max(createExperimentResponseDesignSpecExperimentNameMax),
						description: zod
							.string()
							.max(createExperimentResponseDesignSpecDescriptionMax),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmNameMax,
											),
										arm_description: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmDescriptionMaxOne,
											)
											.or(zod.null())
											.optional(),
									})
									.describe("Describes an experiment treatment arm."),
							)
							.min(createExperimentResponseDesignSpecArmsMin)
							.max(createExperimentResponseDesignSpecArmsMax),
						strata: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												createExperimentResponseDesignSpecStrataItemFieldNameRegExp,
											),
									})
									.describe("Describes a variable used for stratification."),
							)
							.max(createExperimentResponseDesignSpecStrataMax)
							.describe(
								"Optional participant_type fields to use for stratified assignment.",
							),
						metrics: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												createExperimentResponseDesignSpecMetricsItemFieldNameRegExp,
											),
										metric_pct_change: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
											),
										metric_target: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
											),
									})
									.describe(
										"Defines a request to look up baseline stats for a metric to measure in an experiment.",
									),
							)
							.min(1)
							.max(createExperimentResponseDesignSpecMetricsMax)
							.describe("Primary and optional secondary metrics to target."),
						filters: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												createExperimentResponseDesignSpecFiltersItemFieldNameRegExp,
											),
										relation: zod
											.enum(["includes", "excludes", "between"])
											.describe(
												"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
											),
										value: zod
											.array(zod.number().or(zod.null()))
											.or(zod.array(zod.number().or(zod.null())))
											.or(zod.array(zod.string().or(zod.null())))
											.or(zod.array(zod.boolean().or(zod.null()))),
									})
									.describe(
										'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value       | logical Result                                    |\n|----------|-------------|---------------------------------------------------|\n| INCLUDES | [None]      | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |\n\nString comparisons are case-sensitive.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of datetime and timestamp values\n\nDATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
									),
							)
							.max(createExperimentResponseDesignSpecFiltersMax)
							.describe(
								"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
							),
						power: zod
							.number()
							.min(createExperimentResponseDesignSpecPowerMin)
							.max(createExperimentResponseDesignSpecPowerMax)
							.default(createExperimentResponseDesignSpecPowerDefault)
							.describe(
								"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
							),
						alpha: zod
							.number()
							.min(createExperimentResponseDesignSpecAlphaMin)
							.max(createExperimentResponseDesignSpecAlphaMax)
							.default(createExperimentResponseDesignSpecAlphaDefault)
							.describe(
								"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
							),
						fstat_thresh: zod
							.number()
							.min(createExperimentResponseDesignSpecFstatThreshMin)
							.max(createExperimentResponseDesignSpecFstatThreshMax)
							.default(createExperimentResponseDesignSpecFstatThreshDefault)
							.describe(
								'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
							),
					})
					.describe(
						"Use this type to randomly select and assign from existing participants at design time with frequentist A/B experiments.",
					),
				zod
					.object({
						participant_type: zod
							.string()
							.max(createExperimentResponseDesignSpecParticipantTypeMaxOne),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
							),
						experiment_type: zod.enum(["freq_online"]),
						experiment_name: zod
							.string()
							.max(createExperimentResponseDesignSpecExperimentNameMaxOne),
						description: zod
							.string()
							.max(createExperimentResponseDesignSpecDescriptionMaxOne),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmNameMaxOne,
											),
										arm_description: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmDescriptionMaxFour,
											)
											.or(zod.null())
											.optional(),
									})
									.describe("Describes an experiment treatment arm."),
							)
							.min(createExperimentResponseDesignSpecArmsMinOne)
							.max(createExperimentResponseDesignSpecArmsMaxOne),
						strata: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												createExperimentResponseDesignSpecStrataItemFieldNameRegExpOne,
											),
									})
									.describe("Describes a variable used for stratification."),
							)
							.max(createExperimentResponseDesignSpecStrataMaxOne)
							.describe(
								"Optional participant_type fields to use for stratified assignment.",
							),
						metrics: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												createExperimentResponseDesignSpecMetricsItemFieldNameRegExpOne,
											),
										metric_pct_change: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
											),
										metric_target: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
											),
									})
									.describe(
										"Defines a request to look up baseline stats for a metric to measure in an experiment.",
									),
							)
							.min(1)
							.max(createExperimentResponseDesignSpecMetricsMaxOne)
							.describe("Primary and optional secondary metrics to target."),
						filters: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												createExperimentResponseDesignSpecFiltersItemFieldNameRegExpOne,
											),
										relation: zod
											.enum(["includes", "excludes", "between"])
											.describe(
												"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
											),
										value: zod
											.array(zod.number().or(zod.null()))
											.or(zod.array(zod.number().or(zod.null())))
											.or(zod.array(zod.string().or(zod.null())))
											.or(zod.array(zod.boolean().or(zod.null()))),
									})
									.describe(
										'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value       | logical Result                                    |\n|----------|-------------|---------------------------------------------------|\n| INCLUDES | [None]      | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |\n\nString comparisons are case-sensitive.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of datetime and timestamp values\n\nDATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
									),
							)
							.max(createExperimentResponseDesignSpecFiltersMaxOne)
							.describe(
								"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
							),
						power: zod
							.number()
							.min(createExperimentResponseDesignSpecPowerMinOne)
							.max(createExperimentResponseDesignSpecPowerMaxOne)
							.default(createExperimentResponseDesignSpecPowerDefaultOne)
							.describe(
								"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
							),
						alpha: zod
							.number()
							.min(createExperimentResponseDesignSpecAlphaMinOne)
							.max(createExperimentResponseDesignSpecAlphaMaxOne)
							.default(createExperimentResponseDesignSpecAlphaDefaultOne)
							.describe(
								"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
							),
						fstat_thresh: zod
							.number()
							.min(createExperimentResponseDesignSpecFstatThreshMinOne)
							.max(createExperimentResponseDesignSpecFstatThreshMaxOne)
							.default(createExperimentResponseDesignSpecFstatThreshDefaultOne)
							.describe(
								'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
							),
					})
					.describe(
						"Use this type to randomly assign participants into arms during live experiment execution with frequentist A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
					),
				zod
					.object({
						participant_type: zod
							.string()
							.max(createExperimentResponseDesignSpecParticipantTypeMaxTwo),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
							),
						experiment_type: zod.enum(["mab_online"]),
						experiment_name: zod
							.string()
							.max(createExperimentResponseDesignSpecExperimentNameMaxTwo),
						description: zod
							.string()
							.max(createExperimentResponseDesignSpecDescriptionMaxTwo),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmNameMaxTwo,
											),
										arm_description: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmDescriptionMaxSeven,
											)
											.or(zod.null())
											.optional(),
										alpha_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial alpha parameter for Beta prior"),
										beta_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial beta parameter for Beta prior"),
										mu_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial mean parameter for Normal prior"),
										sigma_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Initial standard deviation parameter for Normal prior",
											),
										alpha: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated alpha parameter for Beta prior"),
										beta: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated beta parameter for Beta prior"),
										mu: zod
											.array(zod.number())
											.or(zod.null())
											.optional()
											.describe("Updated mean vector for Normal prior"),
										covariance: zod
											.array(zod.array(zod.number()))
											.or(zod.null())
											.optional()
											.describe("Updated covariance matrix for Normal prior"),
									})
									.describe(
										"Describes an experiment arm for bandit experiments.",
									),
							)
							.min(createExperimentResponseDesignSpecArmsMinTwo)
							.max(createExperimentResponseDesignSpecArmsMaxTwo),
						contexts: zod
							.array(
								zod
									.object({
										context_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"Unique identifier for the context, you should NOT set this when creating a new context.",
											),
										context_name: zod
											.string()
											.max(
												createExperimentResponseDesignSpecContextsItemContextNameMax,
											),
										context_description: zod
											.string()
											.max(
												createExperimentResponseDesignSpecContextsItemContextDescriptionMaxOne,
											)
											.or(zod.null())
											.optional(),
										value_type: zod
											.enum(["binary", "real-valued"])
											.optional()
											.describe("Enum for the type of context."),
									})
									.describe("Pydantic model for context of the experiment."),
							)
							.max(createExperimentResponseDesignSpecContextsMaxOne)
							.or(zod.null())
							.optional()
							.describe(
								"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
							),
						prior_type: zod
							.enum(["beta", "normal"])
							.optional()
							.describe("Enum for the prior distribution of the arm."),
						reward_type: zod
							.enum(["binary", "real-valued"])
							.optional()
							.describe("Enum for the likelihood distribution of the reward."),
					})
					.describe(
						"Use this type to randomly assign participants into arms during live experiment execution with MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
					),
				zod
					.object({
						participant_type: zod
							.string()
							.max(createExperimentResponseDesignSpecParticipantTypeMaxThree),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
							),
						experiment_type: zod.enum(["cmab_online"]),
						experiment_name: zod
							.string()
							.max(createExperimentResponseDesignSpecExperimentNameMaxThree),
						description: zod
							.string()
							.max(createExperimentResponseDesignSpecDescriptionMaxThree),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmNameMaxThree,
											),
										arm_description: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmDescriptionMaxOnezero,
											)
											.or(zod.null())
											.optional(),
										alpha_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial alpha parameter for Beta prior"),
										beta_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial beta parameter for Beta prior"),
										mu_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial mean parameter for Normal prior"),
										sigma_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Initial standard deviation parameter for Normal prior",
											),
										alpha: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated alpha parameter for Beta prior"),
										beta: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated beta parameter for Beta prior"),
										mu: zod
											.array(zod.number())
											.or(zod.null())
											.optional()
											.describe("Updated mean vector for Normal prior"),
										covariance: zod
											.array(zod.array(zod.number()))
											.or(zod.null())
											.optional()
											.describe("Updated covariance matrix for Normal prior"),
									})
									.describe(
										"Describes an experiment arm for bandit experiments.",
									),
							)
							.min(createExperimentResponseDesignSpecArmsMinThree)
							.max(createExperimentResponseDesignSpecArmsMaxThree),
						contexts: zod
							.array(
								zod
									.object({
										context_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"Unique identifier for the context, you should NOT set this when creating a new context.",
											),
										context_name: zod
											.string()
											.max(
												createExperimentResponseDesignSpecContextsItemContextNameMaxOne,
											),
										context_description: zod
											.string()
											.max(
												createExperimentResponseDesignSpecContextsItemContextDescriptionMaxFour,
											)
											.or(zod.null())
											.optional(),
										value_type: zod
											.enum(["binary", "real-valued"])
											.optional()
											.describe("Enum for the type of context."),
									})
									.describe("Pydantic model for context of the experiment."),
							)
							.max(createExperimentResponseDesignSpecContextsMaxFour)
							.or(zod.null())
							.optional()
							.describe(
								"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
							),
						prior_type: zod
							.enum(["beta", "normal"])
							.optional()
							.describe("Enum for the prior distribution of the arm."),
						reward_type: zod
							.enum(["binary", "real-valued"])
							.optional()
							.describe("Enum for the likelihood distribution of the reward."),
					})
					.describe(
						"Use this type to randomly assign participants into arms during live experiment execution with contextual MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
					),
				zod
					.object({
						participant_type: zod
							.string()
							.max(createExperimentResponseDesignSpecParticipantTypeMaxFour),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
							),
						experiment_type: zod.enum(["bayes_ab_online"]),
						experiment_name: zod
							.string()
							.max(createExperimentResponseDesignSpecExperimentNameMaxFour),
						description: zod
							.string()
							.max(createExperimentResponseDesignSpecDescriptionMaxFour),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmNameMaxFour,
											),
										arm_description: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmDescriptionMaxOnethree,
											)
											.or(zod.null())
											.optional(),
										alpha_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial alpha parameter for Beta prior"),
										beta_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial beta parameter for Beta prior"),
										mu_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial mean parameter for Normal prior"),
										sigma_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Initial standard deviation parameter for Normal prior",
											),
										alpha: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated alpha parameter for Beta prior"),
										beta: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated beta parameter for Beta prior"),
										mu: zod
											.array(zod.number())
											.or(zod.null())
											.optional()
											.describe("Updated mean vector for Normal prior"),
										covariance: zod
											.array(zod.array(zod.number()))
											.or(zod.null())
											.optional()
											.describe("Updated covariance matrix for Normal prior"),
									})
									.describe(
										"Describes an experiment arm for bandit experiments.",
									),
							)
							.min(createExperimentResponseDesignSpecArmsMinFour)
							.max(createExperimentResponseDesignSpecArmsMaxFour),
						contexts: zod
							.array(
								zod
									.object({
										context_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"Unique identifier for the context, you should NOT set this when creating a new context.",
											),
										context_name: zod
											.string()
											.max(
												createExperimentResponseDesignSpecContextsItemContextNameMaxTwo,
											),
										context_description: zod
											.string()
											.max(
												createExperimentResponseDesignSpecContextsItemContextDescriptionMaxSeven,
											)
											.or(zod.null())
											.optional(),
										value_type: zod
											.enum(["binary", "real-valued"])
											.optional()
											.describe("Enum for the type of context."),
									})
									.describe("Pydantic model for context of the experiment."),
							)
							.max(createExperimentResponseDesignSpecContextsMaxSeven)
							.or(zod.null())
							.optional()
							.describe(
								"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
							),
						prior_type: zod
							.enum(["beta", "normal"])
							.optional()
							.describe("Enum for the prior distribution of the arm."),
						reward_type: zod
							.enum(["binary", "real-valued"])
							.optional()
							.describe("Enum for the likelihood distribution of the reward."),
					})
					.describe(
						"Use this type to randomly assign participants into arms during live experiment execution with Bayesian A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
					),
			])
			.describe("The type of assignment and experiment design."),
		power_analyses: zod
			.object({
				analyses: zod
					.array(
						zod
							.object({
								metric_spec: zod
									.object({
										field_name: zod
											.string()
											.regex(
												createExperimentResponsePowerAnalysesAnalysesItemMetricSpecFieldNameRegExp,
											),
										metric_pct_change: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Percent change target relative to the metric_baseline.",
											),
										metric_target: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Absolute target value = metric_baseline*(1 + metric_pct_change)",
											),
										metric_type: zod
											.enum(["binary", "numeric"])
											.describe("Classifies metrics by their value type.")
											.or(zod.null())
											.optional()
											.describe("Inferred from dwh type."),
										metric_baseline: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Mean of the tracked metric."),
										metric_stddev: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Standard deviation is set only for metric_type.NUMERIC metrics. Must be set for numeric metrics when available_n > 0.",
											),
										available_nonnull_n: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"The number of participants meeting the filtering criteria with a *non-null* value for this metric.",
											),
										available_n: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n.",
											),
									})
									.describe(
										"Defines a metric to measure in an experiment with its baseline stats.",
									),
								target_n: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Minimum sample size needed to meet the design specs.",
									),
								sufficient_n: zod
									.boolean()
									.or(zod.null())
									.optional()
									.describe(
										"Whether or not there are enough available units to sample from to meet target_n.",
									),
								target_possible: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.",
									),
								pct_change_possible: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.",
									),
								msg: zod
									.object({
										type: zod
											.enum([
												"sufficient",
												"insufficient",
												"no baseline",
												"no available n",
												"zero effect size",
												"zero variation",
											])
											.describe("Classifies metric power analysis results."),
										msg: zod
											.string()
											.describe(
												"Main power analysis result stated in human-friendly English.",
											),
										source_msg: zod
											.string()
											.describe(
												"Power analysis result formatted as a template string with curly-braced {} named placeholders. Use with the dictionary of values to support localization of messages.",
											),
										values: zod
											.record(zod.string(), zod.number().or(zod.number()))
											.or(zod.null())
											.optional(),
									})
									.describe(
										"Describes interpretation of power analysis results.",
									)
									.or(zod.null())
									.optional()
									.describe("Human friendly message about the above results."),
							})
							.describe("Describes analysis results of a single metric."),
					)
					.max(createExperimentResponsePowerAnalysesAnalysesMax),
			})
			.or(zod.null()),
		assign_summary: zod
			.object({
				balance_check: zod
					.object({
						f_statistic: zod
							.number()
							.describe(
								"F-statistic testing the overall significance of the model predicting treatment assignment.",
							),
						numerator_df: zod
							.number()
							.describe(
								"The numerator degrees of freedom for the f-statistic related to number of dependent variables.",
							),
						denominator_df: zod
							.number()
							.describe(
								"Denominator degrees of freedom related to the number of observations.",
							),
						p_value: zod
							.number()
							.describe(
								"Probability of observing these data if strata do not predict treatment assignment, i.e. our randomization is balanced.",
							),
						balance_ok: zod
							.boolean()
							.describe(
								"Whether the p-value for our observed f_statistic is greater than the f-stat threshold specified in our design specification. (See DesignSpec.fstat_thresh)",
							),
					})
					.describe("Describes balance test results for treatment assignment.")
					.or(zod.null())
					.optional()
					.describe(
						"Balance test results if available. 'online' experiments do not have balance checks.",
					),
				sample_size: zod
					.number()
					.describe("The number of participants across all arms in total."),
				arm_sizes: zod
					.array(
						zod
							.object({
								arm: zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												createExperimentResponseAssignSummaryArmSizesItemArmArmNameMax,
											),
										arm_description: zod
											.string()
											.max(
												createExperimentResponseAssignSummaryArmSizesItemArmArmDescriptionMaxOne,
											)
											.or(zod.null())
											.optional(),
									})
									.describe("Describes an experiment treatment arm."),
								size: zod.number().optional(),
							})
							.describe(
								"Describes the number of participants assigned to each arm.",
							),
					)
					.max(createExperimentResponseAssignSummaryArmSizesMaxOne)
					.or(zod.null())
					.optional()
					.describe("For each arm, the number of participants assigned."),
			})
			.describe("Key pieces of an AssignResponse without the assignments.")
			.or(zod.null()),
		webhooks: zod
			.array(zod.string())
			.default(createExperimentResponseWebhooksDefault)
			.describe(
				"List of webhook IDs associated with this experiment. These webhooks are triggered when the experiment is committed.",
			),
	})
	.describe(
		"Same as the request but with ids filled for the experiment and arms, and summary info on the assignment.",
	);

/**
 * @summary Analyze Experiment
 */
export const analyzeExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const analyzeExperimentQueryParams = zod.object({
	baseline_arm_id: zod
		.string()
		.or(zod.null())
		.optional()
		.describe(
			"UUID of the baseline arm. If None, the first design spec arm is used.",
		),
});

export const analyzeExperimentResponseMetricAnalysesItemMetricFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const analyzeExperimentResponseMetricAnalysesItemArmAnalysesItemArmNameMax = 100;
export const analyzeExperimentResponseMetricAnalysesItemArmAnalysesItemArmDescriptionMaxOne = 2000;

export const analyzeExperimentResponse = zod
	.object({
		experiment_id: zod.string().describe("ID of the experiment."),
		metric_analyses: zod
			.array(
				zod
					.object({
						metric_name: zod.string().or(zod.null()).optional(),
						metric: zod
							.object({
								field_name: zod
									.string()
									.regex(
										analyzeExperimentResponseMetricAnalysesItemMetricFieldNameRegExp,
									),
								metric_pct_change: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
									),
								metric_target: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
									),
							})
							.describe(
								"Defines a request to look up baseline stats for a metric to measure in an experiment.",
							)
							.or(zod.null())
							.optional(),
						arm_analyses: zod
							.array(
								zod.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(
											analyzeExperimentResponseMetricAnalysesItemArmAnalysesItemArmNameMax,
										),
									arm_description: zod
										.string()
										.max(
											analyzeExperimentResponseMetricAnalysesItemArmAnalysesItemArmDescriptionMaxOne,
										)
										.or(zod.null())
										.optional(),
									estimate: zod
										.number()
										.describe(
											"The estimated treatment effect relative to the baseline arm.",
										),
									p_value: zod
										.number()
										.or(zod.null())
										.describe(
											"The p-value indicating statistical significance of the treatment effect. Value may be None if the t-stat is not available, e.g. due to inability to calculate the standard error.",
										),
									t_stat: zod
										.number()
										.or(zod.null())
										.describe(
											"The t-statistic from the statistical test. If the value is actually NaN, e.g. due to inability to calculate the standard error, we return None.",
										),
									std_error: zod
										.number()
										.describe(
											"The standard error of the treatment effect estimate.",
										),
									num_missing_values: zod
										.number()
										.describe(
											"The number of participants assigned to this arm with missing values (NaNs) for this metric. These rows are excluded from the analysis.",
										),
									is_baseline: zod
										.boolean()
										.describe(
											"Whether this arm is the baseline/control arm for comparison.",
										),
								}),
							)
							.describe(
								"The results of the analysis for each arm (coefficient) for this specific metric.",
							),
					})
					.describe(
						"Describes the change in a single metric for each arm of an experiment.",
					),
			)
			.describe("Contains one analysis per metric targeted by the experiment."),
		num_participants: zod
			.number()
			.describe(
				"The number of participants assigned to the experiment pulled from the dwh across all arms. Metric outcomes are not guaranteed to be present for all participants.",
			),
		num_missing_participants: zod
			.number()
			.or(zod.null())
			.optional()
			.describe(
				"The number of participants assigned to the experiment across all arms that are not found in the data warehouse when pulling metrics.",
			),
		created_at: zod
			.string()
			.datetime({})
			.describe("The date and time the experiment analysis was created."),
	})
	.describe("Describes the change if any in metrics targeted by an experiment.")
	.or(
		zod
			.object({
				experiment_id: zod.string().describe("ID of the experiment."),
				n_trials: zod
					.number()
					.describe("The number of trials conducted for this experiment."),
				n_outcomes: zod
					.number()
					.describe("The number of outcomes observed for this experiment."),
				posterior_means: zod
					.array(zod.number())
					.describe("Posterior means for each arm in the experiment."),
				posterior_stds: zod
					.array(zod.number())
					.describe(
						"Posterior standard deviations for each arm in the experiment.",
					),
				volumes: zod
					.array(zod.number())
					.describe("Volume of participants for each arm in the experiment."),
			})
			.describe("Describes changes in arms for a bandit experiment"),
	);

/**
 * @summary Commit Experiment
 */
export const commitExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const commitExperimentResponse = zod.any();

/**
 * @summary Abandon Experiment
 */
export const abandonExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const abandonExperimentResponse = zod.any();

/**
 * Returns a list of experiments in the organization.
 * @summary List Organization Experiments
 */
export const listOrganizationExperimentsParams = zod.object({
	organization_id: zod.string(),
});

export const listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMax = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMax = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMax = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMax = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxOne = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMin = 2;

export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMax = 10;
export const listOrganizationExperimentsResponseItemsItemDesignSpecStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listOrganizationExperimentsResponseItemsItemDesignSpecStrataMax = 150;
export const listOrganizationExperimentsResponseItemsItemDesignSpecMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listOrganizationExperimentsResponseItemsItemDesignSpecMetricsMax = 150;
export const listOrganizationExperimentsResponseItemsItemDesignSpecFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listOrganizationExperimentsResponseItemsItemDesignSpecFiltersMax = 20;
export const listOrganizationExperimentsResponseItemsItemDesignSpecPowerDefault = 0.8;
export const listOrganizationExperimentsResponseItemsItemDesignSpecPowerMin = 0;

export const listOrganizationExperimentsResponseItemsItemDesignSpecPowerMax = 1;
export const listOrganizationExperimentsResponseItemsItemDesignSpecAlphaDefault = 0.05;
export const listOrganizationExperimentsResponseItemsItemDesignSpecAlphaMin = 0;

export const listOrganizationExperimentsResponseItemsItemDesignSpecAlphaMax = 1;
export const listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshDefault = 0.6;
export const listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshMin = 0;

export const listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshMax = 1;
export const listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMaxOne = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMaxOne = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMaxOne = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxOne = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxFour = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMinOne = 2;

export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMaxOne = 10;
export const listOrganizationExperimentsResponseItemsItemDesignSpecStrataItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listOrganizationExperimentsResponseItemsItemDesignSpecStrataMaxOne = 150;
export const listOrganizationExperimentsResponseItemsItemDesignSpecMetricsItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listOrganizationExperimentsResponseItemsItemDesignSpecMetricsMaxOne = 150;
export const listOrganizationExperimentsResponseItemsItemDesignSpecFiltersItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listOrganizationExperimentsResponseItemsItemDesignSpecFiltersMaxOne = 20;
export const listOrganizationExperimentsResponseItemsItemDesignSpecPowerDefaultOne = 0.8;
export const listOrganizationExperimentsResponseItemsItemDesignSpecPowerMinOne = 0;

export const listOrganizationExperimentsResponseItemsItemDesignSpecPowerMaxOne = 1;
export const listOrganizationExperimentsResponseItemsItemDesignSpecAlphaDefaultOne = 0.05;
export const listOrganizationExperimentsResponseItemsItemDesignSpecAlphaMinOne = 0;

export const listOrganizationExperimentsResponseItemsItemDesignSpecAlphaMaxOne = 1;
export const listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshDefaultOne = 0.6;
export const listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshMinOne = 0;

export const listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshMaxOne = 1;
export const listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMaxTwo = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMaxTwo = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMaxTwo = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxTwo = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxSeven = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMinTwo = 2;

export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMaxTwo = 10;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextNameMax = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextDescriptionMaxOne = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsMaxOne = 150;
export const listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMaxThree = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMaxThree = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMaxThree = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxThree = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxOnezero = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMinThree = 2;

export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMaxThree = 10;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextNameMaxOne = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextDescriptionMaxFour = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsMaxFour = 150;
export const listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMaxFour = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMaxFour = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMaxFour = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxFour = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxOnethree = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMinFour = 2;

export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMaxFour = 10;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextNameMaxTwo = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextDescriptionMaxSeven = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsMaxSeven = 150;
export const listOrganizationExperimentsResponseItemsItemPowerAnalysesAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listOrganizationExperimentsResponseItemsItemPowerAnalysesAnalysesMax = 150;
export const listOrganizationExperimentsResponseItemsItemAssignSummaryArmSizesItemArmArmNameMax = 100;
export const listOrganizationExperimentsResponseItemsItemAssignSummaryArmSizesItemArmArmDescriptionMaxOne = 2000;
export const listOrganizationExperimentsResponseItemsItemAssignSummaryArmSizesItemSizeDefault = 0;
export const listOrganizationExperimentsResponseItemsItemAssignSummaryArmSizesMaxOne = 10;
export const listOrganizationExperimentsResponseItemsItemWebhooksDefault = [];

export const listOrganizationExperimentsResponse = zod.object({
	items: zod.array(
		zod
			.object({
				datasource_id: zod.string(),
				state: zod
					.enum(["designing", "assigned", "abandoned", "committed", "aborted"])
					.describe(
						"Experiment lifecycle states.\n\nnote: [starting state], [[terminal state]]\n[DESIGNING]->[ASSIGNED]->{[[ABANDONED]], COMMITTED}->[[ABORTED]]",
					),
				stopped_assignments_at: zod
					.string()
					.datetime({})
					.or(zod.null())
					.describe(
						"The date and time assignments were stopped. Null if assignments are still allowed to be made.",
					),
				stopped_assignments_reason: zod
					.enum(["preassigned", "end_date", "manual", "target_n"])
					.describe("The reason assignments were stopped.")
					.or(zod.null())
					.describe(
						"The reason assignments were stopped. Null if assignments are still allowed to be made.",
					),
				design_spec: zod
					.discriminatedUnion("experiment_type", [
						zod
							.object({
								participant_type: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMax,
									),
								experiment_id: zod
									.string()
									.or(zod.null())
									.optional()
									.describe(
										"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
									),
								experiment_type: zod.enum(["freq_preassigned"]),
								experiment_name: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMax,
									),
								description: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMax,
									),
								start_date: zod.string().datetime({}),
								end_date: zod.string().datetime({}),
								arms: zod
									.array(
										zod
											.object({
												arm_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
													),
												arm_name: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMax,
													),
												arm_description: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxOne,
													)
													.or(zod.null())
													.optional(),
											})
											.describe("Describes an experiment treatment arm."),
									)
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMin,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMax,
									),
								strata: zod
									.array(
										zod
											.object({
												field_name: zod
													.string()
													.regex(
														listOrganizationExperimentsResponseItemsItemDesignSpecStrataItemFieldNameRegExp,
													),
											})
											.describe(
												"Describes a variable used for stratification.",
											),
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecStrataMax,
									)
									.describe(
										"Optional participant_type fields to use for stratified assignment.",
									),
								metrics: zod
									.array(
										zod
											.object({
												field_name: zod
													.string()
													.regex(
														listOrganizationExperimentsResponseItemsItemDesignSpecMetricsItemFieldNameRegExp,
													),
												metric_pct_change: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
													),
												metric_target: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
													),
											})
											.describe(
												"Defines a request to look up baseline stats for a metric to measure in an experiment.",
											),
									)
									.min(1)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecMetricsMax,
									)
									.describe(
										"Primary and optional secondary metrics to target.",
									),
								filters: zod
									.array(
										zod
											.object({
												field_name: zod
													.string()
													.regex(
														listOrganizationExperimentsResponseItemsItemDesignSpecFiltersItemFieldNameRegExp,
													),
												relation: zod
													.enum(["includes", "excludes", "between"])
													.describe(
														"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
													),
												value: zod
													.array(zod.number().or(zod.null()))
													.or(zod.array(zod.number().or(zod.null())))
													.or(zod.array(zod.string().or(zod.null())))
													.or(zod.array(zod.boolean().or(zod.null()))),
											})
											.describe(
												'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value       | logical Result                                    |\n|----------|-------------|---------------------------------------------------|\n| INCLUDES | [None]      | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |\n\nString comparisons are case-sensitive.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of datetime and timestamp values\n\nDATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
											),
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecFiltersMax,
									)
									.describe(
										"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
									),
								power: zod
									.number()
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecPowerMin,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecPowerMax,
									)
									.default(
										listOrganizationExperimentsResponseItemsItemDesignSpecPowerDefault,
									)
									.describe(
										"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
									),
								alpha: zod
									.number()
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecAlphaMin,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecAlphaMax,
									)
									.default(
										listOrganizationExperimentsResponseItemsItemDesignSpecAlphaDefault,
									)
									.describe(
										"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
									),
								fstat_thresh: zod
									.number()
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshMin,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshMax,
									)
									.default(
										listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshDefault,
									)
									.describe(
										'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
									),
							})
							.describe(
								"Use this type to randomly select and assign from existing participants at design time with frequentist A/B experiments.",
							),
						zod
							.object({
								participant_type: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMaxOne,
									),
								experiment_id: zod
									.string()
									.or(zod.null())
									.optional()
									.describe(
										"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
									),
								experiment_type: zod.enum(["freq_online"]),
								experiment_name: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMaxOne,
									),
								description: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMaxOne,
									),
								start_date: zod.string().datetime({}),
								end_date: zod.string().datetime({}),
								arms: zod
									.array(
										zod
											.object({
												arm_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
													),
												arm_name: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxOne,
													),
												arm_description: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxFour,
													)
													.or(zod.null())
													.optional(),
											})
											.describe("Describes an experiment treatment arm."),
									)
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMinOne,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMaxOne,
									),
								strata: zod
									.array(
										zod
											.object({
												field_name: zod
													.string()
													.regex(
														listOrganizationExperimentsResponseItemsItemDesignSpecStrataItemFieldNameRegExpOne,
													),
											})
											.describe(
												"Describes a variable used for stratification.",
											),
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecStrataMaxOne,
									)
									.describe(
										"Optional participant_type fields to use for stratified assignment.",
									),
								metrics: zod
									.array(
										zod
											.object({
												field_name: zod
													.string()
													.regex(
														listOrganizationExperimentsResponseItemsItemDesignSpecMetricsItemFieldNameRegExpOne,
													),
												metric_pct_change: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
													),
												metric_target: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
													),
											})
											.describe(
												"Defines a request to look up baseline stats for a metric to measure in an experiment.",
											),
									)
									.min(1)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecMetricsMaxOne,
									)
									.describe(
										"Primary and optional secondary metrics to target.",
									),
								filters: zod
									.array(
										zod
											.object({
												field_name: zod
													.string()
													.regex(
														listOrganizationExperimentsResponseItemsItemDesignSpecFiltersItemFieldNameRegExpOne,
													),
												relation: zod
													.enum(["includes", "excludes", "between"])
													.describe(
														"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
													),
												value: zod
													.array(zod.number().or(zod.null()))
													.or(zod.array(zod.number().or(zod.null())))
													.or(zod.array(zod.string().or(zod.null())))
													.or(zod.array(zod.boolean().or(zod.null()))),
											})
											.describe(
												'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value       | logical Result                                    |\n|----------|-------------|---------------------------------------------------|\n| INCLUDES | [None]      | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |\n\nString comparisons are case-sensitive.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of datetime and timestamp values\n\nDATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
											),
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecFiltersMaxOne,
									)
									.describe(
										"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
									),
								power: zod
									.number()
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecPowerMinOne,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecPowerMaxOne,
									)
									.default(
										listOrganizationExperimentsResponseItemsItemDesignSpecPowerDefaultOne,
									)
									.describe(
										"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
									),
								alpha: zod
									.number()
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecAlphaMinOne,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecAlphaMaxOne,
									)
									.default(
										listOrganizationExperimentsResponseItemsItemDesignSpecAlphaDefaultOne,
									)
									.describe(
										"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
									),
								fstat_thresh: zod
									.number()
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshMinOne,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshMaxOne,
									)
									.default(
										listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshDefaultOne,
									)
									.describe(
										'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
									),
							})
							.describe(
								"Use this type to randomly assign participants into arms during live experiment execution with frequentist A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
							),
						zod
							.object({
								participant_type: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMaxTwo,
									),
								experiment_id: zod
									.string()
									.or(zod.null())
									.optional()
									.describe(
										"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
									),
								experiment_type: zod.enum(["mab_online"]),
								experiment_name: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMaxTwo,
									),
								description: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMaxTwo,
									),
								start_date: zod.string().datetime({}),
								end_date: zod.string().datetime({}),
								arms: zod
									.array(
										zod
											.object({
												arm_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
													),
												arm_name: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxTwo,
													),
												arm_description: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxSeven,
													)
													.or(zod.null())
													.optional(),
												alpha_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial alpha parameter for Beta prior"),
												beta_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial beta parameter for Beta prior"),
												mu_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial mean parameter for Normal prior"),
												sigma_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Initial standard deviation parameter for Normal prior",
													),
												alpha: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Updated alpha parameter for Beta prior"),
												beta: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Updated beta parameter for Beta prior"),
												mu: zod
													.array(zod.number())
													.or(zod.null())
													.optional()
													.describe("Updated mean vector for Normal prior"),
												covariance: zod
													.array(zod.array(zod.number()))
													.or(zod.null())
													.optional()
													.describe(
														"Updated covariance matrix for Normal prior",
													),
											})
											.describe(
												"Describes an experiment arm for bandit experiments.",
											),
									)
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMinTwo,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMaxTwo,
									),
								contexts: zod
									.array(
										zod
											.object({
												context_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"Unique identifier for the context, you should NOT set this when creating a new context.",
													),
												context_name: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextNameMax,
													),
												context_description: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextDescriptionMaxOne,
													)
													.or(zod.null())
													.optional(),
												value_type: zod
													.enum(["binary", "real-valued"])
													.optional()
													.describe("Enum for the type of context."),
											})
											.describe(
												"Pydantic model for context of the experiment.",
											),
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecContextsMaxOne,
									)
									.or(zod.null())
									.optional()
									.describe(
										"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
									),
								prior_type: zod
									.enum(["beta", "normal"])
									.optional()
									.describe("Enum for the prior distribution of the arm."),
								reward_type: zod
									.enum(["binary", "real-valued"])
									.optional()
									.describe(
										"Enum for the likelihood distribution of the reward.",
									),
							})
							.describe(
								"Use this type to randomly assign participants into arms during live experiment execution with MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
							),
						zod
							.object({
								participant_type: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMaxThree,
									),
								experiment_id: zod
									.string()
									.or(zod.null())
									.optional()
									.describe(
										"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
									),
								experiment_type: zod.enum(["cmab_online"]),
								experiment_name: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMaxThree,
									),
								description: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMaxThree,
									),
								start_date: zod.string().datetime({}),
								end_date: zod.string().datetime({}),
								arms: zod
									.array(
										zod
											.object({
												arm_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
													),
												arm_name: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxThree,
													),
												arm_description: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxOnezero,
													)
													.or(zod.null())
													.optional(),
												alpha_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial alpha parameter for Beta prior"),
												beta_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial beta parameter for Beta prior"),
												mu_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial mean parameter for Normal prior"),
												sigma_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Initial standard deviation parameter for Normal prior",
													),
												alpha: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Updated alpha parameter for Beta prior"),
												beta: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Updated beta parameter for Beta prior"),
												mu: zod
													.array(zod.number())
													.or(zod.null())
													.optional()
													.describe("Updated mean vector for Normal prior"),
												covariance: zod
													.array(zod.array(zod.number()))
													.or(zod.null())
													.optional()
													.describe(
														"Updated covariance matrix for Normal prior",
													),
											})
											.describe(
												"Describes an experiment arm for bandit experiments.",
											),
									)
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMinThree,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMaxThree,
									),
								contexts: zod
									.array(
										zod
											.object({
												context_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"Unique identifier for the context, you should NOT set this when creating a new context.",
													),
												context_name: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextNameMaxOne,
													),
												context_description: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextDescriptionMaxFour,
													)
													.or(zod.null())
													.optional(),
												value_type: zod
													.enum(["binary", "real-valued"])
													.optional()
													.describe("Enum for the type of context."),
											})
											.describe(
												"Pydantic model for context of the experiment.",
											),
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecContextsMaxFour,
									)
									.or(zod.null())
									.optional()
									.describe(
										"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
									),
								prior_type: zod
									.enum(["beta", "normal"])
									.optional()
									.describe("Enum for the prior distribution of the arm."),
								reward_type: zod
									.enum(["binary", "real-valued"])
									.optional()
									.describe(
										"Enum for the likelihood distribution of the reward.",
									),
							})
							.describe(
								"Use this type to randomly assign participants into arms during live experiment execution with contextual MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
							),
						zod
							.object({
								participant_type: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMaxFour,
									),
								experiment_id: zod
									.string()
									.or(zod.null())
									.optional()
									.describe(
										"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
									),
								experiment_type: zod.enum(["bayes_ab_online"]),
								experiment_name: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMaxFour,
									),
								description: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMaxFour,
									),
								start_date: zod.string().datetime({}),
								end_date: zod.string().datetime({}),
								arms: zod
									.array(
										zod
											.object({
												arm_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
													),
												arm_name: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxFour,
													),
												arm_description: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxOnethree,
													)
													.or(zod.null())
													.optional(),
												alpha_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial alpha parameter for Beta prior"),
												beta_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial beta parameter for Beta prior"),
												mu_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial mean parameter for Normal prior"),
												sigma_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Initial standard deviation parameter for Normal prior",
													),
												alpha: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Updated alpha parameter for Beta prior"),
												beta: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Updated beta parameter for Beta prior"),
												mu: zod
													.array(zod.number())
													.or(zod.null())
													.optional()
													.describe("Updated mean vector for Normal prior"),
												covariance: zod
													.array(zod.array(zod.number()))
													.or(zod.null())
													.optional()
													.describe(
														"Updated covariance matrix for Normal prior",
													),
											})
											.describe(
												"Describes an experiment arm for bandit experiments.",
											),
									)
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMinFour,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMaxFour,
									),
								contexts: zod
									.array(
										zod
											.object({
												context_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"Unique identifier for the context, you should NOT set this when creating a new context.",
													),
												context_name: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextNameMaxTwo,
													),
												context_description: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextDescriptionMaxSeven,
													)
													.or(zod.null())
													.optional(),
												value_type: zod
													.enum(["binary", "real-valued"])
													.optional()
													.describe("Enum for the type of context."),
											})
											.describe(
												"Pydantic model for context of the experiment.",
											),
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecContextsMaxSeven,
									)
									.or(zod.null())
									.optional()
									.describe(
										"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
									),
								prior_type: zod
									.enum(["beta", "normal"])
									.optional()
									.describe("Enum for the prior distribution of the arm."),
								reward_type: zod
									.enum(["binary", "real-valued"])
									.optional()
									.describe(
										"Enum for the likelihood distribution of the reward.",
									),
							})
							.describe(
								"Use this type to randomly assign participants into arms during live experiment execution with Bayesian A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
							),
					])
					.describe("The type of assignment and experiment design."),
				power_analyses: zod
					.object({
						analyses: zod
							.array(
								zod
									.object({
										metric_spec: zod
											.object({
												field_name: zod
													.string()
													.regex(
														listOrganizationExperimentsResponseItemsItemPowerAnalysesAnalysesItemMetricSpecFieldNameRegExp,
													),
												metric_pct_change: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Percent change target relative to the metric_baseline.",
													),
												metric_target: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Absolute target value = metric_baseline*(1 + metric_pct_change)",
													),
												metric_type: zod
													.enum(["binary", "numeric"])
													.describe("Classifies metrics by their value type.")
													.or(zod.null())
													.optional()
													.describe("Inferred from dwh type."),
												metric_baseline: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Mean of the tracked metric."),
												metric_stddev: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Standard deviation is set only for metric_type.NUMERIC metrics. Must be set for numeric metrics when available_n > 0.",
													),
												available_nonnull_n: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"The number of participants meeting the filtering criteria with a *non-null* value for this metric.",
													),
												available_n: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n.",
													),
											})
											.describe(
												"Defines a metric to measure in an experiment with its baseline stats.",
											),
										target_n: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Minimum sample size needed to meet the design specs.",
											),
										sufficient_n: zod
											.boolean()
											.or(zod.null())
											.optional()
											.describe(
												"Whether or not there are enough available units to sample from to meet target_n.",
											),
										target_possible: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.",
											),
										pct_change_possible: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.",
											),
										msg: zod
											.object({
												type: zod
													.enum([
														"sufficient",
														"insufficient",
														"no baseline",
														"no available n",
														"zero effect size",
														"zero variation",
													])
													.describe(
														"Classifies metric power analysis results.",
													),
												msg: zod
													.string()
													.describe(
														"Main power analysis result stated in human-friendly English.",
													),
												source_msg: zod
													.string()
													.describe(
														"Power analysis result formatted as a template string with curly-braced {} named placeholders. Use with the dictionary of values to support localization of messages.",
													),
												values: zod
													.record(zod.string(), zod.number().or(zod.number()))
													.or(zod.null())
													.optional(),
											})
											.describe(
												"Describes interpretation of power analysis results.",
											)
											.or(zod.null())
											.optional()
											.describe(
												"Human friendly message about the above results.",
											),
									})
									.describe("Describes analysis results of a single metric."),
							)
							.max(
								listOrganizationExperimentsResponseItemsItemPowerAnalysesAnalysesMax,
							),
					})
					.or(zod.null()),
				assign_summary: zod
					.object({
						balance_check: zod
							.object({
								f_statistic: zod
									.number()
									.describe(
										"F-statistic testing the overall significance of the model predicting treatment assignment.",
									),
								numerator_df: zod
									.number()
									.describe(
										"The numerator degrees of freedom for the f-statistic related to number of dependent variables.",
									),
								denominator_df: zod
									.number()
									.describe(
										"Denominator degrees of freedom related to the number of observations.",
									),
								p_value: zod
									.number()
									.describe(
										"Probability of observing these data if strata do not predict treatment assignment, i.e. our randomization is balanced.",
									),
								balance_ok: zod
									.boolean()
									.describe(
										"Whether the p-value for our observed f_statistic is greater than the f-stat threshold specified in our design specification. (See DesignSpec.fstat_thresh)",
									),
							})
							.describe(
								"Describes balance test results for treatment assignment.",
							)
							.or(zod.null())
							.optional()
							.describe(
								"Balance test results if available. 'online' experiments do not have balance checks.",
							),
						sample_size: zod
							.number()
							.describe("The number of participants across all arms in total."),
						arm_sizes: zod
							.array(
								zod
									.object({
										arm: zod
											.object({
												arm_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
													),
												arm_name: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemAssignSummaryArmSizesItemArmArmNameMax,
													),
												arm_description: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemAssignSummaryArmSizesItemArmArmDescriptionMaxOne,
													)
													.or(zod.null())
													.optional(),
											})
											.describe("Describes an experiment treatment arm."),
										size: zod.number().optional(),
									})
									.describe(
										"Describes the number of participants assigned to each arm.",
									),
							)
							.max(
								listOrganizationExperimentsResponseItemsItemAssignSummaryArmSizesMaxOne,
							)
							.or(zod.null())
							.optional()
							.describe("For each arm, the number of participants assigned."),
					})
					.describe("Key pieces of an AssignResponse without the assignments.")
					.or(zod.null()),
				webhooks: zod
					.array(zod.string())
					.default(listOrganizationExperimentsResponseItemsItemWebhooksDefault)
					.describe(
						"List of webhook IDs associated with this experiment. These webhooks are triggered when the experiment is committed.",
					),
			})
			.describe("Representation of our stored Experiment information."),
	),
});

/**
 * Returns the experiment with the specified ID.
 * @summary Get Experiment
 */
export const getExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const getExperimentResponseDesignSpecParticipantTypeMax = 100;
export const getExperimentResponseDesignSpecExperimentNameMax = 100;
export const getExperimentResponseDesignSpecDescriptionMax = 2000;
export const getExperimentResponseDesignSpecArmsItemArmNameMax = 100;
export const getExperimentResponseDesignSpecArmsItemArmDescriptionMaxOne = 2000;
export const getExperimentResponseDesignSpecArmsMin = 2;

export const getExperimentResponseDesignSpecArmsMax = 10;
export const getExperimentResponseDesignSpecStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentResponseDesignSpecStrataMax = 150;
export const getExperimentResponseDesignSpecMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentResponseDesignSpecMetricsMax = 150;
export const getExperimentResponseDesignSpecFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentResponseDesignSpecFiltersMax = 20;
export const getExperimentResponseDesignSpecPowerDefault = 0.8;
export const getExperimentResponseDesignSpecPowerMin = 0;

export const getExperimentResponseDesignSpecPowerMax = 1;
export const getExperimentResponseDesignSpecAlphaDefault = 0.05;
export const getExperimentResponseDesignSpecAlphaMin = 0;

export const getExperimentResponseDesignSpecAlphaMax = 1;
export const getExperimentResponseDesignSpecFstatThreshDefault = 0.6;
export const getExperimentResponseDesignSpecFstatThreshMin = 0;

export const getExperimentResponseDesignSpecFstatThreshMax = 1;
export const getExperimentResponseDesignSpecParticipantTypeMaxOne = 100;
export const getExperimentResponseDesignSpecExperimentNameMaxOne = 100;
export const getExperimentResponseDesignSpecDescriptionMaxOne = 2000;
export const getExperimentResponseDesignSpecArmsItemArmNameMaxOne = 100;
export const getExperimentResponseDesignSpecArmsItemArmDescriptionMaxFour = 2000;
export const getExperimentResponseDesignSpecArmsMinOne = 2;

export const getExperimentResponseDesignSpecArmsMaxOne = 10;
export const getExperimentResponseDesignSpecStrataItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentResponseDesignSpecStrataMaxOne = 150;
export const getExperimentResponseDesignSpecMetricsItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentResponseDesignSpecMetricsMaxOne = 150;
export const getExperimentResponseDesignSpecFiltersItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentResponseDesignSpecFiltersMaxOne = 20;
export const getExperimentResponseDesignSpecPowerDefaultOne = 0.8;
export const getExperimentResponseDesignSpecPowerMinOne = 0;

export const getExperimentResponseDesignSpecPowerMaxOne = 1;
export const getExperimentResponseDesignSpecAlphaDefaultOne = 0.05;
export const getExperimentResponseDesignSpecAlphaMinOne = 0;

export const getExperimentResponseDesignSpecAlphaMaxOne = 1;
export const getExperimentResponseDesignSpecFstatThreshDefaultOne = 0.6;
export const getExperimentResponseDesignSpecFstatThreshMinOne = 0;

export const getExperimentResponseDesignSpecFstatThreshMaxOne = 1;
export const getExperimentResponseDesignSpecParticipantTypeMaxTwo = 100;
export const getExperimentResponseDesignSpecExperimentNameMaxTwo = 100;
export const getExperimentResponseDesignSpecDescriptionMaxTwo = 2000;
export const getExperimentResponseDesignSpecArmsItemArmNameMaxTwo = 100;
export const getExperimentResponseDesignSpecArmsItemArmDescriptionMaxSeven = 2000;
export const getExperimentResponseDesignSpecArmsMinTwo = 2;

export const getExperimentResponseDesignSpecArmsMaxTwo = 10;
export const getExperimentResponseDesignSpecContextsItemContextNameMax = 100;
export const getExperimentResponseDesignSpecContextsItemContextDescriptionMaxOne = 2000;
export const getExperimentResponseDesignSpecContextsMaxOne = 150;
export const getExperimentResponseDesignSpecParticipantTypeMaxThree = 100;
export const getExperimentResponseDesignSpecExperimentNameMaxThree = 100;
export const getExperimentResponseDesignSpecDescriptionMaxThree = 2000;
export const getExperimentResponseDesignSpecArmsItemArmNameMaxThree = 100;
export const getExperimentResponseDesignSpecArmsItemArmDescriptionMaxOnezero = 2000;
export const getExperimentResponseDesignSpecArmsMinThree = 2;

export const getExperimentResponseDesignSpecArmsMaxThree = 10;
export const getExperimentResponseDesignSpecContextsItemContextNameMaxOne = 100;
export const getExperimentResponseDesignSpecContextsItemContextDescriptionMaxFour = 2000;
export const getExperimentResponseDesignSpecContextsMaxFour = 150;
export const getExperimentResponseDesignSpecParticipantTypeMaxFour = 100;
export const getExperimentResponseDesignSpecExperimentNameMaxFour = 100;
export const getExperimentResponseDesignSpecDescriptionMaxFour = 2000;
export const getExperimentResponseDesignSpecArmsItemArmNameMaxFour = 100;
export const getExperimentResponseDesignSpecArmsItemArmDescriptionMaxOnethree = 2000;
export const getExperimentResponseDesignSpecArmsMinFour = 2;

export const getExperimentResponseDesignSpecArmsMaxFour = 10;
export const getExperimentResponseDesignSpecContextsItemContextNameMaxTwo = 100;
export const getExperimentResponseDesignSpecContextsItemContextDescriptionMaxSeven = 2000;
export const getExperimentResponseDesignSpecContextsMaxSeven = 150;
export const getExperimentResponsePowerAnalysesAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentResponsePowerAnalysesAnalysesMax = 150;
export const getExperimentResponseAssignSummaryArmSizesItemArmArmNameMax = 100;
export const getExperimentResponseAssignSummaryArmSizesItemArmArmDescriptionMaxOne = 2000;
export const getExperimentResponseAssignSummaryArmSizesItemSizeDefault = 0;
export const getExperimentResponseAssignSummaryArmSizesMaxOne = 10;
export const getExperimentResponseWebhooksDefault = [];

export const getExperimentResponse = zod
	.object({
		datasource_id: zod.string(),
		state: zod
			.enum(["designing", "assigned", "abandoned", "committed", "aborted"])
			.describe(
				"Experiment lifecycle states.\n\nnote: [starting state], [[terminal state]]\n[DESIGNING]->[ASSIGNED]->{[[ABANDONED]], COMMITTED}->[[ABORTED]]",
			),
		stopped_assignments_at: zod
			.string()
			.datetime({})
			.or(zod.null())
			.describe(
				"The date and time assignments were stopped. Null if assignments are still allowed to be made.",
			),
		stopped_assignments_reason: zod
			.enum(["preassigned", "end_date", "manual", "target_n"])
			.describe("The reason assignments were stopped.")
			.or(zod.null())
			.describe(
				"The reason assignments were stopped. Null if assignments are still allowed to be made.",
			),
		design_spec: zod
			.discriminatedUnion("experiment_type", [
				zod
					.object({
						participant_type: zod
							.string()
							.max(getExperimentResponseDesignSpecParticipantTypeMax),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
							),
						experiment_type: zod.enum(["freq_preassigned"]),
						experiment_name: zod
							.string()
							.max(getExperimentResponseDesignSpecExperimentNameMax),
						description: zod
							.string()
							.max(getExperimentResponseDesignSpecDescriptionMax),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(getExperimentResponseDesignSpecArmsItemArmNameMax),
										arm_description: zod
											.string()
											.max(
												getExperimentResponseDesignSpecArmsItemArmDescriptionMaxOne,
											)
											.or(zod.null())
											.optional(),
									})
									.describe("Describes an experiment treatment arm."),
							)
							.min(getExperimentResponseDesignSpecArmsMin)
							.max(getExperimentResponseDesignSpecArmsMax),
						strata: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												getExperimentResponseDesignSpecStrataItemFieldNameRegExp,
											),
									})
									.describe("Describes a variable used for stratification."),
							)
							.max(getExperimentResponseDesignSpecStrataMax)
							.describe(
								"Optional participant_type fields to use for stratified assignment.",
							),
						metrics: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												getExperimentResponseDesignSpecMetricsItemFieldNameRegExp,
											),
										metric_pct_change: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
											),
										metric_target: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
											),
									})
									.describe(
										"Defines a request to look up baseline stats for a metric to measure in an experiment.",
									),
							)
							.min(1)
							.max(getExperimentResponseDesignSpecMetricsMax)
							.describe("Primary and optional secondary metrics to target."),
						filters: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												getExperimentResponseDesignSpecFiltersItemFieldNameRegExp,
											),
										relation: zod
											.enum(["includes", "excludes", "between"])
											.describe(
												"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
											),
										value: zod
											.array(zod.number().or(zod.null()))
											.or(zod.array(zod.number().or(zod.null())))
											.or(zod.array(zod.string().or(zod.null())))
											.or(zod.array(zod.boolean().or(zod.null()))),
									})
									.describe(
										'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value       | logical Result                                    |\n|----------|-------------|---------------------------------------------------|\n| INCLUDES | [None]      | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |\n\nString comparisons are case-sensitive.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of datetime and timestamp values\n\nDATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
									),
							)
							.max(getExperimentResponseDesignSpecFiltersMax)
							.describe(
								"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
							),
						power: zod
							.number()
							.min(getExperimentResponseDesignSpecPowerMin)
							.max(getExperimentResponseDesignSpecPowerMax)
							.default(getExperimentResponseDesignSpecPowerDefault)
							.describe(
								"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
							),
						alpha: zod
							.number()
							.min(getExperimentResponseDesignSpecAlphaMin)
							.max(getExperimentResponseDesignSpecAlphaMax)
							.default(getExperimentResponseDesignSpecAlphaDefault)
							.describe(
								"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
							),
						fstat_thresh: zod
							.number()
							.min(getExperimentResponseDesignSpecFstatThreshMin)
							.max(getExperimentResponseDesignSpecFstatThreshMax)
							.default(getExperimentResponseDesignSpecFstatThreshDefault)
							.describe(
								'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
							),
					})
					.describe(
						"Use this type to randomly select and assign from existing participants at design time with frequentist A/B experiments.",
					),
				zod
					.object({
						participant_type: zod
							.string()
							.max(getExperimentResponseDesignSpecParticipantTypeMaxOne),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
							),
						experiment_type: zod.enum(["freq_online"]),
						experiment_name: zod
							.string()
							.max(getExperimentResponseDesignSpecExperimentNameMaxOne),
						description: zod
							.string()
							.max(getExperimentResponseDesignSpecDescriptionMaxOne),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												getExperimentResponseDesignSpecArmsItemArmNameMaxOne,
											),
										arm_description: zod
											.string()
											.max(
												getExperimentResponseDesignSpecArmsItemArmDescriptionMaxFour,
											)
											.or(zod.null())
											.optional(),
									})
									.describe("Describes an experiment treatment arm."),
							)
							.min(getExperimentResponseDesignSpecArmsMinOne)
							.max(getExperimentResponseDesignSpecArmsMaxOne),
						strata: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												getExperimentResponseDesignSpecStrataItemFieldNameRegExpOne,
											),
									})
									.describe("Describes a variable used for stratification."),
							)
							.max(getExperimentResponseDesignSpecStrataMaxOne)
							.describe(
								"Optional participant_type fields to use for stratified assignment.",
							),
						metrics: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												getExperimentResponseDesignSpecMetricsItemFieldNameRegExpOne,
											),
										metric_pct_change: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
											),
										metric_target: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
											),
									})
									.describe(
										"Defines a request to look up baseline stats for a metric to measure in an experiment.",
									),
							)
							.min(1)
							.max(getExperimentResponseDesignSpecMetricsMaxOne)
							.describe("Primary and optional secondary metrics to target."),
						filters: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												getExperimentResponseDesignSpecFiltersItemFieldNameRegExpOne,
											),
										relation: zod
											.enum(["includes", "excludes", "between"])
											.describe(
												"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
											),
										value: zod
											.array(zod.number().or(zod.null()))
											.or(zod.array(zod.number().or(zod.null())))
											.or(zod.array(zod.string().or(zod.null())))
											.or(zod.array(zod.boolean().or(zod.null()))),
									})
									.describe(
										'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value       | logical Result                                    |\n|----------|-------------|---------------------------------------------------|\n| INCLUDES | [None]      | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |\n\nString comparisons are case-sensitive.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of datetime and timestamp values\n\nDATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
									),
							)
							.max(getExperimentResponseDesignSpecFiltersMaxOne)
							.describe(
								"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
							),
						power: zod
							.number()
							.min(getExperimentResponseDesignSpecPowerMinOne)
							.max(getExperimentResponseDesignSpecPowerMaxOne)
							.default(getExperimentResponseDesignSpecPowerDefaultOne)
							.describe(
								"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
							),
						alpha: zod
							.number()
							.min(getExperimentResponseDesignSpecAlphaMinOne)
							.max(getExperimentResponseDesignSpecAlphaMaxOne)
							.default(getExperimentResponseDesignSpecAlphaDefaultOne)
							.describe(
								"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
							),
						fstat_thresh: zod
							.number()
							.min(getExperimentResponseDesignSpecFstatThreshMinOne)
							.max(getExperimentResponseDesignSpecFstatThreshMaxOne)
							.default(getExperimentResponseDesignSpecFstatThreshDefaultOne)
							.describe(
								'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
							),
					})
					.describe(
						"Use this type to randomly assign participants into arms during live experiment execution with frequentist A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
					),
				zod
					.object({
						participant_type: zod
							.string()
							.max(getExperimentResponseDesignSpecParticipantTypeMaxTwo),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
							),
						experiment_type: zod.enum(["mab_online"]),
						experiment_name: zod
							.string()
							.max(getExperimentResponseDesignSpecExperimentNameMaxTwo),
						description: zod
							.string()
							.max(getExperimentResponseDesignSpecDescriptionMaxTwo),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												getExperimentResponseDesignSpecArmsItemArmNameMaxTwo,
											),
										arm_description: zod
											.string()
											.max(
												getExperimentResponseDesignSpecArmsItemArmDescriptionMaxSeven,
											)
											.or(zod.null())
											.optional(),
										alpha_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial alpha parameter for Beta prior"),
										beta_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial beta parameter for Beta prior"),
										mu_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial mean parameter for Normal prior"),
										sigma_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Initial standard deviation parameter for Normal prior",
											),
										alpha: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated alpha parameter for Beta prior"),
										beta: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated beta parameter for Beta prior"),
										mu: zod
											.array(zod.number())
											.or(zod.null())
											.optional()
											.describe("Updated mean vector for Normal prior"),
										covariance: zod
											.array(zod.array(zod.number()))
											.or(zod.null())
											.optional()
											.describe("Updated covariance matrix for Normal prior"),
									})
									.describe(
										"Describes an experiment arm for bandit experiments.",
									),
							)
							.min(getExperimentResponseDesignSpecArmsMinTwo)
							.max(getExperimentResponseDesignSpecArmsMaxTwo),
						contexts: zod
							.array(
								zod
									.object({
										context_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"Unique identifier for the context, you should NOT set this when creating a new context.",
											),
										context_name: zod
											.string()
											.max(
												getExperimentResponseDesignSpecContextsItemContextNameMax,
											),
										context_description: zod
											.string()
											.max(
												getExperimentResponseDesignSpecContextsItemContextDescriptionMaxOne,
											)
											.or(zod.null())
											.optional(),
										value_type: zod
											.enum(["binary", "real-valued"])
											.optional()
											.describe("Enum for the type of context."),
									})
									.describe("Pydantic model for context of the experiment."),
							)
							.max(getExperimentResponseDesignSpecContextsMaxOne)
							.or(zod.null())
							.optional()
							.describe(
								"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
							),
						prior_type: zod
							.enum(["beta", "normal"])
							.optional()
							.describe("Enum for the prior distribution of the arm."),
						reward_type: zod
							.enum(["binary", "real-valued"])
							.optional()
							.describe("Enum for the likelihood distribution of the reward."),
					})
					.describe(
						"Use this type to randomly assign participants into arms during live experiment execution with MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
					),
				zod
					.object({
						participant_type: zod
							.string()
							.max(getExperimentResponseDesignSpecParticipantTypeMaxThree),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
							),
						experiment_type: zod.enum(["cmab_online"]),
						experiment_name: zod
							.string()
							.max(getExperimentResponseDesignSpecExperimentNameMaxThree),
						description: zod
							.string()
							.max(getExperimentResponseDesignSpecDescriptionMaxThree),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												getExperimentResponseDesignSpecArmsItemArmNameMaxThree,
											),
										arm_description: zod
											.string()
											.max(
												getExperimentResponseDesignSpecArmsItemArmDescriptionMaxOnezero,
											)
											.or(zod.null())
											.optional(),
										alpha_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial alpha parameter for Beta prior"),
										beta_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial beta parameter for Beta prior"),
										mu_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial mean parameter for Normal prior"),
										sigma_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Initial standard deviation parameter for Normal prior",
											),
										alpha: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated alpha parameter for Beta prior"),
										beta: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated beta parameter for Beta prior"),
										mu: zod
											.array(zod.number())
											.or(zod.null())
											.optional()
											.describe("Updated mean vector for Normal prior"),
										covariance: zod
											.array(zod.array(zod.number()))
											.or(zod.null())
											.optional()
											.describe("Updated covariance matrix for Normal prior"),
									})
									.describe(
										"Describes an experiment arm for bandit experiments.",
									),
							)
							.min(getExperimentResponseDesignSpecArmsMinThree)
							.max(getExperimentResponseDesignSpecArmsMaxThree),
						contexts: zod
							.array(
								zod
									.object({
										context_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"Unique identifier for the context, you should NOT set this when creating a new context.",
											),
										context_name: zod
											.string()
											.max(
												getExperimentResponseDesignSpecContextsItemContextNameMaxOne,
											),
										context_description: zod
											.string()
											.max(
												getExperimentResponseDesignSpecContextsItemContextDescriptionMaxFour,
											)
											.or(zod.null())
											.optional(),
										value_type: zod
											.enum(["binary", "real-valued"])
											.optional()
											.describe("Enum for the type of context."),
									})
									.describe("Pydantic model for context of the experiment."),
							)
							.max(getExperimentResponseDesignSpecContextsMaxFour)
							.or(zod.null())
							.optional()
							.describe(
								"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
							),
						prior_type: zod
							.enum(["beta", "normal"])
							.optional()
							.describe("Enum for the prior distribution of the arm."),
						reward_type: zod
							.enum(["binary", "real-valued"])
							.optional()
							.describe("Enum for the likelihood distribution of the reward."),
					})
					.describe(
						"Use this type to randomly assign participants into arms during live experiment execution with contextual MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
					),
				zod
					.object({
						participant_type: zod
							.string()
							.max(getExperimentResponseDesignSpecParticipantTypeMaxFour),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
							),
						experiment_type: zod.enum(["bayes_ab_online"]),
						experiment_name: zod
							.string()
							.max(getExperimentResponseDesignSpecExperimentNameMaxFour),
						description: zod
							.string()
							.max(getExperimentResponseDesignSpecDescriptionMaxFour),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												getExperimentResponseDesignSpecArmsItemArmNameMaxFour,
											),
										arm_description: zod
											.string()
											.max(
												getExperimentResponseDesignSpecArmsItemArmDescriptionMaxOnethree,
											)
											.or(zod.null())
											.optional(),
										alpha_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial alpha parameter for Beta prior"),
										beta_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial beta parameter for Beta prior"),
										mu_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial mean parameter for Normal prior"),
										sigma_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Initial standard deviation parameter for Normal prior",
											),
										alpha: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated alpha parameter for Beta prior"),
										beta: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated beta parameter for Beta prior"),
										mu: zod
											.array(zod.number())
											.or(zod.null())
											.optional()
											.describe("Updated mean vector for Normal prior"),
										covariance: zod
											.array(zod.array(zod.number()))
											.or(zod.null())
											.optional()
											.describe("Updated covariance matrix for Normal prior"),
									})
									.describe(
										"Describes an experiment arm for bandit experiments.",
									),
							)
							.min(getExperimentResponseDesignSpecArmsMinFour)
							.max(getExperimentResponseDesignSpecArmsMaxFour),
						contexts: zod
							.array(
								zod
									.object({
										context_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"Unique identifier for the context, you should NOT set this when creating a new context.",
											),
										context_name: zod
											.string()
											.max(
												getExperimentResponseDesignSpecContextsItemContextNameMaxTwo,
											),
										context_description: zod
											.string()
											.max(
												getExperimentResponseDesignSpecContextsItemContextDescriptionMaxSeven,
											)
											.or(zod.null())
											.optional(),
										value_type: zod
											.enum(["binary", "real-valued"])
											.optional()
											.describe("Enum for the type of context."),
									})
									.describe("Pydantic model for context of the experiment."),
							)
							.max(getExperimentResponseDesignSpecContextsMaxSeven)
							.or(zod.null())
							.optional()
							.describe(
								"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
							),
						prior_type: zod
							.enum(["beta", "normal"])
							.optional()
							.describe("Enum for the prior distribution of the arm."),
						reward_type: zod
							.enum(["binary", "real-valued"])
							.optional()
							.describe("Enum for the likelihood distribution of the reward."),
					})
					.describe(
						"Use this type to randomly assign participants into arms during live experiment execution with Bayesian A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
					),
			])
			.describe("The type of assignment and experiment design."),
		power_analyses: zod
			.object({
				analyses: zod
					.array(
						zod
							.object({
								metric_spec: zod
									.object({
										field_name: zod
											.string()
											.regex(
												getExperimentResponsePowerAnalysesAnalysesItemMetricSpecFieldNameRegExp,
											),
										metric_pct_change: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Percent change target relative to the metric_baseline.",
											),
										metric_target: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Absolute target value = metric_baseline*(1 + metric_pct_change)",
											),
										metric_type: zod
											.enum(["binary", "numeric"])
											.describe("Classifies metrics by their value type.")
											.or(zod.null())
											.optional()
											.describe("Inferred from dwh type."),
										metric_baseline: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Mean of the tracked metric."),
										metric_stddev: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Standard deviation is set only for metric_type.NUMERIC metrics. Must be set for numeric metrics when available_n > 0.",
											),
										available_nonnull_n: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"The number of participants meeting the filtering criteria with a *non-null* value for this metric.",
											),
										available_n: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n.",
											),
									})
									.describe(
										"Defines a metric to measure in an experiment with its baseline stats.",
									),
								target_n: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Minimum sample size needed to meet the design specs.",
									),
								sufficient_n: zod
									.boolean()
									.or(zod.null())
									.optional()
									.describe(
										"Whether or not there are enough available units to sample from to meet target_n.",
									),
								target_possible: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.",
									),
								pct_change_possible: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.",
									),
								msg: zod
									.object({
										type: zod
											.enum([
												"sufficient",
												"insufficient",
												"no baseline",
												"no available n",
												"zero effect size",
												"zero variation",
											])
											.describe("Classifies metric power analysis results."),
										msg: zod
											.string()
											.describe(
												"Main power analysis result stated in human-friendly English.",
											),
										source_msg: zod
											.string()
											.describe(
												"Power analysis result formatted as a template string with curly-braced {} named placeholders. Use with the dictionary of values to support localization of messages.",
											),
										values: zod
											.record(zod.string(), zod.number().or(zod.number()))
											.or(zod.null())
											.optional(),
									})
									.describe(
										"Describes interpretation of power analysis results.",
									)
									.or(zod.null())
									.optional()
									.describe("Human friendly message about the above results."),
							})
							.describe("Describes analysis results of a single metric."),
					)
					.max(getExperimentResponsePowerAnalysesAnalysesMax),
			})
			.or(zod.null()),
		assign_summary: zod
			.object({
				balance_check: zod
					.object({
						f_statistic: zod
							.number()
							.describe(
								"F-statistic testing the overall significance of the model predicting treatment assignment.",
							),
						numerator_df: zod
							.number()
							.describe(
								"The numerator degrees of freedom for the f-statistic related to number of dependent variables.",
							),
						denominator_df: zod
							.number()
							.describe(
								"Denominator degrees of freedom related to the number of observations.",
							),
						p_value: zod
							.number()
							.describe(
								"Probability of observing these data if strata do not predict treatment assignment, i.e. our randomization is balanced.",
							),
						balance_ok: zod
							.boolean()
							.describe(
								"Whether the p-value for our observed f_statistic is greater than the f-stat threshold specified in our design specification. (See DesignSpec.fstat_thresh)",
							),
					})
					.describe("Describes balance test results for treatment assignment.")
					.or(zod.null())
					.optional()
					.describe(
						"Balance test results if available. 'online' experiments do not have balance checks.",
					),
				sample_size: zod
					.number()
					.describe("The number of participants across all arms in total."),
				arm_sizes: zod
					.array(
						zod
							.object({
								arm: zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												getExperimentResponseAssignSummaryArmSizesItemArmArmNameMax,
											),
										arm_description: zod
											.string()
											.max(
												getExperimentResponseAssignSummaryArmSizesItemArmArmDescriptionMaxOne,
											)
											.or(zod.null())
											.optional(),
									})
									.describe("Describes an experiment treatment arm."),
								size: zod.number().optional(),
							})
							.describe(
								"Describes the number of participants assigned to each arm.",
							),
					)
					.max(getExperimentResponseAssignSummaryArmSizesMaxOne)
					.or(zod.null())
					.optional()
					.describe("For each arm, the number of participants assigned."),
			})
			.describe("Key pieces of an AssignResponse without the assignments.")
			.or(zod.null()),
		webhooks: zod
			.array(zod.string())
			.default(getExperimentResponseWebhooksDefault)
			.describe(
				"List of webhook IDs associated with this experiment. These webhooks are triggered when the experiment is committed.",
			),
	})
	.describe(
		"An experiment configuration capturing all info at design time when assignment was made.",
	);

/**
 * Deletes the experiment with the specified ID.
 * @summary Delete Experiment
 */
export const deleteExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const deleteExperimentQueryAllowMissingDefault = false;

export const deleteExperimentQueryParams = zod.object({
	allow_missing: zod
		.boolean()
		.optional()
		.describe("If true, return a 204 even if the resource does not exist."),
});

/**
 * @summary Get Experiment Assignments
 */
export const getExperimentAssignmentsParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const getExperimentAssignmentsResponseAssignmentsItemParticipantIdMax = 64;
export const getExperimentAssignmentsResponseAssignmentsItemArmNameMax = 100;
export const getExperimentAssignmentsResponseAssignmentsItemStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentAssignmentsResponseAssignmentsItemStrataMaxOne = 150;
export const getExperimentAssignmentsResponseAssignmentsItemContextValuesMaxOne = 10;

export const getExperimentAssignmentsResponse = zod
	.object({
		balance_check: zod
			.object({
				f_statistic: zod
					.number()
					.describe(
						"F-statistic testing the overall significance of the model predicting treatment assignment.",
					),
				numerator_df: zod
					.number()
					.describe(
						"The numerator degrees of freedom for the f-statistic related to number of dependent variables.",
					),
				denominator_df: zod
					.number()
					.describe(
						"Denominator degrees of freedom related to the number of observations.",
					),
				p_value: zod
					.number()
					.describe(
						"Probability of observing these data if strata do not predict treatment assignment, i.e. our randomization is balanced.",
					),
				balance_ok: zod
					.boolean()
					.describe(
						"Whether the p-value for our observed f_statistic is greater than the f-stat threshold specified in our design specification. (See DesignSpec.fstat_thresh)",
					),
			})
			.describe("Describes balance test results for treatment assignment.")
			.or(zod.null())
			.optional()
			.describe(
				"Balance test results if available. 'online' experiments do not have balance checks.",
			),
		experiment_id: zod.string(),
		sample_size: zod.number(),
		assignments: zod.array(
			zod
				.object({
					arm_id: zod
						.string()
						.describe(
							"ID of the arm this participant was assigned to. Same as Arm.arm_id.",
						),
					participant_id: zod
						.string()
						.max(
							getExperimentAssignmentsResponseAssignmentsItemParticipantIdMax,
						)
						.describe(
							"Unique identifier for the participant. This is the primary key for the participant in the data warehouse.",
						),
					arm_name: zod
						.string()
						.max(getExperimentAssignmentsResponseAssignmentsItemArmNameMax)
						.describe(
							"The arm this participant was assigned to. Same as Arm.arm_name.",
						),
					created_at: zod
						.string()
						.datetime({})
						.or(zod.null())
						.optional()
						.describe("The date and time the assignment was created."),
					strata: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											getExperimentAssignmentsResponseAssignmentsItemStrataItemFieldNameRegExp,
										),
									strata_value: zod.string().or(zod.null()).optional(),
								})
								.describe(
									"Describes stratification for an experiment participant.",
								),
						)
						.max(getExperimentAssignmentsResponseAssignmentsItemStrataMaxOne)
						.or(zod.null())
						.optional()
						.describe(
							"List of properties and their values for this participant used for stratification or tracking metrics. If stratification is not used, this will be None.",
						),
					observed_at: zod
						.string()
						.datetime({})
						.or(zod.null())
						.optional()
						.describe("The date and time the outcome was recorded."),
					outcome: zod
						.number()
						.or(zod.null())
						.optional()
						.describe("The observed outcome for this assignment."),
					context_values: zod
						.array(zod.number())
						.max(
							getExperimentAssignmentsResponseAssignmentsItemContextValuesMaxOne,
						)
						.or(zod.null())
						.optional()
						.describe(
							"List of context values for this assignment. If no contexts are used, this will be None.",
						),
				})
				.describe("Base class for treatment assignment in experiments."),
		),
	})
	.describe(
		"Describes assignments for all participants and balance test results if available.",
	);

/**
 * @summary Export experiment assignments as CSV file; BalanceCheck not included. csv header form: participant_id,arm_id,arm_name,strata_name1,strata_name2,...
 */
export const getExperimentAssignmentsAsCsvParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const getExperimentAssignmentsAsCsvResponse = zod.any();

/**
 * Get the assignment for a specific participant, excluding strata if any.
    For 'preassigned' experiments, the participant's Assignment is returned if it exists.
    For 'online', returns the assignment if it exists, else generates an assignment.
 * @summary Get Experiment Assignment For Participant
 */
export const getExperimentAssignmentForParticipantParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
	participant_id: zod.string(),
});

export const getExperimentAssignmentForParticipantQueryCreateIfNoneDefault = true;

export const getExperimentAssignmentForParticipantQueryParams = zod.object({
	create_if_none: zod
		.boolean()
		.default(getExperimentAssignmentForParticipantQueryCreateIfNoneDefault)
		.describe(
			"Create an assignment if none exists. Does nothing for preassigned experiments. Override if you just want to check if an assignment exists.",
		),
});

export const getExperimentAssignmentForParticipantResponseAssignmentParticipantIdMax = 64;
export const getExperimentAssignmentForParticipantResponseAssignmentArmNameMax = 100;
export const getExperimentAssignmentForParticipantResponseAssignmentStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentAssignmentForParticipantResponseAssignmentStrataMaxOne = 150;
export const getExperimentAssignmentForParticipantResponseAssignmentContextValuesMaxOne = 10;

export const getExperimentAssignmentForParticipantResponse = zod
	.object({
		experiment_id: zod.string(),
		participant_id: zod.string(),
		assignment: zod
			.object({
				arm_id: zod
					.string()
					.describe(
						"ID of the arm this participant was assigned to. Same as Arm.arm_id.",
					),
				participant_id: zod
					.string()
					.max(
						getExperimentAssignmentForParticipantResponseAssignmentParticipantIdMax,
					)
					.describe(
						"Unique identifier for the participant. This is the primary key for the participant in the data warehouse.",
					),
				arm_name: zod
					.string()
					.max(
						getExperimentAssignmentForParticipantResponseAssignmentArmNameMax,
					)
					.describe(
						"The arm this participant was assigned to. Same as Arm.arm_name.",
					),
				created_at: zod
					.string()
					.datetime({})
					.or(zod.null())
					.optional()
					.describe("The date and time the assignment was created."),
				strata: zod
					.array(
						zod
							.object({
								field_name: zod
									.string()
									.regex(
										getExperimentAssignmentForParticipantResponseAssignmentStrataItemFieldNameRegExp,
									),
								strata_value: zod.string().or(zod.null()).optional(),
							})
							.describe(
								"Describes stratification for an experiment participant.",
							),
					)
					.max(
						getExperimentAssignmentForParticipantResponseAssignmentStrataMaxOne,
					)
					.or(zod.null())
					.optional()
					.describe(
						"List of properties and their values for this participant used for stratification or tracking metrics. If stratification is not used, this will be None.",
					),
				observed_at: zod
					.string()
					.datetime({})
					.or(zod.null())
					.optional()
					.describe("The date and time the outcome was recorded."),
				outcome: zod
					.number()
					.or(zod.null())
					.optional()
					.describe("The observed outcome for this assignment."),
				context_values: zod
					.array(zod.number())
					.max(
						getExperimentAssignmentForParticipantResponseAssignmentContextValuesMaxOne,
					)
					.or(zod.null())
					.optional()
					.describe(
						"List of context values for this assignment. If no contexts are used, this will be None.",
					),
			})
			.describe("Base class for treatment assignment in experiments.")
			.or(zod.null())
			.describe("Null if no assignment. assignment.strata are not included."),
	})
	.describe(
		"Describes assignment for a single <experiment, participant> pair.",
	);

/**
 * Performs a power check for the specified datasource.
 * @summary Power Check
 */
export const powerCheckParams = zod.object({
	datasource_id: zod.string(),
});

export const powerCheckBodyDesignSpecParticipantTypeMax = 100;
export const powerCheckBodyDesignSpecExperimentNameMax = 100;
export const powerCheckBodyDesignSpecDescriptionMax = 2000;
export const powerCheckBodyDesignSpecArmsItemArmNameMax = 100;
export const powerCheckBodyDesignSpecArmsItemArmDescriptionMaxOne = 2000;
export const powerCheckBodyDesignSpecArmsMin = 2;

export const powerCheckBodyDesignSpecArmsMax = 10;
export const powerCheckBodyDesignSpecStrataItemFieldNameRegExp = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecStrataMax = 150;
export const powerCheckBodyDesignSpecMetricsItemFieldNameRegExp = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecMetricsMax = 150;
export const powerCheckBodyDesignSpecFiltersItemFieldNameRegExp = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecFiltersMax = 20;
export const powerCheckBodyDesignSpecPowerDefault = 0.8;
export const powerCheckBodyDesignSpecPowerMin = 0;

export const powerCheckBodyDesignSpecPowerMax = 1;
export const powerCheckBodyDesignSpecAlphaDefault = 0.05;
export const powerCheckBodyDesignSpecAlphaMin = 0;

export const powerCheckBodyDesignSpecAlphaMax = 1;
export const powerCheckBodyDesignSpecFstatThreshDefault = 0.6;
export const powerCheckBodyDesignSpecFstatThreshMin = 0;

export const powerCheckBodyDesignSpecFstatThreshMax = 1;
export const powerCheckBodyDesignSpecParticipantTypeMaxOne = 100;
export const powerCheckBodyDesignSpecExperimentNameMaxOne = 100;
export const powerCheckBodyDesignSpecDescriptionMaxOne = 2000;
export const powerCheckBodyDesignSpecArmsItemArmNameMaxOne = 100;
export const powerCheckBodyDesignSpecArmsItemArmDescriptionMaxFour = 2000;
export const powerCheckBodyDesignSpecArmsMinOne = 2;

export const powerCheckBodyDesignSpecArmsMaxOne = 10;
export const powerCheckBodyDesignSpecStrataItemFieldNameRegExpOne = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecStrataMaxOne = 150;
export const powerCheckBodyDesignSpecMetricsItemFieldNameRegExpOne = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecMetricsMaxOne = 150;
export const powerCheckBodyDesignSpecFiltersItemFieldNameRegExpOne = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecFiltersMaxOne = 20;
export const powerCheckBodyDesignSpecPowerDefaultOne = 0.8;
export const powerCheckBodyDesignSpecPowerMinOne = 0;

export const powerCheckBodyDesignSpecPowerMaxOne = 1;
export const powerCheckBodyDesignSpecAlphaDefaultOne = 0.05;
export const powerCheckBodyDesignSpecAlphaMinOne = 0;

export const powerCheckBodyDesignSpecAlphaMaxOne = 1;
export const powerCheckBodyDesignSpecFstatThreshDefaultOne = 0.6;
export const powerCheckBodyDesignSpecFstatThreshMinOne = 0;

export const powerCheckBodyDesignSpecFstatThreshMaxOne = 1;
export const powerCheckBodyDesignSpecParticipantTypeMaxTwo = 100;
export const powerCheckBodyDesignSpecExperimentNameMaxTwo = 100;
export const powerCheckBodyDesignSpecDescriptionMaxTwo = 2000;
export const powerCheckBodyDesignSpecArmsItemArmNameMaxTwo = 100;
export const powerCheckBodyDesignSpecArmsItemArmDescriptionMaxSeven = 2000;
export const powerCheckBodyDesignSpecArmsMinTwo = 2;

export const powerCheckBodyDesignSpecArmsMaxTwo = 10;
export const powerCheckBodyDesignSpecContextsItemContextNameMax = 100;
export const powerCheckBodyDesignSpecContextsItemContextDescriptionMaxOne = 2000;
export const powerCheckBodyDesignSpecContextsMaxOne = 150;
export const powerCheckBodyDesignSpecParticipantTypeMaxThree = 100;
export const powerCheckBodyDesignSpecExperimentNameMaxThree = 100;
export const powerCheckBodyDesignSpecDescriptionMaxThree = 2000;
export const powerCheckBodyDesignSpecArmsItemArmNameMaxThree = 100;
export const powerCheckBodyDesignSpecArmsItemArmDescriptionMaxOnezero = 2000;
export const powerCheckBodyDesignSpecArmsMinThree = 2;

export const powerCheckBodyDesignSpecArmsMaxThree = 10;
export const powerCheckBodyDesignSpecContextsItemContextNameMaxOne = 100;
export const powerCheckBodyDesignSpecContextsItemContextDescriptionMaxFour = 2000;
export const powerCheckBodyDesignSpecContextsMaxFour = 150;
export const powerCheckBodyDesignSpecParticipantTypeMaxFour = 100;
export const powerCheckBodyDesignSpecExperimentNameMaxFour = 100;
export const powerCheckBodyDesignSpecDescriptionMaxFour = 2000;
export const powerCheckBodyDesignSpecArmsItemArmNameMaxFour = 100;
export const powerCheckBodyDesignSpecArmsItemArmDescriptionMaxOnethree = 2000;
export const powerCheckBodyDesignSpecArmsMinFour = 2;

export const powerCheckBodyDesignSpecArmsMaxFour = 10;
export const powerCheckBodyDesignSpecContextsItemContextNameMaxTwo = 100;
export const powerCheckBodyDesignSpecContextsItemContextDescriptionMaxSeven = 2000;
export const powerCheckBodyDesignSpecContextsMaxSeven = 150;

export const powerCheckBody = zod.object({
	design_spec: zod
		.discriminatedUnion("experiment_type", [
			zod
				.object({
					participant_type: zod
						.string()
						.max(powerCheckBodyDesignSpecParticipantTypeMax),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
						),
					experiment_type: zod.enum(["freq_preassigned"]),
					experiment_name: zod
						.string()
						.max(powerCheckBodyDesignSpecExperimentNameMax),
					description: zod.string().max(powerCheckBodyDesignSpecDescriptionMax),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(powerCheckBodyDesignSpecArmsItemArmNameMax),
									arm_description: zod
										.string()
										.max(powerCheckBodyDesignSpecArmsItemArmDescriptionMaxOne)
										.or(zod.null())
										.optional(),
								})
								.describe("Describes an experiment treatment arm."),
						)
						.min(powerCheckBodyDesignSpecArmsMin)
						.max(powerCheckBodyDesignSpecArmsMax),
					strata: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(powerCheckBodyDesignSpecStrataItemFieldNameRegExp),
								})
								.describe("Describes a variable used for stratification."),
						)
						.max(powerCheckBodyDesignSpecStrataMax)
						.describe(
							"Optional participant_type fields to use for stratified assignment.",
						),
					metrics: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(powerCheckBodyDesignSpecMetricsItemFieldNameRegExp),
									metric_pct_change: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
										),
									metric_target: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
										),
								})
								.describe(
									"Defines a request to look up baseline stats for a metric to measure in an experiment.",
								),
						)
						.min(1)
						.max(powerCheckBodyDesignSpecMetricsMax)
						.describe("Primary and optional secondary metrics to target."),
					filters: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(powerCheckBodyDesignSpecFiltersItemFieldNameRegExp),
									relation: zod
										.enum(["includes", "excludes", "between"])
										.describe(
											"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
										),
									value: zod
										.array(zod.number().or(zod.null()))
										.or(zod.array(zod.number().or(zod.null())))
										.or(zod.array(zod.string().or(zod.null())))
										.or(zod.array(zod.boolean().or(zod.null()))),
								})
								.describe(
									'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value       | logical Result                                    |\n|----------|-------------|---------------------------------------------------|\n| INCLUDES | [None]      | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |\n\nString comparisons are case-sensitive.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of datetime and timestamp values\n\nDATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
								),
						)
						.max(powerCheckBodyDesignSpecFiltersMax)
						.describe(
							"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
						),
					power: zod
						.number()
						.min(powerCheckBodyDesignSpecPowerMin)
						.max(powerCheckBodyDesignSpecPowerMax)
						.default(powerCheckBodyDesignSpecPowerDefault)
						.describe(
							"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
						),
					alpha: zod
						.number()
						.min(powerCheckBodyDesignSpecAlphaMin)
						.max(powerCheckBodyDesignSpecAlphaMax)
						.default(powerCheckBodyDesignSpecAlphaDefault)
						.describe(
							"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
						),
					fstat_thresh: zod
						.number()
						.min(powerCheckBodyDesignSpecFstatThreshMin)
						.max(powerCheckBodyDesignSpecFstatThreshMax)
						.default(powerCheckBodyDesignSpecFstatThreshDefault)
						.describe(
							'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
						),
				})
				.describe(
					"Use this type to randomly select and assign from existing participants at design time with frequentist A/B experiments.",
				),
			zod
				.object({
					participant_type: zod
						.string()
						.max(powerCheckBodyDesignSpecParticipantTypeMaxOne),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
						),
					experiment_type: zod.enum(["freq_online"]),
					experiment_name: zod
						.string()
						.max(powerCheckBodyDesignSpecExperimentNameMaxOne),
					description: zod
						.string()
						.max(powerCheckBodyDesignSpecDescriptionMaxOne),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(powerCheckBodyDesignSpecArmsItemArmNameMaxOne),
									arm_description: zod
										.string()
										.max(powerCheckBodyDesignSpecArmsItemArmDescriptionMaxFour)
										.or(zod.null())
										.optional(),
								})
								.describe("Describes an experiment treatment arm."),
						)
						.min(powerCheckBodyDesignSpecArmsMinOne)
						.max(powerCheckBodyDesignSpecArmsMaxOne),
					strata: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											powerCheckBodyDesignSpecStrataItemFieldNameRegExpOne,
										),
								})
								.describe("Describes a variable used for stratification."),
						)
						.max(powerCheckBodyDesignSpecStrataMaxOne)
						.describe(
							"Optional participant_type fields to use for stratified assignment.",
						),
					metrics: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											powerCheckBodyDesignSpecMetricsItemFieldNameRegExpOne,
										),
									metric_pct_change: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
										),
									metric_target: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
										),
								})
								.describe(
									"Defines a request to look up baseline stats for a metric to measure in an experiment.",
								),
						)
						.min(1)
						.max(powerCheckBodyDesignSpecMetricsMaxOne)
						.describe("Primary and optional secondary metrics to target."),
					filters: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											powerCheckBodyDesignSpecFiltersItemFieldNameRegExpOne,
										),
									relation: zod
										.enum(["includes", "excludes", "between"])
										.describe(
											"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
										),
									value: zod
										.array(zod.number().or(zod.null()))
										.or(zod.array(zod.number().or(zod.null())))
										.or(zod.array(zod.string().or(zod.null())))
										.or(zod.array(zod.boolean().or(zod.null()))),
								})
								.describe(
									'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value       | logical Result                                    |\n|----------|-------------|---------------------------------------------------|\n| INCLUDES | [None]      | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |\n\nString comparisons are case-sensitive.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of datetime and timestamp values\n\nDATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
								),
						)
						.max(powerCheckBodyDesignSpecFiltersMaxOne)
						.describe(
							"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
						),
					power: zod
						.number()
						.min(powerCheckBodyDesignSpecPowerMinOne)
						.max(powerCheckBodyDesignSpecPowerMaxOne)
						.default(powerCheckBodyDesignSpecPowerDefaultOne)
						.describe(
							"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
						),
					alpha: zod
						.number()
						.min(powerCheckBodyDesignSpecAlphaMinOne)
						.max(powerCheckBodyDesignSpecAlphaMaxOne)
						.default(powerCheckBodyDesignSpecAlphaDefaultOne)
						.describe(
							"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
						),
					fstat_thresh: zod
						.number()
						.min(powerCheckBodyDesignSpecFstatThreshMinOne)
						.max(powerCheckBodyDesignSpecFstatThreshMaxOne)
						.default(powerCheckBodyDesignSpecFstatThreshDefaultOne)
						.describe(
							'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
						),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution with frequentist A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
			zod
				.object({
					participant_type: zod
						.string()
						.max(powerCheckBodyDesignSpecParticipantTypeMaxTwo),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
						),
					experiment_type: zod.enum(["mab_online"]),
					experiment_name: zod
						.string()
						.max(powerCheckBodyDesignSpecExperimentNameMaxTwo),
					description: zod
						.string()
						.max(powerCheckBodyDesignSpecDescriptionMaxTwo),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(powerCheckBodyDesignSpecArmsItemArmNameMaxTwo),
									arm_description: zod
										.string()
										.max(powerCheckBodyDesignSpecArmsItemArmDescriptionMaxSeven)
										.or(zod.null())
										.optional(),
									alpha_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial alpha parameter for Beta prior"),
									beta_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial beta parameter for Beta prior"),
									mu_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial mean parameter for Normal prior"),
									sigma_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Initial standard deviation parameter for Normal prior",
										),
									alpha: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated alpha parameter for Beta prior"),
									beta: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated beta parameter for Beta prior"),
									mu: zod
										.array(zod.number())
										.or(zod.null())
										.optional()
										.describe("Updated mean vector for Normal prior"),
									covariance: zod
										.array(zod.array(zod.number()))
										.or(zod.null())
										.optional()
										.describe("Updated covariance matrix for Normal prior"),
								})
								.describe(
									"Describes an experiment arm for bandit experiments.",
								),
						)
						.min(powerCheckBodyDesignSpecArmsMinTwo)
						.max(powerCheckBodyDesignSpecArmsMaxTwo),
					contexts: zod
						.array(
							zod
								.object({
									context_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"Unique identifier for the context, you should NOT set this when creating a new context.",
										),
									context_name: zod
										.string()
										.max(powerCheckBodyDesignSpecContextsItemContextNameMax),
									context_description: zod
										.string()
										.max(
											powerCheckBodyDesignSpecContextsItemContextDescriptionMaxOne,
										)
										.or(zod.null())
										.optional(),
									value_type: zod
										.enum(["binary", "real-valued"])
										.optional()
										.describe("Enum for the type of context."),
								})
								.describe("Pydantic model for context of the experiment."),
						)
						.max(powerCheckBodyDesignSpecContextsMaxOne)
						.or(zod.null())
						.optional()
						.describe(
							"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
						),
					prior_type: zod
						.enum(["beta", "normal"])
						.optional()
						.describe("Enum for the prior distribution of the arm."),
					reward_type: zod
						.enum(["binary", "real-valued"])
						.optional()
						.describe("Enum for the likelihood distribution of the reward."),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution with MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
			zod
				.object({
					participant_type: zod
						.string()
						.max(powerCheckBodyDesignSpecParticipantTypeMaxThree),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
						),
					experiment_type: zod.enum(["cmab_online"]),
					experiment_name: zod
						.string()
						.max(powerCheckBodyDesignSpecExperimentNameMaxThree),
					description: zod
						.string()
						.max(powerCheckBodyDesignSpecDescriptionMaxThree),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(powerCheckBodyDesignSpecArmsItemArmNameMaxThree),
									arm_description: zod
										.string()
										.max(
											powerCheckBodyDesignSpecArmsItemArmDescriptionMaxOnezero,
										)
										.or(zod.null())
										.optional(),
									alpha_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial alpha parameter for Beta prior"),
									beta_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial beta parameter for Beta prior"),
									mu_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial mean parameter for Normal prior"),
									sigma_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Initial standard deviation parameter for Normal prior",
										),
									alpha: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated alpha parameter for Beta prior"),
									beta: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated beta parameter for Beta prior"),
									mu: zod
										.array(zod.number())
										.or(zod.null())
										.optional()
										.describe("Updated mean vector for Normal prior"),
									covariance: zod
										.array(zod.array(zod.number()))
										.or(zod.null())
										.optional()
										.describe("Updated covariance matrix for Normal prior"),
								})
								.describe(
									"Describes an experiment arm for bandit experiments.",
								),
						)
						.min(powerCheckBodyDesignSpecArmsMinThree)
						.max(powerCheckBodyDesignSpecArmsMaxThree),
					contexts: zod
						.array(
							zod
								.object({
									context_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"Unique identifier for the context, you should NOT set this when creating a new context.",
										),
									context_name: zod
										.string()
										.max(powerCheckBodyDesignSpecContextsItemContextNameMaxOne),
									context_description: zod
										.string()
										.max(
											powerCheckBodyDesignSpecContextsItemContextDescriptionMaxFour,
										)
										.or(zod.null())
										.optional(),
									value_type: zod
										.enum(["binary", "real-valued"])
										.optional()
										.describe("Enum for the type of context."),
								})
								.describe("Pydantic model for context of the experiment."),
						)
						.max(powerCheckBodyDesignSpecContextsMaxFour)
						.or(zod.null())
						.optional()
						.describe(
							"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
						),
					prior_type: zod
						.enum(["beta", "normal"])
						.optional()
						.describe("Enum for the prior distribution of the arm."),
					reward_type: zod
						.enum(["binary", "real-valued"])
						.optional()
						.describe("Enum for the likelihood distribution of the reward."),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution with contextual MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
			zod
				.object({
					participant_type: zod
						.string()
						.max(powerCheckBodyDesignSpecParticipantTypeMaxFour),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
						),
					experiment_type: zod.enum(["bayes_ab_online"]),
					experiment_name: zod
						.string()
						.max(powerCheckBodyDesignSpecExperimentNameMaxFour),
					description: zod
						.string()
						.max(powerCheckBodyDesignSpecDescriptionMaxFour),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(powerCheckBodyDesignSpecArmsItemArmNameMaxFour),
									arm_description: zod
										.string()
										.max(
											powerCheckBodyDesignSpecArmsItemArmDescriptionMaxOnethree,
										)
										.or(zod.null())
										.optional(),
									alpha_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial alpha parameter for Beta prior"),
									beta_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial beta parameter for Beta prior"),
									mu_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial mean parameter for Normal prior"),
									sigma_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Initial standard deviation parameter for Normal prior",
										),
									alpha: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated alpha parameter for Beta prior"),
									beta: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated beta parameter for Beta prior"),
									mu: zod
										.array(zod.number())
										.or(zod.null())
										.optional()
										.describe("Updated mean vector for Normal prior"),
									covariance: zod
										.array(zod.array(zod.number()))
										.or(zod.null())
										.optional()
										.describe("Updated covariance matrix for Normal prior"),
								})
								.describe(
									"Describes an experiment arm for bandit experiments.",
								),
						)
						.min(powerCheckBodyDesignSpecArmsMinFour)
						.max(powerCheckBodyDesignSpecArmsMaxFour),
					contexts: zod
						.array(
							zod
								.object({
									context_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"Unique identifier for the context, you should NOT set this when creating a new context.",
										),
									context_name: zod
										.string()
										.max(powerCheckBodyDesignSpecContextsItemContextNameMaxTwo),
									context_description: zod
										.string()
										.max(
											powerCheckBodyDesignSpecContextsItemContextDescriptionMaxSeven,
										)
										.or(zod.null())
										.optional(),
									value_type: zod
										.enum(["binary", "real-valued"])
										.optional()
										.describe("Enum for the type of context."),
								})
								.describe("Pydantic model for context of the experiment."),
						)
						.max(powerCheckBodyDesignSpecContextsMaxSeven)
						.or(zod.null())
						.optional()
						.describe(
							"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
						),
					prior_type: zod
						.enum(["beta", "normal"])
						.optional()
						.describe("Enum for the prior distribution of the arm."),
					reward_type: zod
						.enum(["binary", "real-valued"])
						.optional()
						.describe("Enum for the likelihood distribution of the reward."),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution with Bayesian A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
		])
		.describe("The type of assignment and experiment design."),
});

export const powerCheckResponseAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const powerCheckResponseAnalysesMax = 150;

export const powerCheckResponse = zod.object({
	analyses: zod
		.array(
			zod
				.object({
					metric_spec: zod
						.object({
							field_name: zod
								.string()
								.regex(powerCheckResponseAnalysesItemMetricSpecFieldNameRegExp),
							metric_pct_change: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"Percent change target relative to the metric_baseline.",
								),
							metric_target: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"Absolute target value = metric_baseline*(1 + metric_pct_change)",
								),
							metric_type: zod
								.enum(["binary", "numeric"])
								.describe("Classifies metrics by their value type.")
								.or(zod.null())
								.optional()
								.describe("Inferred from dwh type."),
							metric_baseline: zod
								.number()
								.or(zod.null())
								.optional()
								.describe("Mean of the tracked metric."),
							metric_stddev: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"Standard deviation is set only for metric_type.NUMERIC metrics. Must be set for numeric metrics when available_n > 0.",
								),
							available_nonnull_n: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"The number of participants meeting the filtering criteria with a *non-null* value for this metric.",
								),
							available_n: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n.",
								),
						})
						.describe(
							"Defines a metric to measure in an experiment with its baseline stats.",
						),
					target_n: zod
						.number()
						.or(zod.null())
						.optional()
						.describe("Minimum sample size needed to meet the design specs."),
					sufficient_n: zod
						.boolean()
						.or(zod.null())
						.optional()
						.describe(
							"Whether or not there are enough available units to sample from to meet target_n.",
						),
					target_possible: zod
						.number()
						.or(zod.null())
						.optional()
						.describe(
							"If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.",
						),
					pct_change_possible: zod
						.number()
						.or(zod.null())
						.optional()
						.describe(
							"If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.",
						),
					msg: zod
						.object({
							type: zod
								.enum([
									"sufficient",
									"insufficient",
									"no baseline",
									"no available n",
									"zero effect size",
									"zero variation",
								])
								.describe("Classifies metric power analysis results."),
							msg: zod
								.string()
								.describe(
									"Main power analysis result stated in human-friendly English.",
								),
							source_msg: zod
								.string()
								.describe(
									"Power analysis result formatted as a template string with curly-braced {} named placeholders. Use with the dictionary of values to support localization of messages.",
								),
							values: zod
								.record(zod.string(), zod.number().or(zod.number()))
								.or(zod.null())
								.optional(),
						})
						.describe("Describes interpretation of power analysis results.")
						.or(zod.null())
						.optional()
						.describe("Human friendly message about the above results."),
				})
				.describe("Describes analysis results of a single metric."),
		)
		.max(powerCheckResponseAnalysesMax),
});
