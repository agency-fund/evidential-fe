/**
 * Generated by orval v7.6.0 üç∫
 * Do not edit manually.
 * xngin: Experiments API
 * OpenAPI spec version: 0.9.0
 */
import { z as zod } from "zod";

/**
 * Returns basic metadata about the authenticated caller of this method.
 * @summary Caller Identity
 */
export const callerIdentityResponse = zod.object({
	email: zod.string(),
	iss: zod.string(),
	sub: zod.string(),
	hd: zod.string(),
});

/**
 * Returns a list of organizations that the authenticated user is a member of.
 * @summary List Organizations
 */
export const listOrganizationsResponse = zod.object({
	items: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string(),
		}),
	),
});

/**
 * Creates a new organization.

Only users with an @agency.fund email address can create organizations.
 * @summary Create Organizations
 */
export const createOrganizationsBody = zod.object({
	name: zod.string(),
});

export const createOrganizationsResponse = zod.object({
	id: zod.string(),
});

/**
 * Adds a new member to an organization.

The authenticated user must be part of the organization to add members.
 * @summary Add Member To Organization
 */
export const addMemberToOrganizationParams = zod.object({
	organization_id: zod.string(),
});

export const addMemberToOrganizationBody = zod.object({
	email: zod.string(),
});

/**
 * Removes a member from an organization.

The authenticated user must be part of the organization to remove members.
 * @summary Remove Member From Organization
 */
export const removeMemberFromOrganizationParams = zod.object({
	organization_id: zod.string(),
	user_id: zod.string(),
});

/**
 * Updates an organization's properties.

The authenticated user must be a member of the organization.
Currently only supports updating the organization name.
 * @summary Update Organization
 */
export const updateOrganizationParams = zod.object({
	organization_id: zod.string(),
});

export const updateOrganizationBody = zod.object({
	name: zod.string().or(zod.null()).optional(),
});

export const updateOrganizationResponse = zod.any();

/**
 * Returns detailed information about a specific organization.

The authenticated user must be a member of the organization.
 * @summary Get Organization
 */
export const getOrganizationParams = zod.object({
	organization_id: zod.string(),
});

export const getOrganizationResponse = zod.object({
	id: zod.string(),
	name: zod.string(),
	users: zod.array(
		zod.object({
			id: zod.string(),
			email: zod.string(),
		}),
	),
	datasources: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string(),
			driver: zod.string(),
			type: zod.string(),
			organization_id: zod.string(),
			organization_name: zod.string(),
		}),
	),
});

/**
 * Returns a list of datasources accessible to the authenticated user.
 * @summary List Datasources
 */
export const listDatasourcesResponse = zod.object({
	items: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string(),
			driver: zod.string(),
			type: zod.string(),
			organization_id: zod.string(),
			organization_name: zod.string(),
		}),
	),
});

/**
 * Creates a new datasource for the specified organization.
 * @summary Create Datasource
 */
export const createDatasourceBodyDwhPortDefault = 5432;
export const createDatasourceBodyDwhPortMin = 1024;

export const createDatasourceBodyDwhPortMax = 65535;

export const createDatasourceBody = zod.object({
	organization_id: zod.string(),
	name: zod.string(),
	dwh: zod.discriminatedUnion("driver", [
		zod.object({
			driver: zod.enum(["postgresql+psycopg", "postgresql+psycopg2"]),
			host: zod.string(),
			port: zod
				.number()
				.min(createDatasourceBodyDwhPortMin)
				.max(createDatasourceBodyDwhPortMax)
				.default(createDatasourceBodyDwhPortDefault),
			user: zod.string(),
			password: zod.string(),
			dbname: zod.string(),
			sslmode: zod
				.enum([
					"disable",
					"allow",
					"prefer",
					"require",
					"verify-ca",
					"verify-full",
				])
				.or(zod.null())
				.optional(),
			search_path: zod.string().or(zod.null()).optional(),
		}),
		zod.object({
			driver: zod.enum(["bigquery"]),
			project_id: zod.string(),
			dataset_id: zod.string(),
			credentials: zod.discriminatedUnion("type", [
				zod.object({
					type: zod.enum(["serviceaccountinfo"]),
					content_base64: zod.string(),
				}),
				zod.object({
					type: zod.enum(["serviceaccountfile"]),
					path: zod.string(),
				}),
			]),
		}),
	]),
});

export const createDatasourceResponse = zod.object({
	id: zod.string(),
});

/**
 * @summary Update Datasource
 */
export const updateDatasourceParams = zod.object({
	datasource_id: zod.string(),
});

export const updateDatasourceBodyDwhPortDefault = 5432;
export const updateDatasourceBodyDwhPortMin = 1024;

export const updateDatasourceBodyDwhPortMax = 65535;

export const updateDatasourceBody = zod.object({
	name: zod.string().or(zod.null()).optional(),
	dwh: zod
		.discriminatedUnion("driver", [
			zod.object({
				driver: zod.enum(["postgresql+psycopg", "postgresql+psycopg2"]),
				host: zod.string(),
				port: zod
					.number()
					.min(updateDatasourceBodyDwhPortMin)
					.max(updateDatasourceBodyDwhPortMax)
					.default(updateDatasourceBodyDwhPortDefault),
				user: zod.string(),
				password: zod.string(),
				dbname: zod.string(),
				sslmode: zod
					.enum([
						"disable",
						"allow",
						"prefer",
						"require",
						"verify-ca",
						"verify-full",
					])
					.or(zod.null())
					.optional(),
				search_path: zod.string().or(zod.null()).optional(),
			}),
			zod.object({
				driver: zod.enum(["bigquery"]),
				project_id: zod.string(),
				dataset_id: zod.string(),
				credentials: zod.discriminatedUnion("type", [
					zod.object({
						type: zod.enum(["serviceaccountinfo"]),
						content_base64: zod.string(),
					}),
					zod.object({
						type: zod.enum(["serviceaccountfile"]),
						path: zod.string(),
					}),
				]),
			}),
		])
		.or(zod.null())
		.optional(),
});

export const updateDatasourceResponse = zod.any();

/**
 * Returns detailed information about a specific datasource.
 * @summary Get Datasource
 */
export const getDatasourceParams = zod.object({
	datasource_id: zod.string(),
});

export const getDatasourceResponseConfigDwhPortDefault = 5432;
export const getDatasourceResponseConfigDwhPortMin = 1024;

export const getDatasourceResponseConfigDwhPortMax = 65535;

export const getDatasourceResponse = zod.object({
	id: zod.string(),
	name: zod.string(),
	config: zod.discriminatedUnion("type", [
		zod.object({
			participants: zod.array(
				zod.discriminatedUnion("type", [
					zod.object({
						participant_type: zod.string(),
						type: zod.enum(["sheet"]),
						table_name: zod.string(),
						sheet: zod.object({
							url: zod.string(),
							worksheet: zod.string(),
						}),
					}),
					zod.object({
						table_name: zod.string(),
						fields: zod.array(
							zod.object({
								field_name: zod.string(),
								data_type: zod.enum([
									"boolean",
									"character varying",
									"uuid",
									"date",
									"integer",
									"double precision",
									"numeric",
									"timestamp without time zone",
									"bigint",
								]),
								description: zod.string(),
								is_unique_id: zod.boolean(),
								is_strata: zod.boolean(),
								is_filter: zod.boolean(),
								is_metric: zod.boolean(),
								extra: zod
									.record(zod.string(), zod.string())
									.or(zod.null())
									.optional(),
							}),
						),
						participant_type: zod.string(),
						type: zod.enum(["schema"]),
					}),
				]),
			),
			webhook_config: zod
				.object({
					actions: zod.object({
						commit: zod
							.object({
								method: zod.enum(["GET", "POST", "PUT", "PATCH", "DELETE"]),
								url: zod.string(),
							})
							.or(zod.null())
							.optional(),
						assignment_file: zod
							.object({
								method: zod.enum(["GET", "POST", "PUT", "PATCH", "DELETE"]),
								url: zod.string(),
							})
							.or(zod.null())
							.optional(),
						update_timestamps: zod
							.object({
								method: zod.enum(["GET", "POST", "PUT", "PATCH", "DELETE"]),
								url: zod.string(),
							})
							.or(zod.null())
							.optional(),
						update_description: zod
							.object({
								method: zod.enum(["GET", "POST", "PUT", "PATCH", "DELETE"]),
								url: zod.string(),
							})
							.or(zod.null())
							.optional(),
					}),
					common_headers: zod.object({
						authorization: zod.string().or(zod.null()),
					}),
				})
				.or(zod.null())
				.optional(),
			type: zod.enum(["remote"]),
			dwh: zod.discriminatedUnion("driver", [
				zod.object({
					driver: zod.enum(["postgresql+psycopg", "postgresql+psycopg2"]),
					host: zod.string(),
					port: zod
						.number()
						.min(getDatasourceResponseConfigDwhPortMin)
						.max(getDatasourceResponseConfigDwhPortMax)
						.default(getDatasourceResponseConfigDwhPortDefault),
					user: zod.string(),
					password: zod.string(),
					dbname: zod.string(),
					sslmode: zod
						.enum([
							"disable",
							"allow",
							"prefer",
							"require",
							"verify-ca",
							"verify-full",
						])
						.or(zod.null())
						.optional(),
					search_path: zod.string().or(zod.null()).optional(),
				}),
				zod.object({
					driver: zod.enum(["bigquery"]),
					project_id: zod.string(),
					dataset_id: zod.string(),
					credentials: zod.discriminatedUnion("type", [
						zod.object({
							type: zod.enum(["serviceaccountinfo"]),
							content_base64: zod.string(),
						}),
						zod.object({
							type: zod.enum(["serviceaccountfile"]),
							path: zod.string(),
						}),
					]),
				}),
			]),
		}),
		zod.object({
			participants: zod.array(
				zod.discriminatedUnion("type", [
					zod.object({
						participant_type: zod.string(),
						type: zod.enum(["sheet"]),
						table_name: zod.string(),
						sheet: zod.object({
							url: zod.string(),
							worksheet: zod.string(),
						}),
					}),
					zod.object({
						table_name: zod.string(),
						fields: zod.array(
							zod.object({
								field_name: zod.string(),
								data_type: zod.enum([
									"boolean",
									"character varying",
									"uuid",
									"date",
									"integer",
									"double precision",
									"numeric",
									"timestamp without time zone",
									"bigint",
								]),
								description: zod.string(),
								is_unique_id: zod.boolean(),
								is_strata: zod.boolean(),
								is_filter: zod.boolean(),
								is_metric: zod.boolean(),
								extra: zod
									.record(zod.string(), zod.string())
									.or(zod.null())
									.optional(),
							}),
						),
						participant_type: zod.string(),
						type: zod.enum(["schema"]),
					}),
				]),
			),
			type: zod.enum(["sqlite_local"]),
			sqlite_filename: zod.string(),
		}),
	]),
	organization_id: zod.string(),
	organization_name: zod.string(),
});

/**
 * Deletes a datasource.

The user must be a member of the organization that owns the datasource.
 * @summary Delete Datasource
 */
export const deleteDatasourceParams = zod.object({
	datasource_id: zod.string(),
});

/**
 * Verifies connectivity to a datasource and returns a list of readable tables.
 * @summary Inspect Datasource
 */
export const inspectDatasourceParams = zod.object({
	datasource_id: zod.string(),
});

export const inspectDatasourceQueryRefreshDefault = false;

export const inspectDatasourceQueryParams = zod.object({
	refresh: zod.boolean().optional(),
});

export const inspectDatasourceResponse = zod.object({
	tables: zod.array(zod.string()),
});

/**
 * Inspects a single table in a datasource and returns a summary of its fields.
 * @summary Inspect Table In Datasource
 */
export const inspectTableInDatasourceParams = zod.object({
	datasource_id: zod.string(),
	table_name: zod.string(),
});

export const inspectTableInDatasourceQueryRefreshDefault = false;

export const inspectTableInDatasourceQueryParams = zod.object({
	refresh: zod.boolean().optional(),
});

export const inspectTableInDatasourceResponse = zod.object({
	detected_unique_id_fields: zod.array(zod.string()),
	fields: zod.array(
		zod.object({
			field_name: zod.string(),
			data_type: zod.enum([
				"boolean",
				"character varying",
				"uuid",
				"date",
				"integer",
				"double precision",
				"numeric",
				"timestamp without time zone",
				"bigint",
			]),
			description: zod.string(),
		}),
	),
});

/**
 * @summary List Participant Types
 */
export const listParticipantTypesParams = zod.object({
	datasource_id: zod.string(),
});

export const listParticipantTypesResponse = zod.object({
	items: zod.array(
		zod.discriminatedUnion("type", [
			zod.object({
				participant_type: zod.string(),
				type: zod.enum(["sheet"]),
				table_name: zod.string(),
				sheet: zod.object({
					url: zod.string(),
					worksheet: zod.string(),
				}),
			}),
			zod.object({
				table_name: zod.string(),
				fields: zod.array(
					zod.object({
						field_name: zod.string(),
						data_type: zod.enum([
							"boolean",
							"character varying",
							"uuid",
							"date",
							"integer",
							"double precision",
							"numeric",
							"timestamp without time zone",
							"bigint",
						]),
						description: zod.string(),
						is_unique_id: zod.boolean(),
						is_strata: zod.boolean(),
						is_filter: zod.boolean(),
						is_metric: zod.boolean(),
						extra: zod
							.record(zod.string(), zod.string())
							.or(zod.null())
							.optional(),
					}),
				),
				participant_type: zod.string(),
				type: zod.enum(["schema"]),
			}),
		]),
	),
});

/**
 * @summary Create Participant Type
 */
export const createParticipantTypeParams = zod.object({
	datasource_id: zod.string(),
});

export const createParticipantTypeBody = zod.object({
	participant_type: zod.string(),
	schema_def: zod.object({
		table_name: zod.string(),
		fields: zod.array(
			zod.object({
				field_name: zod.string(),
				data_type: zod.enum([
					"boolean",
					"character varying",
					"uuid",
					"date",
					"integer",
					"double precision",
					"numeric",
					"timestamp without time zone",
					"bigint",
				]),
				description: zod.string(),
				is_unique_id: zod.boolean(),
				is_strata: zod.boolean(),
				is_filter: zod.boolean(),
				is_metric: zod.boolean(),
				extra: zod.record(zod.string(), zod.string()).or(zod.null()).optional(),
			}),
		),
	}),
});

export const createParticipantTypeResponse = zod.object({
	participant_type: zod.string(),
	schema_def: zod.object({
		table_name: zod.string(),
		fields: zod.array(
			zod.object({
				field_name: zod.string(),
				data_type: zod.enum([
					"boolean",
					"character varying",
					"uuid",
					"date",
					"integer",
					"double precision",
					"numeric",
					"timestamp without time zone",
					"bigint",
				]),
				description: zod.string(),
				is_unique_id: zod.boolean(),
				is_strata: zod.boolean(),
				is_filter: zod.boolean(),
				is_metric: zod.boolean(),
				extra: zod.record(zod.string(), zod.string()).or(zod.null()).optional(),
			}),
		),
	}),
});

/**
 * Returns filter, strata, and metric field metadata for a participant type, including exemplars for filter fields.
 * @summary Inspect Participant Types
 */
export const inspectParticipantTypesParams = zod.object({
	datasource_id: zod.string(),
	participant_id: zod.string(),
});

export const inspectParticipantTypesQueryRefreshDefault = false;

export const inspectParticipantTypesQueryParams = zod.object({
	refresh: zod.boolean().optional(),
});

export const inspectParticipantTypesResponseFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectParticipantTypesResponseFiltersItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectParticipantTypesResponseMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectParticipantTypesResponseStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");

export const inspectParticipantTypesResponse = zod.object({
	filters: zod.array(
		zod
			.object({
				field_name: zod
					.string()
					.regex(inspectParticipantTypesResponseFiltersItemFieldNameRegExp),
				data_type: zod.enum([
					"boolean",
					"character varying",
					"uuid",
					"date",
					"integer",
					"double precision",
					"numeric",
					"timestamp without time zone",
					"bigint",
				]),
				relations: zod
					.array(zod.enum(["includes", "excludes", "between"]))
					.min(1),
				description: zod.string(),
				min: zod
					.string()
					.datetime()
					.or(zod.string().date())
					.or(zod.number())
					.or(zod.number())
					.or(zod.null()),
				max: zod
					.string()
					.datetime()
					.or(zod.string().date())
					.or(zod.number())
					.or(zod.number())
					.or(zod.null()),
			})
			.or(
				zod.object({
					field_name: zod
						.string()
						.regex(
							inspectParticipantTypesResponseFiltersItemFieldNameRegExpOne,
						),
					data_type: zod.enum([
						"boolean",
						"character varying",
						"uuid",
						"date",
						"integer",
						"double precision",
						"numeric",
						"timestamp without time zone",
						"bigint",
					]),
					relations: zod
						.array(zod.enum(["includes", "excludes", "between"]))
						.min(1),
					description: zod.string(),
					distinct_values: zod.array(zod.string()).or(zod.null()),
				}),
			),
	),
	metrics: zod.array(
		zod.object({
			field_name: zod
				.string()
				.regex(inspectParticipantTypesResponseMetricsItemFieldNameRegExp),
			data_type: zod.enum([
				"boolean",
				"character varying",
				"uuid",
				"date",
				"integer",
				"double precision",
				"numeric",
				"timestamp without time zone",
				"bigint",
			]),
			description: zod.string(),
		}),
	),
	strata: zod.array(
		zod.object({
			data_type: zod.enum([
				"boolean",
				"character varying",
				"uuid",
				"date",
				"integer",
				"double precision",
				"numeric",
				"timestamp without time zone",
				"bigint",
			]),
			field_name: zod
				.string()
				.regex(inspectParticipantTypesResponseStrataItemFieldNameRegExp),
			description: zod.string(),
			extra: zod.record(zod.string(), zod.string()).or(zod.null()).optional(),
		}),
	),
});

/**
 * @summary Get Participant Types
 */
export const getParticipantTypesParams = zod.object({
	datasource_id: zod.string(),
	participant_id: zod.string(),
});

export const getParticipantTypesResponse = zod.discriminatedUnion("type", [
	zod.object({
		participant_type: zod.string(),
		type: zod.enum(["sheet"]),
		table_name: zod.string(),
		sheet: zod.object({
			url: zod.string(),
			worksheet: zod.string(),
		}),
	}),
	zod.object({
		table_name: zod.string(),
		fields: zod.array(
			zod.object({
				field_name: zod.string(),
				data_type: zod.enum([
					"boolean",
					"character varying",
					"uuid",
					"date",
					"integer",
					"double precision",
					"numeric",
					"timestamp without time zone",
					"bigint",
				]),
				description: zod.string(),
				is_unique_id: zod.boolean(),
				is_strata: zod.boolean(),
				is_filter: zod.boolean(),
				is_metric: zod.boolean(),
				extra: zod.record(zod.string(), zod.string()).or(zod.null()).optional(),
			}),
		),
		participant_type: zod.string(),
		type: zod.enum(["schema"]),
	}),
]);

/**
 * @summary Update Participant Type
 */
export const updateParticipantTypeParams = zod.object({
	datasource_id: zod.string(),
	participant_id: zod.string(),
});

export const updateParticipantTypeBody = zod.object({
	participant_type: zod.string().or(zod.null()).optional(),
	table_name: zod.string().or(zod.null()).optional(),
	fields: zod
		.array(
			zod.object({
				field_name: zod.string(),
				data_type: zod.enum([
					"boolean",
					"character varying",
					"uuid",
					"date",
					"integer",
					"double precision",
					"numeric",
					"timestamp without time zone",
					"bigint",
				]),
				description: zod.string(),
				is_unique_id: zod.boolean(),
				is_strata: zod.boolean(),
				is_filter: zod.boolean(),
				is_metric: zod.boolean(),
				extra: zod.record(zod.string(), zod.string()).or(zod.null()).optional(),
			}),
		)
		.or(zod.null())
		.optional(),
});

export const updateParticipantTypeResponse = zod.object({
	participant_type: zod.string(),
	table_name: zod.string(),
	fields: zod.array(
		zod.object({
			field_name: zod.string(),
			data_type: zod.enum([
				"boolean",
				"character varying",
				"uuid",
				"date",
				"integer",
				"double precision",
				"numeric",
				"timestamp without time zone",
				"bigint",
			]),
			description: zod.string(),
			is_unique_id: zod.boolean(),
			is_strata: zod.boolean(),
			is_filter: zod.boolean(),
			is_metric: zod.boolean(),
			extra: zod.record(zod.string(), zod.string()).or(zod.null()).optional(),
		}),
	),
});

/**
 * @summary Delete Participant
 */
export const deleteParticipantParams = zod.object({
	datasource_id: zod.string(),
	participant_id: zod.string(),
});

/**
 * Returns API keys that the caller has access to via their organization memberships.

An API key is visible if the user belongs to the organization that owns any of the
datasources that the API key can access.
 * @summary List Api Keys
 */
export const listApiKeysResponse = zod.object({
	items: zod.array(
		zod.object({
			id: zod.string(),
			datasource_id: zod.string(),
			organization_id: zod.string(),
			organization_name: zod.string(),
		}),
	),
});

/**
 * Creates an API key for the specified datasource.

The user must belong to the organization that owns the requested datasource.
 * @summary Create Api Key
 */
export const createApiKeyBody = zod.object({
	datasource_id: zod.string(),
});

export const createApiKeyResponse = zod.object({
	id: zod.string(),
	datasource_id: zod.string(),
	key: zod.string(),
});

/**
 * Deletes the specified API key.
 * @summary Delete Api Key
 */
export const deleteApiKeyParams = zod.object({
	api_key_id: zod.string(),
});

/**
 * @summary Create Experiment With Assignment
 */
export const createExperimentWithAssignmentParams = zod.object({
	datasource_id: zod.string(),
});

export const createExperimentWithAssignmentQueryParams = zod.object({
	chosen_n: zod.number(),
});

export const createExperimentWithAssignmentBodyDesignSpecArmsMin = 2;
export const createExperimentWithAssignmentBodyDesignSpecStrataFieldNamesItemRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentWithAssignmentBodyDesignSpecMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentWithAssignmentBodyDesignSpecPowerDefault = 0.8;
export const createExperimentWithAssignmentBodyDesignSpecPowerMin = 0;

export const createExperimentWithAssignmentBodyDesignSpecPowerMax = 1;
export const createExperimentWithAssignmentBodyDesignSpecAlphaDefault = 0.05;
export const createExperimentWithAssignmentBodyDesignSpecAlphaMin = 0;

export const createExperimentWithAssignmentBodyDesignSpecAlphaMax = 1;
export const createExperimentWithAssignmentBodyDesignSpecFstatThreshDefault = 0.6;
export const createExperimentWithAssignmentBodyDesignSpecFstatThreshMin = 0;

export const createExperimentWithAssignmentBodyDesignSpecFstatThreshMax = 1;
export const createExperimentWithAssignmentBodyAudienceSpecFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentWithAssignmentBodyPowerAnalysesAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");

export const createExperimentWithAssignmentBody = zod.object({
	design_spec: zod.object({
		experiment_id: zod.string().uuid().or(zod.null()),
		experiment_name: zod.string(),
		description: zod.string(),
		start_date: zod.string().datetime(),
		end_date: zod.string().datetime(),
		arms: zod
			.array(
				zod.object({
					arm_id: zod.string().uuid().or(zod.null()),
					arm_name: zod.string(),
					arm_description: zod.string().or(zod.null()).optional(),
				}),
			)
			.min(createExperimentWithAssignmentBodyDesignSpecArmsMin),
		strata_field_names: zod.array(
			zod
				.string()
				.regex(
					createExperimentWithAssignmentBodyDesignSpecStrataFieldNamesItemRegExp,
				),
		),
		metrics: zod
			.array(
				zod.object({
					field_name: zod
						.string()
						.regex(
							createExperimentWithAssignmentBodyDesignSpecMetricsItemFieldNameRegExp,
						),
					metric_pct_change: zod.number().or(zod.null()).optional(),
					metric_target: zod.number().or(zod.null()).optional(),
				}),
			)
			.min(1),
		power: zod
			.number()
			.min(createExperimentWithAssignmentBodyDesignSpecPowerMin)
			.max(createExperimentWithAssignmentBodyDesignSpecPowerMax)
			.default(createExperimentWithAssignmentBodyDesignSpecPowerDefault),
		alpha: zod
			.number()
			.min(createExperimentWithAssignmentBodyDesignSpecAlphaMin)
			.max(createExperimentWithAssignmentBodyDesignSpecAlphaMax)
			.default(createExperimentWithAssignmentBodyDesignSpecAlphaDefault),
		fstat_thresh: zod
			.number()
			.min(createExperimentWithAssignmentBodyDesignSpecFstatThreshMin)
			.max(createExperimentWithAssignmentBodyDesignSpecFstatThreshMax)
			.default(createExperimentWithAssignmentBodyDesignSpecFstatThreshDefault),
	}),
	audience_spec: zod.object({
		participant_type: zod.string(),
		filters: zod.array(
			zod.object({
				field_name: zod
					.string()
					.regex(
						createExperimentWithAssignmentBodyAudienceSpecFiltersItemFieldNameRegExp,
					),
				relation: zod.enum(["includes", "excludes", "between"]),
				value: zod
					.array(zod.number().or(zod.null()))
					.or(zod.array(zod.number().or(zod.null())))
					.or(zod.array(zod.string().or(zod.null())))
					.or(zod.array(zod.boolean().or(zod.null()))),
			}),
		),
	}),
	power_analyses: zod
		.object({
			analyses: zod.array(
				zod.object({
					metric_spec: zod.object({
						field_name: zod
							.string()
							.regex(
								createExperimentWithAssignmentBodyPowerAnalysesAnalysesItemMetricSpecFieldNameRegExp,
							),
						metric_pct_change: zod.number().or(zod.null()).optional(),
						metric_target: zod.number().or(zod.null()).optional(),
						metric_type: zod
							.enum(["binary", "numeric"])
							.or(zod.null())
							.optional(),
						metric_baseline: zod.number().or(zod.null()).optional(),
						metric_stddev: zod.number().or(zod.null()).optional(),
						available_nonnull_n: zod.number().or(zod.null()).optional(),
						available_n: zod.number().or(zod.null()).optional(),
					}),
					target_n: zod.number().or(zod.null()).optional(),
					sufficient_n: zod.boolean().or(zod.null()).optional(),
					target_possible: zod.number().or(zod.null()).optional(),
					pct_change_possible: zod.number().or(zod.null()).optional(),
					msg: zod
						.object({
							type: zod.enum(["sufficient", "insufficient", "no baseline"]),
							msg: zod.string(),
							source_msg: zod.string(),
							values: zod
								.record(zod.string(), zod.number().or(zod.number()))
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
				}),
			),
		})
		.or(zod.null())
		.optional(),
});

export const createExperimentWithAssignmentResponseDesignSpecArmsMin = 2;
export const createExperimentWithAssignmentResponseDesignSpecStrataFieldNamesItemRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentWithAssignmentResponseDesignSpecMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentWithAssignmentResponseDesignSpecPowerDefault = 0.8;
export const createExperimentWithAssignmentResponseDesignSpecPowerMin = 0;

export const createExperimentWithAssignmentResponseDesignSpecPowerMax = 1;
export const createExperimentWithAssignmentResponseDesignSpecAlphaDefault = 0.05;
export const createExperimentWithAssignmentResponseDesignSpecAlphaMin = 0;

export const createExperimentWithAssignmentResponseDesignSpecAlphaMax = 1;
export const createExperimentWithAssignmentResponseDesignSpecFstatThreshDefault = 0.6;
export const createExperimentWithAssignmentResponseDesignSpecFstatThreshMin = 0;

export const createExperimentWithAssignmentResponseDesignSpecFstatThreshMax = 1;
export const createExperimentWithAssignmentResponseAudienceSpecFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentWithAssignmentResponsePowerAnalysesAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");

export const createExperimentWithAssignmentResponse = zod.object({
	datasource_id: zod.string(),
	state: zod.enum([
		"designing",
		"assigned",
		"abandoned",
		"committed",
		"aborted",
	]),
	design_spec: zod.object({
		experiment_id: zod.string().uuid().or(zod.null()),
		experiment_name: zod.string(),
		description: zod.string(),
		start_date: zod.string().datetime(),
		end_date: zod.string().datetime(),
		arms: zod
			.array(
				zod.object({
					arm_id: zod.string().uuid().or(zod.null()),
					arm_name: zod.string(),
					arm_description: zod.string().or(zod.null()).optional(),
				}),
			)
			.min(createExperimentWithAssignmentResponseDesignSpecArmsMin),
		strata_field_names: zod.array(
			zod
				.string()
				.regex(
					createExperimentWithAssignmentResponseDesignSpecStrataFieldNamesItemRegExp,
				),
		),
		metrics: zod
			.array(
				zod.object({
					field_name: zod
						.string()
						.regex(
							createExperimentWithAssignmentResponseDesignSpecMetricsItemFieldNameRegExp,
						),
					metric_pct_change: zod.number().or(zod.null()).optional(),
					metric_target: zod.number().or(zod.null()).optional(),
				}),
			)
			.min(1),
		power: zod
			.number()
			.min(createExperimentWithAssignmentResponseDesignSpecPowerMin)
			.max(createExperimentWithAssignmentResponseDesignSpecPowerMax)
			.default(createExperimentWithAssignmentResponseDesignSpecPowerDefault),
		alpha: zod
			.number()
			.min(createExperimentWithAssignmentResponseDesignSpecAlphaMin)
			.max(createExperimentWithAssignmentResponseDesignSpecAlphaMax)
			.default(createExperimentWithAssignmentResponseDesignSpecAlphaDefault),
		fstat_thresh: zod
			.number()
			.min(createExperimentWithAssignmentResponseDesignSpecFstatThreshMin)
			.max(createExperimentWithAssignmentResponseDesignSpecFstatThreshMax)
			.default(
				createExperimentWithAssignmentResponseDesignSpecFstatThreshDefault,
			),
	}),
	audience_spec: zod.object({
		participant_type: zod.string(),
		filters: zod.array(
			zod.object({
				field_name: zod
					.string()
					.regex(
						createExperimentWithAssignmentResponseAudienceSpecFiltersItemFieldNameRegExp,
					),
				relation: zod.enum(["includes", "excludes", "between"]),
				value: zod
					.array(zod.number().or(zod.null()))
					.or(zod.array(zod.number().or(zod.null())))
					.or(zod.array(zod.string().or(zod.null())))
					.or(zod.array(zod.boolean().or(zod.null()))),
			}),
		),
	}),
	power_analyses: zod
		.object({
			analyses: zod.array(
				zod.object({
					metric_spec: zod.object({
						field_name: zod
							.string()
							.regex(
								createExperimentWithAssignmentResponsePowerAnalysesAnalysesItemMetricSpecFieldNameRegExp,
							),
						metric_pct_change: zod.number().or(zod.null()).optional(),
						metric_target: zod.number().or(zod.null()).optional(),
						metric_type: zod
							.enum(["binary", "numeric"])
							.or(zod.null())
							.optional(),
						metric_baseline: zod.number().or(zod.null()).optional(),
						metric_stddev: zod.number().or(zod.null()).optional(),
						available_nonnull_n: zod.number().or(zod.null()).optional(),
						available_n: zod.number().or(zod.null()).optional(),
					}),
					target_n: zod.number().or(zod.null()).optional(),
					sufficient_n: zod.boolean().or(zod.null()).optional(),
					target_possible: zod.number().or(zod.null()).optional(),
					pct_change_possible: zod.number().or(zod.null()).optional(),
					msg: zod
						.object({
							type: zod.enum(["sufficient", "insufficient", "no baseline"]),
							msg: zod.string(),
							source_msg: zod.string(),
							values: zod
								.record(zod.string(), zod.number().or(zod.number()))
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
				}),
			),
		})
		.or(zod.null()),
	assign_summary: zod.object({
		balance_check: zod.object({
			f_statistic: zod.number(),
			numerator_df: zod.number(),
			denominator_df: zod.number(),
			p_value: zod.number(),
			balance_ok: zod.boolean(),
		}),
		sample_size: zod.number(),
	}),
});

/**
 * @summary Commit Experiment
 */
export const commitExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

/**
 * @summary Abandon Experiment
 */
export const abandonExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

/**
 * Returns the list of experiments in the datasource.
 * @summary List Experiments
 */
export const listExperimentsParams = zod.object({
	datasource_id: zod.string(),
});

export const listExperimentsResponseItemsItemDesignSpecArmsMin = 2;
export const listExperimentsResponseItemsItemDesignSpecStrataFieldNamesItemRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listExperimentsResponseItemsItemDesignSpecMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listExperimentsResponseItemsItemDesignSpecPowerDefault = 0.8;
export const listExperimentsResponseItemsItemDesignSpecPowerMin = 0;

export const listExperimentsResponseItemsItemDesignSpecPowerMax = 1;
export const listExperimentsResponseItemsItemDesignSpecAlphaDefault = 0.05;
export const listExperimentsResponseItemsItemDesignSpecAlphaMin = 0;

export const listExperimentsResponseItemsItemDesignSpecAlphaMax = 1;
export const listExperimentsResponseItemsItemDesignSpecFstatThreshDefault = 0.6;
export const listExperimentsResponseItemsItemDesignSpecFstatThreshMin = 0;

export const listExperimentsResponseItemsItemDesignSpecFstatThreshMax = 1;
export const listExperimentsResponseItemsItemAudienceSpecFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listExperimentsResponseItemsItemPowerAnalysesAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");

export const listExperimentsResponse = zod.object({
	items: zod.array(
		zod.object({
			datasource_id: zod.string(),
			state: zod.enum([
				"designing",
				"assigned",
				"abandoned",
				"committed",
				"aborted",
			]),
			design_spec: zod.object({
				experiment_id: zod.string().uuid().or(zod.null()),
				experiment_name: zod.string(),
				description: zod.string(),
				start_date: zod.string().datetime(),
				end_date: zod.string().datetime(),
				arms: zod
					.array(
						zod.object({
							arm_id: zod.string().uuid().or(zod.null()),
							arm_name: zod.string(),
							arm_description: zod.string().or(zod.null()).optional(),
						}),
					)
					.min(listExperimentsResponseItemsItemDesignSpecArmsMin),
				strata_field_names: zod.array(
					zod
						.string()
						.regex(
							listExperimentsResponseItemsItemDesignSpecStrataFieldNamesItemRegExp,
						),
				),
				metrics: zod
					.array(
						zod.object({
							field_name: zod
								.string()
								.regex(
									listExperimentsResponseItemsItemDesignSpecMetricsItemFieldNameRegExp,
								),
							metric_pct_change: zod.number().or(zod.null()).optional(),
							metric_target: zod.number().or(zod.null()).optional(),
						}),
					)
					.min(1),
				power: zod
					.number()
					.min(listExperimentsResponseItemsItemDesignSpecPowerMin)
					.max(listExperimentsResponseItemsItemDesignSpecPowerMax)
					.default(listExperimentsResponseItemsItemDesignSpecPowerDefault),
				alpha: zod
					.number()
					.min(listExperimentsResponseItemsItemDesignSpecAlphaMin)
					.max(listExperimentsResponseItemsItemDesignSpecAlphaMax)
					.default(listExperimentsResponseItemsItemDesignSpecAlphaDefault),
				fstat_thresh: zod
					.number()
					.min(listExperimentsResponseItemsItemDesignSpecFstatThreshMin)
					.max(listExperimentsResponseItemsItemDesignSpecFstatThreshMax)
					.default(
						listExperimentsResponseItemsItemDesignSpecFstatThreshDefault,
					),
			}),
			audience_spec: zod.object({
				participant_type: zod.string(),
				filters: zod.array(
					zod.object({
						field_name: zod
							.string()
							.regex(
								listExperimentsResponseItemsItemAudienceSpecFiltersItemFieldNameRegExp,
							),
						relation: zod.enum(["includes", "excludes", "between"]),
						value: zod
							.array(zod.number().or(zod.null()))
							.or(zod.array(zod.number().or(zod.null())))
							.or(zod.array(zod.string().or(zod.null())))
							.or(zod.array(zod.boolean().or(zod.null()))),
					}),
				),
			}),
			power_analyses: zod
				.object({
					analyses: zod.array(
						zod.object({
							metric_spec: zod.object({
								field_name: zod
									.string()
									.regex(
										listExperimentsResponseItemsItemPowerAnalysesAnalysesItemMetricSpecFieldNameRegExp,
									),
								metric_pct_change: zod.number().or(zod.null()).optional(),
								metric_target: zod.number().or(zod.null()).optional(),
								metric_type: zod
									.enum(["binary", "numeric"])
									.or(zod.null())
									.optional(),
								metric_baseline: zod.number().or(zod.null()).optional(),
								metric_stddev: zod.number().or(zod.null()).optional(),
								available_nonnull_n: zod.number().or(zod.null()).optional(),
								available_n: zod.number().or(zod.null()).optional(),
							}),
							target_n: zod.number().or(zod.null()).optional(),
							sufficient_n: zod.boolean().or(zod.null()).optional(),
							target_possible: zod.number().or(zod.null()).optional(),
							pct_change_possible: zod.number().or(zod.null()).optional(),
							msg: zod
								.object({
									type: zod.enum(["sufficient", "insufficient", "no baseline"]),
									msg: zod.string(),
									source_msg: zod.string(),
									values: zod
										.record(zod.string(), zod.number().or(zod.number()))
										.or(zod.null())
										.optional(),
								})
								.or(zod.null())
								.optional(),
						}),
					),
				})
				.or(zod.null()),
			assign_summary: zod.object({
				balance_check: zod.object({
					f_statistic: zod.number(),
					numerator_df: zod.number(),
					denominator_df: zod.number(),
					p_value: zod.number(),
					balance_ok: zod.boolean(),
				}),
				sample_size: zod.number(),
			}),
		}),
	),
});

/**
 * Returns the experiment with the specified ID.
 * @summary Get Experiment
 */
export const getExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const getExperimentResponseDesignSpecArmsMin = 2;
export const getExperimentResponseDesignSpecStrataFieldNamesItemRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentResponseDesignSpecMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentResponseDesignSpecPowerDefault = 0.8;
export const getExperimentResponseDesignSpecPowerMin = 0;

export const getExperimentResponseDesignSpecPowerMax = 1;
export const getExperimentResponseDesignSpecAlphaDefault = 0.05;
export const getExperimentResponseDesignSpecAlphaMin = 0;

export const getExperimentResponseDesignSpecAlphaMax = 1;
export const getExperimentResponseDesignSpecFstatThreshDefault = 0.6;
export const getExperimentResponseDesignSpecFstatThreshMin = 0;

export const getExperimentResponseDesignSpecFstatThreshMax = 1;
export const getExperimentResponseAudienceSpecFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentResponsePowerAnalysesAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");

export const getExperimentResponse = zod.object({
	datasource_id: zod.string(),
	state: zod.enum([
		"designing",
		"assigned",
		"abandoned",
		"committed",
		"aborted",
	]),
	design_spec: zod.object({
		experiment_id: zod.string().uuid().or(zod.null()),
		experiment_name: zod.string(),
		description: zod.string(),
		start_date: zod.string().datetime(),
		end_date: zod.string().datetime(),
		arms: zod
			.array(
				zod.object({
					arm_id: zod.string().uuid().or(zod.null()),
					arm_name: zod.string(),
					arm_description: zod.string().or(zod.null()).optional(),
				}),
			)
			.min(getExperimentResponseDesignSpecArmsMin),
		strata_field_names: zod.array(
			zod
				.string()
				.regex(getExperimentResponseDesignSpecStrataFieldNamesItemRegExp),
		),
		metrics: zod
			.array(
				zod.object({
					field_name: zod
						.string()
						.regex(getExperimentResponseDesignSpecMetricsItemFieldNameRegExp),
					metric_pct_change: zod.number().or(zod.null()).optional(),
					metric_target: zod.number().or(zod.null()).optional(),
				}),
			)
			.min(1),
		power: zod
			.number()
			.min(getExperimentResponseDesignSpecPowerMin)
			.max(getExperimentResponseDesignSpecPowerMax)
			.default(getExperimentResponseDesignSpecPowerDefault),
		alpha: zod
			.number()
			.min(getExperimentResponseDesignSpecAlphaMin)
			.max(getExperimentResponseDesignSpecAlphaMax)
			.default(getExperimentResponseDesignSpecAlphaDefault),
		fstat_thresh: zod
			.number()
			.min(getExperimentResponseDesignSpecFstatThreshMin)
			.max(getExperimentResponseDesignSpecFstatThreshMax)
			.default(getExperimentResponseDesignSpecFstatThreshDefault),
	}),
	audience_spec: zod.object({
		participant_type: zod.string(),
		filters: zod.array(
			zod.object({
				field_name: zod
					.string()
					.regex(getExperimentResponseAudienceSpecFiltersItemFieldNameRegExp),
				relation: zod.enum(["includes", "excludes", "between"]),
				value: zod
					.array(zod.number().or(zod.null()))
					.or(zod.array(zod.number().or(zod.null())))
					.or(zod.array(zod.string().or(zod.null())))
					.or(zod.array(zod.boolean().or(zod.null()))),
			}),
		),
	}),
	power_analyses: zod
		.object({
			analyses: zod.array(
				zod.object({
					metric_spec: zod.object({
						field_name: zod
							.string()
							.regex(
								getExperimentResponsePowerAnalysesAnalysesItemMetricSpecFieldNameRegExp,
							),
						metric_pct_change: zod.number().or(zod.null()).optional(),
						metric_target: zod.number().or(zod.null()).optional(),
						metric_type: zod
							.enum(["binary", "numeric"])
							.or(zod.null())
							.optional(),
						metric_baseline: zod.number().or(zod.null()).optional(),
						metric_stddev: zod.number().or(zod.null()).optional(),
						available_nonnull_n: zod.number().or(zod.null()).optional(),
						available_n: zod.number().or(zod.null()).optional(),
					}),
					target_n: zod.number().or(zod.null()).optional(),
					sufficient_n: zod.boolean().or(zod.null()).optional(),
					target_possible: zod.number().or(zod.null()).optional(),
					pct_change_possible: zod.number().or(zod.null()).optional(),
					msg: zod
						.object({
							type: zod.enum(["sufficient", "insufficient", "no baseline"]),
							msg: zod.string(),
							source_msg: zod.string(),
							values: zod
								.record(zod.string(), zod.number().or(zod.number()))
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
				}),
			),
		})
		.or(zod.null()),
	assign_summary: zod.object({
		balance_check: zod.object({
			f_statistic: zod.number(),
			numerator_df: zod.number(),
			denominator_df: zod.number(),
			p_value: zod.number(),
			balance_ok: zod.boolean(),
		}),
		sample_size: zod.number(),
	}),
});

/**
 * Deletes the experiment with the specified ID.
 * @summary Delete Experiment
 */
export const deleteExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

/**
 * @summary Get Experiment Assignments
 */
export const getExperimentAssignmentsParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const getExperimentAssignmentsResponseAssignmentsItemStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");

export const getExperimentAssignmentsResponse = zod.object({
	balance_check: zod.object({
		f_statistic: zod.number(),
		numerator_df: zod.number(),
		denominator_df: zod.number(),
		p_value: zod.number(),
		balance_ok: zod.boolean(),
	}),
	experiment_id: zod.string().uuid(),
	sample_size: zod.number(),
	assignments: zod.array(
		zod.object({
			participant_id: zod.string(),
			arm_id: zod.string().uuid(),
			arm_name: zod.string(),
			strata: zod.array(
				zod.object({
					field_name: zod
						.string()
						.regex(
							getExperimentAssignmentsResponseAssignmentsItemStrataItemFieldNameRegExp,
						),
					strata_value: zod.string().or(zod.null()).optional(),
				}),
			),
		}),
	),
});

/**
 * @summary Power Check
 */
export const powerCheckParams = zod.object({
	datasource_id: zod.string(),
});

export const powerCheckBodyDesignSpecArmsMin = 2;
export const powerCheckBodyDesignSpecStrataFieldNamesItemRegExp = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecMetricsItemFieldNameRegExp = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecPowerDefault = 0.8;
export const powerCheckBodyDesignSpecPowerMin = 0;

export const powerCheckBodyDesignSpecPowerMax = 1;
export const powerCheckBodyDesignSpecAlphaDefault = 0.05;
export const powerCheckBodyDesignSpecAlphaMin = 0;

export const powerCheckBodyDesignSpecAlphaMax = 1;
export const powerCheckBodyDesignSpecFstatThreshDefault = 0.6;
export const powerCheckBodyDesignSpecFstatThreshMin = 0;

export const powerCheckBodyDesignSpecFstatThreshMax = 1;
export const powerCheckBodyAudienceSpecFiltersItemFieldNameRegExp = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);

export const powerCheckBody = zod.object({
	design_spec: zod.object({
		experiment_id: zod.string().uuid().or(zod.null()),
		experiment_name: zod.string(),
		description: zod.string(),
		start_date: zod.string().datetime(),
		end_date: zod.string().datetime(),
		arms: zod
			.array(
				zod.object({
					arm_id: zod.string().uuid().or(zod.null()),
					arm_name: zod.string(),
					arm_description: zod.string().or(zod.null()).optional(),
				}),
			)
			.min(powerCheckBodyDesignSpecArmsMin),
		strata_field_names: zod.array(
			zod.string().regex(powerCheckBodyDesignSpecStrataFieldNamesItemRegExp),
		),
		metrics: zod
			.array(
				zod.object({
					field_name: zod
						.string()
						.regex(powerCheckBodyDesignSpecMetricsItemFieldNameRegExp),
					metric_pct_change: zod.number().or(zod.null()).optional(),
					metric_target: zod.number().or(zod.null()).optional(),
				}),
			)
			.min(1),
		power: zod
			.number()
			.min(powerCheckBodyDesignSpecPowerMin)
			.max(powerCheckBodyDesignSpecPowerMax)
			.default(powerCheckBodyDesignSpecPowerDefault),
		alpha: zod
			.number()
			.min(powerCheckBodyDesignSpecAlphaMin)
			.max(powerCheckBodyDesignSpecAlphaMax)
			.default(powerCheckBodyDesignSpecAlphaDefault),
		fstat_thresh: zod
			.number()
			.min(powerCheckBodyDesignSpecFstatThreshMin)
			.max(powerCheckBodyDesignSpecFstatThreshMax)
			.default(powerCheckBodyDesignSpecFstatThreshDefault),
	}),
	audience_spec: zod.object({
		participant_type: zod.string(),
		filters: zod.array(
			zod.object({
				field_name: zod
					.string()
					.regex(powerCheckBodyAudienceSpecFiltersItemFieldNameRegExp),
				relation: zod.enum(["includes", "excludes", "between"]),
				value: zod
					.array(zod.number().or(zod.null()))
					.or(zod.array(zod.number().or(zod.null())))
					.or(zod.array(zod.string().or(zod.null())))
					.or(zod.array(zod.boolean().or(zod.null()))),
			}),
		),
	}),
});

export const powerCheckResponseAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");

export const powerCheckResponse = zod.object({
	analyses: zod.array(
		zod.object({
			metric_spec: zod.object({
				field_name: zod
					.string()
					.regex(powerCheckResponseAnalysesItemMetricSpecFieldNameRegExp),
				metric_pct_change: zod.number().or(zod.null()).optional(),
				metric_target: zod.number().or(zod.null()).optional(),
				metric_type: zod.enum(["binary", "numeric"]).or(zod.null()).optional(),
				metric_baseline: zod.number().or(zod.null()).optional(),
				metric_stddev: zod.number().or(zod.null()).optional(),
				available_nonnull_n: zod.number().or(zod.null()).optional(),
				available_n: zod.number().or(zod.null()).optional(),
			}),
			target_n: zod.number().or(zod.null()).optional(),
			sufficient_n: zod.boolean().or(zod.null()).optional(),
			target_possible: zod.number().or(zod.null()).optional(),
			pct_change_possible: zod.number().or(zod.null()).optional(),
			msg: zod
				.object({
					type: zod.enum(["sufficient", "insufficient", "no baseline"]),
					msg: zod.string(),
					source_msg: zod.string(),
					values: zod
						.record(zod.string(), zod.number().or(zod.number()))
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
		}),
	),
});
