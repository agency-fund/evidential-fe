/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * xngin: Experiments API
 * OpenAPI spec version: 0.9.0
 */
import { z as zod } from "zod";

/**
 * Returns basic metadata about the authenticated caller of this method.
 * @summary Caller Identity
 */
export const callerIdentityResponse = zod.object({
	email: zod.string(),
	iss: zod.string(),
	sub: zod.string(),
	hd: zod.string(),
});

/**
 * Returns a list of organizations that the authenticated user is a member of.
 * @summary List Organizations
 */
export const listOrganizationsResponseItemsItemIdMax = 64;
export const listOrganizationsResponseItemsItemNameMax = 100;

export const listOrganizationsResponse = zod.object({
	items: zod.array(
		zod.object({
			id: zod.string().max(listOrganizationsResponseItemsItemIdMax),
			name: zod.string().max(listOrganizationsResponseItemsItemNameMax),
		}),
	),
});

/**
 * Creates a new organization.

Only users with an @agency.fund email address can create organizations.
 * @summary Create Organizations
 */
export const createOrganizationsBodyNameMax = 100;

export const createOrganizationsBody = zod.object({
	name: zod.string().max(createOrganizationsBodyNameMax),
});

export const createOrganizationsResponseIdMax = 64;

export const createOrganizationsResponse = zod.object({
	id: zod.string().max(createOrganizationsResponseIdMax),
});

/**
 * Adds a Webhook to an organization.
 * @summary Add Webhook To Organization
 */
export const addWebhookToOrganizationParams = zod.object({
	organization_id: zod.string(),
});

export const addWebhookToOrganizationBodyUrlMax = 500;

export const addWebhookToOrganizationBody = zod.object({
	type: zod.string(),
	url: zod.string().max(addWebhookToOrganizationBodyUrlMax),
});

export const addWebhookToOrganizationResponse = zod
	.object({
		id: zod.string().describe("The ID of the newly created webhook."),
		type: zod.string().describe("The type of webhook; e.g. experiment.created"),
		url: zod.string().describe("The URL to notify."),
		auth_token: zod
			.string()
			.or(zod.null())
			.describe(
				"The value of the Authorization: header that will be sent with the request to the configured URL.",
			),
	})
	.describe("Information on the successfully created webhook.");

/**
 * Lists all the webhooks for an organization.
 * @summary List Organization Webhooks
 */
export const listOrganizationWebhooksParams = zod.object({
	organization_id: zod.string(),
});

export const listOrganizationWebhooksResponse = zod.object({
	items: zod.array(
		zod
			.object({
				id: zod.string().describe("The ID of the webhook."),
				type: zod
					.string()
					.describe("The type of webhook; e.g. experiment.created"),
				url: zod.string().describe("The URL to notify."),
				auth_token: zod
					.string()
					.or(zod.null())
					.describe(
						"The value of the Authorization: header that will be sent with the request to the configured URL.",
					),
			})
			.describe("Summarizes a Webhook configuration for an organization."),
	),
});

/**
 * Removes a Webhook from an organization.
 * @summary Delete Webhook From Organization
 */
export const deleteWebhookFromOrganizationParams = zod.object({
	organization_id: zod.string(),
	webhook_id: zod.string(),
});

/**
 * Returns the most recent 200 events in an organization.
 * @summary List Organization Events
 */
export const listOrganizationEventsParams = zod.object({
	organization_id: zod.string(),
});

export const listOrganizationEventsResponse = zod.object({
	items: zod.array(
		zod
			.object({
				id: zod.string().describe("The ID of the event."),
				created_at: zod
					.string()
					.datetime({})
					.describe("The time the event was created."),
				type: zod.string().describe("The type of event."),
				summary: zod.string().describe("Human-readable summary of the event."),
				link: zod
					.string()
					.or(zod.null())
					.optional()
					.describe("A navigable link to related information."),
				details: zod.object({}).or(zod.null()).describe("Details"),
			})
			.describe("Describes an event."),
	),
});

/**
 * Adds a new member to an organization.

The authenticated user must be part of the organization to add members.
 * @summary Add Member To Organization
 */
export const addMemberToOrganizationParams = zod.object({
	organization_id: zod.string(),
});

export const addMemberToOrganizationBody = zod.object({
	email: zod.string(),
});

/**
 * Removes a member from an organization.

The authenticated user must be part of the organization to remove members.
 * @summary Remove Member From Organization
 */
export const removeMemberFromOrganizationParams = zod.object({
	organization_id: zod.string(),
	user_id: zod.string(),
});

/**
 * Updates an organization's properties.

The authenticated user must be a member of the organization.
Currently only supports updating the organization name.
 * @summary Update Organization
 */
export const updateOrganizationParams = zod.object({
	organization_id: zod.string(),
});

export const updateOrganizationBodyNameMaxOne = 100;

export const updateOrganizationBody = zod.object({
	name: zod
		.string()
		.max(updateOrganizationBodyNameMaxOne)
		.or(zod.null())
		.optional(),
});

export const updateOrganizationResponse = zod.any();

/**
 * Returns detailed information about a specific organization.

The authenticated user must be a member of the organization.
 * @summary Get Organization
 */
export const getOrganizationParams = zod.object({
	organization_id: zod.string(),
});

export const getOrganizationResponseIdMax = 64;
export const getOrganizationResponseNameMax = 100;
export const getOrganizationResponseUsersItemIdMax = 64;
export const getOrganizationResponseUsersItemEmailMax = 64;
export const getOrganizationResponseDatasourcesItemIdMax = 64;
export const getOrganizationResponseDatasourcesItemNameMax = 100;
export const getOrganizationResponseDatasourcesItemOrganizationIdMax = 64;
export const getOrganizationResponseDatasourcesItemOrganizationNameMax = 100;

export const getOrganizationResponse = zod.object({
	id: zod.string().max(getOrganizationResponseIdMax),
	name: zod.string().max(getOrganizationResponseNameMax),
	users: zod.array(
		zod.object({
			id: zod.string().max(getOrganizationResponseUsersItemIdMax),
			email: zod.string().max(getOrganizationResponseUsersItemEmailMax),
		}),
	),
	datasources: zod.array(
		zod.object({
			id: zod.string().max(getOrganizationResponseDatasourcesItemIdMax),
			name: zod.string().max(getOrganizationResponseDatasourcesItemNameMax),
			driver: zod.string(),
			type: zod.string(),
			organization_id: zod
				.string()
				.max(getOrganizationResponseDatasourcesItemOrganizationIdMax),
			organization_name: zod
				.string()
				.max(getOrganizationResponseDatasourcesItemOrganizationNameMax),
		}),
	),
});

/**
 * Returns a list of datasources accessible to the authenticated user for an org.
 * @summary List Organization Datasources
 */
export const listOrganizationDatasourcesParams = zod.object({
	organization_id: zod.string(),
});

export const listOrganizationDatasourcesResponseItemsItemIdMax = 64;
export const listOrganizationDatasourcesResponseItemsItemNameMax = 100;
export const listOrganizationDatasourcesResponseItemsItemOrganizationIdMax = 64;
export const listOrganizationDatasourcesResponseItemsItemOrganizationNameMax = 100;

export const listOrganizationDatasourcesResponse = zod.object({
	items: zod.array(
		zod.object({
			id: zod.string().max(listOrganizationDatasourcesResponseItemsItemIdMax),
			name: zod
				.string()
				.max(listOrganizationDatasourcesResponseItemsItemNameMax),
			driver: zod.string(),
			type: zod.string(),
			organization_id: zod
				.string()
				.max(listOrganizationDatasourcesResponseItemsItemOrganizationIdMax),
			organization_name: zod
				.string()
				.max(listOrganizationDatasourcesResponseItemsItemOrganizationNameMax),
		}),
	),
});

/**
 * Creates a new datasource for the specified organization.
 * @summary Create Datasource
 */
export const createDatasourceBodyOrganizationIdMax = 64;
export const createDatasourceBodyDwhPortDefault = 5432;
export const createDatasourceBodyDwhPortMin = 1024;

export const createDatasourceBodyDwhPortMax = 65535;
export const createDatasourceBodyDwhProjectIdMin = 6;

export const createDatasourceBodyDwhProjectIdMax = 30;

export const createDatasourceBodyDwhProjectIdRegExp = new RegExp(
	"^[a-z0-9-]+$",
);
export const createDatasourceBodyDwhDatasetIdMax = 1024;

export const createDatasourceBodyDwhDatasetIdRegExp = new RegExp(
	"^[a-zA-Z0-9_]+$",
);
export const createDatasourceBodyDwhCredentialsContentBase64Min = 4;

export const createDatasourceBodyDwhCredentialsContentBase64Max = 8000;

export const createDatasourceBody = zod.object({
	organization_id: zod.string().max(createDatasourceBodyOrganizationIdMax),
	name: zod.string(),
	dwh: zod.discriminatedUnion("driver", [
		zod
			.object({
				driver: zod.enum(["postgresql+psycopg", "postgresql+psycopg2"]),
				host: zod.string(),
				port: zod
					.number()
					.min(createDatasourceBodyDwhPortMin)
					.max(createDatasourceBodyDwhPortMax)
					.default(createDatasourceBodyDwhPortDefault),
				user: zod.string(),
				password: zod.string(),
				dbname: zod.string(),
				sslmode: zod.enum(["disable", "require", "verify-ca", "verify-full"]),
				search_path: zod.string().or(zod.null()).optional(),
			})
			.describe(
				"Describes a set of parameters suitable for connecting to most types of remote databases.",
			),
		zod
			.object({
				driver: zod.enum(["bigquery"]),
				project_id: zod
					.string()
					.min(createDatasourceBodyDwhProjectIdMin)
					.max(createDatasourceBodyDwhProjectIdMax)
					.regex(createDatasourceBodyDwhProjectIdRegExp)
					.describe("The Google Cloud Project ID containing the dataset."),
				dataset_id: zod
					.string()
					.min(1)
					.max(createDatasourceBodyDwhDatasetIdMax)
					.regex(createDatasourceBodyDwhDatasetIdRegExp)
					.describe("The dataset name."),
				credentials: zod.discriminatedUnion("type", [
					zod
						.object({
							type: zod.enum(["serviceaccountinfo"]),
							content_base64: zod
								.string()
								.min(createDatasourceBodyDwhCredentialsContentBase64Min)
								.max(createDatasourceBodyDwhCredentialsContentBase64Max)
								.describe(
									"The base64-encoded service account info in the canonical JSON form.",
								),
						})
						.describe("Describes a Google Cloud Service Account credential."),
					zod
						.object({
							type: zod.enum(["serviceaccountfile"]),
							path: zod
								.string()
								.describe(
									"The path to the service account credentials file containing the credentials in canonical JSON form.",
								),
						})
						.describe(
							"Describes a file path to a Google Cloud Service Account credential file.",
						),
				]),
			})
			.describe("Describes a BigQuery connection."),
	]),
});

export const createDatasourceResponseIdMax = 64;

export const createDatasourceResponse = zod.object({
	id: zod.string().max(createDatasourceResponseIdMax),
});

/**
 * @summary Update Datasource
 */
export const updateDatasourceParams = zod.object({
	datasource_id: zod.string(),
});

export const updateDatasourceBodyNameMaxOne = 100;
export const updateDatasourceBodyDwhPortDefault = 5432;
export const updateDatasourceBodyDwhPortMin = 1024;

export const updateDatasourceBodyDwhPortMax = 65535;
export const updateDatasourceBodyDwhProjectIdMin = 6;

export const updateDatasourceBodyDwhProjectIdMax = 30;

export const updateDatasourceBodyDwhProjectIdRegExp = new RegExp(
	"^[a-z0-9-]+$",
);
export const updateDatasourceBodyDwhDatasetIdMax = 1024;

export const updateDatasourceBodyDwhDatasetIdRegExp = new RegExp(
	"^[a-zA-Z0-9_]+$",
);
export const updateDatasourceBodyDwhCredentialsContentBase64Min = 4;

export const updateDatasourceBodyDwhCredentialsContentBase64Max = 8000;

export const updateDatasourceBody = zod.object({
	name: zod
		.string()
		.max(updateDatasourceBodyNameMaxOne)
		.or(zod.null())
		.optional(),
	dwh: zod
		.discriminatedUnion("driver", [
			zod
				.object({
					driver: zod.enum(["postgresql+psycopg", "postgresql+psycopg2"]),
					host: zod.string(),
					port: zod
						.number()
						.min(updateDatasourceBodyDwhPortMin)
						.max(updateDatasourceBodyDwhPortMax)
						.default(updateDatasourceBodyDwhPortDefault),
					user: zod.string(),
					password: zod.string(),
					dbname: zod.string(),
					sslmode: zod.enum(["disable", "require", "verify-ca", "verify-full"]),
					search_path: zod.string().or(zod.null()).optional(),
				})
				.describe(
					"Describes a set of parameters suitable for connecting to most types of remote databases.",
				),
			zod
				.object({
					driver: zod.enum(["bigquery"]),
					project_id: zod
						.string()
						.min(updateDatasourceBodyDwhProjectIdMin)
						.max(updateDatasourceBodyDwhProjectIdMax)
						.regex(updateDatasourceBodyDwhProjectIdRegExp)
						.describe("The Google Cloud Project ID containing the dataset."),
					dataset_id: zod
						.string()
						.min(1)
						.max(updateDatasourceBodyDwhDatasetIdMax)
						.regex(updateDatasourceBodyDwhDatasetIdRegExp)
						.describe("The dataset name."),
					credentials: zod.discriminatedUnion("type", [
						zod
							.object({
								type: zod.enum(["serviceaccountinfo"]),
								content_base64: zod
									.string()
									.min(updateDatasourceBodyDwhCredentialsContentBase64Min)
									.max(updateDatasourceBodyDwhCredentialsContentBase64Max)
									.describe(
										"The base64-encoded service account info in the canonical JSON form.",
									),
							})
							.describe("Describes a Google Cloud Service Account credential."),
						zod
							.object({
								type: zod.enum(["serviceaccountfile"]),
								path: zod
									.string()
									.describe(
										"The path to the service account credentials file containing the credentials in canonical JSON form.",
									),
							})
							.describe(
								"Describes a file path to a Google Cloud Service Account credential file.",
							),
					]),
				})
				.describe("Describes a BigQuery connection."),
		])
		.or(zod.null())
		.optional(),
});

export const updateDatasourceResponse = zod.any();

/**
 * Returns detailed information about a specific datasource.
 * @summary Get Datasource
 */
export const getDatasourceParams = zod.object({
	datasource_id: zod.string(),
});

export const getDatasourceResponseIdMax = 64;
export const getDatasourceResponseNameMax = 100;
export const getDatasourceResponseConfigParticipantsItemFieldsItemDescriptionDefault =
	"";
export const getDatasourceResponseConfigParticipantsItemFieldsItemIsUniqueIdDefault = false;
export const getDatasourceResponseConfigParticipantsItemFieldsItemIsStrataDefault = false;
export const getDatasourceResponseConfigParticipantsItemFieldsItemIsFilterDefault = false;
export const getDatasourceResponseConfigParticipantsItemFieldsItemIsMetricDefault = false;
export const getDatasourceResponseConfigDwhPortDefault = 5432;
export const getDatasourceResponseConfigDwhPortMin = 1024;

export const getDatasourceResponseConfigDwhPortMax = 65535;
export const getDatasourceResponseConfigDwhProjectIdMin = 6;

export const getDatasourceResponseConfigDwhProjectIdMax = 30;

export const getDatasourceResponseConfigDwhProjectIdRegExp = new RegExp(
	"^[a-z0-9-]+$",
);
export const getDatasourceResponseConfigDwhDatasetIdMax = 1024;

export const getDatasourceResponseConfigDwhDatasetIdRegExp = new RegExp(
	"^[a-zA-Z0-9_]+$",
);
export const getDatasourceResponseConfigDwhCredentialsContentBase64Min = 4;

export const getDatasourceResponseConfigDwhCredentialsContentBase64Max = 8000;
export const getDatasourceResponseOrganizationIdMax = 64;
export const getDatasourceResponseOrganizationNameMax = 100;

export const getDatasourceResponse = zod.object({
	id: zod.string().max(getDatasourceResponseIdMax),
	name: zod.string().max(getDatasourceResponseNameMax),
	config: zod
		.object({
			participants: zod.array(
				zod.discriminatedUnion("type", [
					zod.object({
						participant_type: zod
							.string()
							.describe(
								"The name of the set of participants defined by the filters. This name must be unique within a datasource.",
							),
						type: zod.enum(["sheet"]),
						table_name: zod.string(),
						sheet: zod.object({
							url: zod.string(),
							worksheet: zod.string(),
						}),
					}),
					zod.object({
						table_name: zod
							.string()
							.describe("Name of the table in the data warehouse"),
						fields: zod
							.array(
								zod.object({
									field_name: zod
										.string()
										.describe("Name of the field in the data source"),
									data_type: zod
										.enum([
											"boolean",
											"character varying",
											"uuid",
											"date",
											"integer",
											"double precision",
											"numeric",
											"timestamp without time zone",
											"timestamp with time zone",
											"bigint",
											"jsonb (unsupported)",
											"json (unsupported)",
											"unsupported",
										])
										.describe(
											"Defines the supported data types for fields in the data source.",
										),
									description: zod
										.string()
										.optional()
										.describe("Human-readable description of the field"),
									is_unique_id: zod
										.boolean()
										.optional()
										.describe("Whether this field uniquely identifies records"),
									is_strata: zod
										.boolean()
										.optional()
										.describe(
											"Whether this field should be used for stratification",
										),
									is_filter: zod
										.boolean()
										.optional()
										.describe("Whether this field can be used as a filter"),
									is_metric: zod
										.boolean()
										.optional()
										.describe("Whether this field can be used as a metric"),
									extra: zod
										.record(zod.string(), zod.string())
										.or(zod.null())
										.optional()
										.describe("Additional field metadata"),
								}),
							)
							.describe("List of fields available in this table"),
						participant_type: zod
							.string()
							.describe(
								"The name of the set of participants defined by the filters. This name must be unique within a datasource.",
							),
						type: zod.enum(["schema"]),
					}),
				]),
			),
			webhook_config: zod
				.object({
					actions: zod
						.object({
							commit: zod
								.object({
									method: zod.enum(["GET", "POST", "PUT", "PATCH", "DELETE"]),
									url: zod.string(),
								})
								.describe("Represents a url and HTTP method to use with it.")
								.or(zod.null())
								.optional(),
						})
						.describe(
							"The set of supported actions that trigger a user callback.",
						),
					common_headers: zod
						.object({
							authorization: zod.string().or(zod.null()),
						})
						.describe(
							"Enumerates supported headers to attach to all webhook requests.",
						),
				})
				.describe("Top-level configuration object for user-defined webhooks.")
				.or(zod.null())
				.optional(),
			type: zod.string(),
			dwh: zod.discriminatedUnion("driver", [
				zod
					.object({
						driver: zod.enum(["postgresql+psycopg", "postgresql+psycopg2"]),
						host: zod.string(),
						port: zod
							.number()
							.min(getDatasourceResponseConfigDwhPortMin)
							.max(getDatasourceResponseConfigDwhPortMax)
							.default(getDatasourceResponseConfigDwhPortDefault),
						user: zod.string(),
						password: zod.string(),
						dbname: zod.string(),
						sslmode: zod.enum([
							"disable",
							"require",
							"verify-ca",
							"verify-full",
						]),
						search_path: zod.string().or(zod.null()).optional(),
					})
					.describe(
						"Describes a set of parameters suitable for connecting to most types of remote databases.",
					),
				zod
					.object({
						driver: zod.enum(["bigquery"]),
						project_id: zod
							.string()
							.min(getDatasourceResponseConfigDwhProjectIdMin)
							.max(getDatasourceResponseConfigDwhProjectIdMax)
							.regex(getDatasourceResponseConfigDwhProjectIdRegExp)
							.describe("The Google Cloud Project ID containing the dataset."),
						dataset_id: zod
							.string()
							.min(1)
							.max(getDatasourceResponseConfigDwhDatasetIdMax)
							.regex(getDatasourceResponseConfigDwhDatasetIdRegExp)
							.describe("The dataset name."),
						credentials: zod.discriminatedUnion("type", [
							zod
								.object({
									type: zod.enum(["serviceaccountinfo"]),
									content_base64: zod
										.string()
										.min(
											getDatasourceResponseConfigDwhCredentialsContentBase64Min,
										)
										.max(
											getDatasourceResponseConfigDwhCredentialsContentBase64Max,
										)
										.describe(
											"The base64-encoded service account info in the canonical JSON form.",
										),
								})
								.describe(
									"Describes a Google Cloud Service Account credential.",
								),
							zod
								.object({
									type: zod.enum(["serviceaccountfile"]),
									path: zod
										.string()
										.describe(
											"The path to the service account credentials file containing the credentials in canonical JSON form.",
										),
								})
								.describe(
									"Describes a file path to a Google Cloud Service Account credential file.",
								),
						]),
					})
					.describe("Describes a BigQuery connection."),
			]),
		})
		.describe(
			"RemoteDatabaseConfig defines a configuration for a remote data warehouse.",
		),
	organization_id: zod.string().max(getDatasourceResponseOrganizationIdMax),
	organization_name: zod.string().max(getDatasourceResponseOrganizationNameMax),
});

/**
 * Deletes a datasource.

The user must be a member of the organization that owns the datasource.
 * @summary Delete Datasource
 */
export const deleteDatasourceParams = zod.object({
	datasource_id: zod.string(),
});

/**
 * Verifies connectivity to a datasource and returns a list of readable tables.
 * @summary Inspect Datasource
 */
export const inspectDatasourceParams = zod.object({
	datasource_id: zod.string(),
});

export const inspectDatasourceQueryRefreshDefault = false;

export const inspectDatasourceQueryParams = zod.object({
	refresh: zod.boolean().optional().describe("Refresh the cache."),
});

export const inspectDatasourceResponse = zod.object({
	tables: zod.array(zod.string()),
});

/**
 * Inspects a single table in a datasource and returns a summary of its fields.
 * @summary Inspect Table In Datasource
 */
export const inspectTableInDatasourceParams = zod.object({
	datasource_id: zod.string(),
	table_name: zod.string(),
});

export const inspectTableInDatasourceQueryRefreshDefault = false;

export const inspectTableInDatasourceQueryParams = zod.object({
	refresh: zod.boolean().optional().describe("Refresh the cache."),
});

export const inspectTableInDatasourceResponseFieldsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectTableInDatasourceResponseFieldsItemDescriptionMax = 2000;

export const inspectTableInDatasourceResponse = zod
	.object({
		detected_unique_id_fields: zod
			.array(zod.string())
			.describe("Fields that are possibly candidates for unique IDs."),
		fields: zod
			.array(
				zod
					.object({
						field_name: zod
							.string()
							.regex(inspectTableInDatasourceResponseFieldsItemFieldNameRegExp),
						data_type: zod
							.enum([
								"boolean",
								"character varying",
								"uuid",
								"date",
								"integer",
								"double precision",
								"numeric",
								"timestamp without time zone",
								"timestamp with time zone",
								"bigint",
								"jsonb (unsupported)",
								"json (unsupported)",
								"unsupported",
							])
							.describe(
								"Defines the supported data types for fields in the data source.",
							),
						description: zod
							.string()
							.max(inspectTableInDatasourceResponseFieldsItemDescriptionMax),
					})
					.describe("Concise summary of fields in the table."),
			)
			.describe("Fields in the table."),
	})
	.describe("Describes a table in the datasource.");

/**
 * @summary List Participant Types
 */
export const listParticipantTypesParams = zod.object({
	datasource_id: zod.string(),
});

export const listParticipantTypesResponseItemsItemFieldsItemDescriptionDefault =
	"";
export const listParticipantTypesResponseItemsItemFieldsItemIsUniqueIdDefault = false;
export const listParticipantTypesResponseItemsItemFieldsItemIsStrataDefault = false;
export const listParticipantTypesResponseItemsItemFieldsItemIsFilterDefault = false;
export const listParticipantTypesResponseItemsItemFieldsItemIsMetricDefault = false;

export const listParticipantTypesResponse = zod.object({
	items: zod.array(
		zod.discriminatedUnion("type", [
			zod.object({
				participant_type: zod
					.string()
					.describe(
						"The name of the set of participants defined by the filters. This name must be unique within a datasource.",
					),
				type: zod.enum(["sheet"]),
				table_name: zod.string(),
				sheet: zod.object({
					url: zod.string(),
					worksheet: zod.string(),
				}),
			}),
			zod.object({
				table_name: zod
					.string()
					.describe("Name of the table in the data warehouse"),
				fields: zod
					.array(
						zod.object({
							field_name: zod
								.string()
								.describe("Name of the field in the data source"),
							data_type: zod
								.enum([
									"boolean",
									"character varying",
									"uuid",
									"date",
									"integer",
									"double precision",
									"numeric",
									"timestamp without time zone",
									"timestamp with time zone",
									"bigint",
									"jsonb (unsupported)",
									"json (unsupported)",
									"unsupported",
								])
								.describe(
									"Defines the supported data types for fields in the data source.",
								),
							description: zod
								.string()
								.optional()
								.describe("Human-readable description of the field"),
							is_unique_id: zod
								.boolean()
								.optional()
								.describe("Whether this field uniquely identifies records"),
							is_strata: zod
								.boolean()
								.optional()
								.describe(
									"Whether this field should be used for stratification",
								),
							is_filter: zod
								.boolean()
								.optional()
								.describe("Whether this field can be used as a filter"),
							is_metric: zod
								.boolean()
								.optional()
								.describe("Whether this field can be used as a metric"),
							extra: zod
								.record(zod.string(), zod.string())
								.or(zod.null())
								.optional()
								.describe("Additional field metadata"),
						}),
					)
					.describe("List of fields available in this table"),
				participant_type: zod
					.string()
					.describe(
						"The name of the set of participants defined by the filters. This name must be unique within a datasource.",
					),
				type: zod.enum(["schema"]),
			}),
		]),
	),
});

/**
 * @summary Create Participant Type
 */
export const createParticipantTypeParams = zod.object({
	datasource_id: zod.string(),
});

export const createParticipantTypeBodyParticipantTypeMax = 100;
export const createParticipantTypeBodySchemaDefFieldsItemDescriptionDefault =
	"";
export const createParticipantTypeBodySchemaDefFieldsItemIsUniqueIdDefault = false;
export const createParticipantTypeBodySchemaDefFieldsItemIsStrataDefault = false;
export const createParticipantTypeBodySchemaDefFieldsItemIsFilterDefault = false;
export const createParticipantTypeBodySchemaDefFieldsItemIsMetricDefault = false;

export const createParticipantTypeBody = zod.object({
	participant_type: zod
		.string()
		.max(createParticipantTypeBodyParticipantTypeMax),
	schema_def: zod
		.object({
			table_name: zod
				.string()
				.describe("Name of the table in the data warehouse"),
			fields: zod
				.array(
					zod.object({
						field_name: zod
							.string()
							.describe("Name of the field in the data source"),
						data_type: zod
							.enum([
								"boolean",
								"character varying",
								"uuid",
								"date",
								"integer",
								"double precision",
								"numeric",
								"timestamp without time zone",
								"timestamp with time zone",
								"bigint",
								"jsonb (unsupported)",
								"json (unsupported)",
								"unsupported",
							])
							.describe(
								"Defines the supported data types for fields in the data source.",
							),
						description: zod
							.string()
							.optional()
							.describe("Human-readable description of the field"),
						is_unique_id: zod
							.boolean()
							.optional()
							.describe("Whether this field uniquely identifies records"),
						is_strata: zod
							.boolean()
							.optional()
							.describe("Whether this field should be used for stratification"),
						is_filter: zod
							.boolean()
							.optional()
							.describe("Whether this field can be used as a filter"),
						is_metric: zod
							.boolean()
							.optional()
							.describe("Whether this field can be used as a metric"),
						extra: zod
							.record(zod.string(), zod.string())
							.or(zod.null())
							.optional()
							.describe("Additional field metadata"),
					}),
				)
				.describe("List of fields available in this table"),
		})
		.describe(
			"Represents a single worksheet describing metadata about a type of Participant.",
		),
});

export const createParticipantTypeResponseParticipantTypeMax = 100;
export const createParticipantTypeResponseSchemaDefFieldsItemDescriptionDefault =
	"";
export const createParticipantTypeResponseSchemaDefFieldsItemIsUniqueIdDefault = false;
export const createParticipantTypeResponseSchemaDefFieldsItemIsStrataDefault = false;
export const createParticipantTypeResponseSchemaDefFieldsItemIsFilterDefault = false;
export const createParticipantTypeResponseSchemaDefFieldsItemIsMetricDefault = false;

export const createParticipantTypeResponse = zod.object({
	participant_type: zod
		.string()
		.max(createParticipantTypeResponseParticipantTypeMax),
	schema_def: zod
		.object({
			table_name: zod
				.string()
				.describe("Name of the table in the data warehouse"),
			fields: zod
				.array(
					zod.object({
						field_name: zod
							.string()
							.describe("Name of the field in the data source"),
						data_type: zod
							.enum([
								"boolean",
								"character varying",
								"uuid",
								"date",
								"integer",
								"double precision",
								"numeric",
								"timestamp without time zone",
								"timestamp with time zone",
								"bigint",
								"jsonb (unsupported)",
								"json (unsupported)",
								"unsupported",
							])
							.describe(
								"Defines the supported data types for fields in the data source.",
							),
						description: zod
							.string()
							.optional()
							.describe("Human-readable description of the field"),
						is_unique_id: zod
							.boolean()
							.optional()
							.describe("Whether this field uniquely identifies records"),
						is_strata: zod
							.boolean()
							.optional()
							.describe("Whether this field should be used for stratification"),
						is_filter: zod
							.boolean()
							.optional()
							.describe("Whether this field can be used as a filter"),
						is_metric: zod
							.boolean()
							.optional()
							.describe("Whether this field can be used as a metric"),
						extra: zod
							.record(zod.string(), zod.string())
							.or(zod.null())
							.optional()
							.describe("Additional field metadata"),
					}),
				)
				.describe("List of fields available in this table"),
		})
		.describe(
			"Represents a single worksheet describing metadata about a type of Participant.",
		),
});

/**
 * Returns filter, strata, and metric field metadata for a participant type, including exemplars for filter fields.
 * @summary Inspect Participant Types
 */
export const inspectParticipantTypesParams = zod.object({
	datasource_id: zod.string(),
	participant_id: zod.string(),
});

export const inspectParticipantTypesQueryRefreshDefault = false;

export const inspectParticipantTypesQueryParams = zod.object({
	refresh: zod.boolean().optional().describe("Refresh the cache."),
});

export const inspectParticipantTypesResponseFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectParticipantTypesResponseFiltersItemRelationsMax = 20;
export const inspectParticipantTypesResponseFiltersItemDescriptionMax = 2000;
export const inspectParticipantTypesResponseFiltersItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectParticipantTypesResponseFiltersItemRelationsMaxOne = 20;
export const inspectParticipantTypesResponseFiltersItemDescriptionMaxOne = 2000;
export const inspectParticipantTypesResponseMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectParticipantTypesResponseMetricsItemDescriptionMax = 2000;
export const inspectParticipantTypesResponseStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectParticipantTypesResponseStrataItemDescriptionMax = 2000;

export const inspectParticipantTypesResponse = zod
	.object({
		filters: zod.array(
			zod
				.object({
					field_name: zod
						.string()
						.regex(inspectParticipantTypesResponseFiltersItemFieldNameRegExp)
						.describe("Name of the field."),
					data_type: zod
						.enum([
							"boolean",
							"character varying",
							"uuid",
							"date",
							"integer",
							"double precision",
							"numeric",
							"timestamp without time zone",
							"timestamp with time zone",
							"bigint",
							"jsonb (unsupported)",
							"json (unsupported)",
							"unsupported",
						])
						.describe(
							"Defines the supported data types for fields in the data source.",
						),
					relations: zod
						.array(
							zod
								.enum(["includes", "excludes", "between"])
								.describe(
									"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
								),
						)
						.min(1)
						.max(inspectParticipantTypesResponseFiltersItemRelationsMax),
					description: zod
						.string()
						.max(inspectParticipantTypesResponseFiltersItemDescriptionMax),
					min: zod
						.string()
						.datetime({})
						.or(zod.string().date())
						.or(zod.number())
						.or(zod.number())
						.or(zod.null())
						.describe("The minimum observed value."),
					max: zod
						.string()
						.datetime({})
						.or(zod.string().date())
						.or(zod.number())
						.or(zod.number())
						.or(zod.null())
						.describe("The maximum observed value."),
				})
				.describe("Describes a numeric or date filter variable.")
				.or(
					zod
						.object({
							field_name: zod
								.string()
								.regex(
									inspectParticipantTypesResponseFiltersItemFieldNameRegExpOne,
								)
								.describe("Name of the field."),
							data_type: zod
								.enum([
									"boolean",
									"character varying",
									"uuid",
									"date",
									"integer",
									"double precision",
									"numeric",
									"timestamp without time zone",
									"timestamp with time zone",
									"bigint",
									"jsonb (unsupported)",
									"json (unsupported)",
									"unsupported",
								])
								.describe(
									"Defines the supported data types for fields in the data source.",
								),
							relations: zod
								.array(
									zod
										.enum(["includes", "excludes", "between"])
										.describe(
											"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
										),
								)
								.min(1)
								.max(inspectParticipantTypesResponseFiltersItemRelationsMaxOne),
							description: zod
								.string()
								.max(
									inspectParticipantTypesResponseFiltersItemDescriptionMaxOne,
								),
							distinct_values: zod
								.array(zod.string())
								.or(zod.null())
								.describe("Sorted list of unique values."),
						})
						.describe("Describes a discrete filter variable."),
				),
		),
		metrics: zod.array(
			zod
				.object({
					field_name: zod
						.string()
						.regex(inspectParticipantTypesResponseMetricsItemFieldNameRegExp),
					data_type: zod
						.enum([
							"boolean",
							"character varying",
							"uuid",
							"date",
							"integer",
							"double precision",
							"numeric",
							"timestamp without time zone",
							"timestamp with time zone",
							"bigint",
							"jsonb (unsupported)",
							"json (unsupported)",
							"unsupported",
						])
						.describe(
							"Defines the supported data types for fields in the data source.",
						),
					description: zod
						.string()
						.max(inspectParticipantTypesResponseMetricsItemDescriptionMax),
				})
				.describe("Describes a metric."),
		),
		strata: zod.array(
			zod
				.object({
					data_type: zod
						.enum([
							"boolean",
							"character varying",
							"uuid",
							"date",
							"integer",
							"double precision",
							"numeric",
							"timestamp without time zone",
							"timestamp with time zone",
							"bigint",
							"jsonb (unsupported)",
							"json (unsupported)",
							"unsupported",
						])
						.describe(
							"Defines the supported data types for fields in the data source.",
						),
					field_name: zod
						.string()
						.regex(inspectParticipantTypesResponseStrataItemFieldNameRegExp),
					description: zod
						.string()
						.max(inspectParticipantTypesResponseStrataItemDescriptionMax),
					extra: zod
						.record(zod.string(), zod.string())
						.or(zod.null())
						.optional(),
				})
				.describe("Describes a stratification variable."),
		),
	})
	.describe(
		"Describes a participant type's strata, metrics, and filters (including exemplar values).",
	);

/**
 * @summary Get Participant Types
 */
export const getParticipantTypesParams = zod.object({
	datasource_id: zod.string(),
	participant_id: zod.string(),
});

export const getParticipantTypesResponseFieldsItemDescriptionDefault = "";
export const getParticipantTypesResponseFieldsItemIsUniqueIdDefault = false;
export const getParticipantTypesResponseFieldsItemIsStrataDefault = false;
export const getParticipantTypesResponseFieldsItemIsFilterDefault = false;
export const getParticipantTypesResponseFieldsItemIsMetricDefault = false;

export const getParticipantTypesResponse = zod.discriminatedUnion("type", [
	zod.object({
		participant_type: zod
			.string()
			.describe(
				"The name of the set of participants defined by the filters. This name must be unique within a datasource.",
			),
		type: zod.enum(["sheet"]),
		table_name: zod.string(),
		sheet: zod.object({
			url: zod.string(),
			worksheet: zod.string(),
		}),
	}),
	zod.object({
		table_name: zod
			.string()
			.describe("Name of the table in the data warehouse"),
		fields: zod
			.array(
				zod.object({
					field_name: zod
						.string()
						.describe("Name of the field in the data source"),
					data_type: zod
						.enum([
							"boolean",
							"character varying",
							"uuid",
							"date",
							"integer",
							"double precision",
							"numeric",
							"timestamp without time zone",
							"timestamp with time zone",
							"bigint",
							"jsonb (unsupported)",
							"json (unsupported)",
							"unsupported",
						])
						.describe(
							"Defines the supported data types for fields in the data source.",
						),
					description: zod
						.string()
						.optional()
						.describe("Human-readable description of the field"),
					is_unique_id: zod
						.boolean()
						.optional()
						.describe("Whether this field uniquely identifies records"),
					is_strata: zod
						.boolean()
						.optional()
						.describe("Whether this field should be used for stratification"),
					is_filter: zod
						.boolean()
						.optional()
						.describe("Whether this field can be used as a filter"),
					is_metric: zod
						.boolean()
						.optional()
						.describe("Whether this field can be used as a metric"),
					extra: zod
						.record(zod.string(), zod.string())
						.or(zod.null())
						.optional()
						.describe("Additional field metadata"),
				}),
			)
			.describe("List of fields available in this table"),
		participant_type: zod
			.string()
			.describe(
				"The name of the set of participants defined by the filters. This name must be unique within a datasource.",
			),
		type: zod.enum(["schema"]),
	}),
]);

/**
 * @summary Update Participant Type
 */
export const updateParticipantTypeParams = zod.object({
	datasource_id: zod.string(),
	participant_id: zod.string(),
});

export const updateParticipantTypeBodyParticipantTypeMaxOne = 100;
export const updateParticipantTypeBodyTableNameRegExpOne = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const updateParticipantTypeBodyFieldsItemDescriptionDefault = "";
export const updateParticipantTypeBodyFieldsItemIsUniqueIdDefault = false;
export const updateParticipantTypeBodyFieldsItemIsStrataDefault = false;
export const updateParticipantTypeBodyFieldsItemIsFilterDefault = false;
export const updateParticipantTypeBodyFieldsItemIsMetricDefault = false;
export const updateParticipantTypeBodyFieldsMaxOne = 150;

export const updateParticipantTypeBody = zod.object({
	participant_type: zod
		.string()
		.max(updateParticipantTypeBodyParticipantTypeMaxOne)
		.or(zod.null())
		.optional(),
	table_name: zod
		.string()
		.regex(updateParticipantTypeBodyTableNameRegExpOne)
		.or(zod.null())
		.optional(),
	fields: zod
		.array(
			zod.object({
				field_name: zod
					.string()
					.describe("Name of the field in the data source"),
				data_type: zod
					.enum([
						"boolean",
						"character varying",
						"uuid",
						"date",
						"integer",
						"double precision",
						"numeric",
						"timestamp without time zone",
						"timestamp with time zone",
						"bigint",
						"jsonb (unsupported)",
						"json (unsupported)",
						"unsupported",
					])
					.describe(
						"Defines the supported data types for fields in the data source.",
					),
				description: zod
					.string()
					.optional()
					.describe("Human-readable description of the field"),
				is_unique_id: zod
					.boolean()
					.optional()
					.describe("Whether this field uniquely identifies records"),
				is_strata: zod
					.boolean()
					.optional()
					.describe("Whether this field should be used for stratification"),
				is_filter: zod
					.boolean()
					.optional()
					.describe("Whether this field can be used as a filter"),
				is_metric: zod
					.boolean()
					.optional()
					.describe("Whether this field can be used as a metric"),
				extra: zod
					.record(zod.string(), zod.string())
					.or(zod.null())
					.optional()
					.describe("Additional field metadata"),
			}),
		)
		.max(updateParticipantTypeBodyFieldsMaxOne)
		.or(zod.null())
		.optional(),
});

export const updateParticipantTypeResponseParticipantTypeMax = 100;
export const updateParticipantTypeResponseTableNameRegExpOne = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const updateParticipantTypeResponseFieldsItemDescriptionDefault = "";
export const updateParticipantTypeResponseFieldsItemIsUniqueIdDefault = false;
export const updateParticipantTypeResponseFieldsItemIsStrataDefault = false;
export const updateParticipantTypeResponseFieldsItemIsFilterDefault = false;
export const updateParticipantTypeResponseFieldsItemIsMetricDefault = false;
export const updateParticipantTypeResponseFieldsMaxOne = 150;

export const updateParticipantTypeResponse = zod.object({
	participant_type: zod
		.string()
		.max(updateParticipantTypeResponseParticipantTypeMax),
	table_name: zod
		.string()
		.regex(updateParticipantTypeResponseTableNameRegExpOne)
		.or(zod.null())
		.optional(),
	fields: zod
		.array(
			zod.object({
				field_name: zod
					.string()
					.describe("Name of the field in the data source"),
				data_type: zod
					.enum([
						"boolean",
						"character varying",
						"uuid",
						"date",
						"integer",
						"double precision",
						"numeric",
						"timestamp without time zone",
						"timestamp with time zone",
						"bigint",
						"jsonb (unsupported)",
						"json (unsupported)",
						"unsupported",
					])
					.describe(
						"Defines the supported data types for fields in the data source.",
					),
				description: zod
					.string()
					.optional()
					.describe("Human-readable description of the field"),
				is_unique_id: zod
					.boolean()
					.optional()
					.describe("Whether this field uniquely identifies records"),
				is_strata: zod
					.boolean()
					.optional()
					.describe("Whether this field should be used for stratification"),
				is_filter: zod
					.boolean()
					.optional()
					.describe("Whether this field can be used as a filter"),
				is_metric: zod
					.boolean()
					.optional()
					.describe("Whether this field can be used as a metric"),
				extra: zod
					.record(zod.string(), zod.string())
					.or(zod.null())
					.optional()
					.describe("Additional field metadata"),
			}),
		)
		.max(updateParticipantTypeResponseFieldsMaxOne)
		.or(zod.null())
		.optional(),
});

/**
 * @summary Delete Participant
 */
export const deleteParticipantParams = zod.object({
	datasource_id: zod.string(),
	participant_id: zod.string(),
});

/**
 * Returns API keys that have access to the datasource.
 * @summary List Api Keys
 */
export const listApiKeysParams = zod.object({
	datasource_id: zod.string(),
});

export const listApiKeysResponseItemsItemIdMax = 64;
export const listApiKeysResponseItemsItemDatasourceIdMax = 64;
export const listApiKeysResponseItemsItemOrganizationIdMax = 64;
export const listApiKeysResponseItemsItemOrganizationNameMax = 100;

export const listApiKeysResponse = zod.object({
	items: zod.array(
		zod.object({
			id: zod.string().max(listApiKeysResponseItemsItemIdMax),
			datasource_id: zod
				.string()
				.max(listApiKeysResponseItemsItemDatasourceIdMax),
			organization_id: zod
				.string()
				.max(listApiKeysResponseItemsItemOrganizationIdMax),
			organization_name: zod
				.string()
				.max(listApiKeysResponseItemsItemOrganizationNameMax),
		}),
	),
});

/**
 * Creates an API key for the specified datasource.

The user must belong to the organization that owns the requested datasource.
 * @summary Create Api Key
 */
export const createApiKeyParams = zod.object({
	datasource_id: zod.string(),
});

export const createApiKeyResponseIdMax = 64;

export const createApiKeyResponse = zod.object({
	id: zod.string().max(createApiKeyResponseIdMax),
	datasource_id: zod.string(),
	key: zod.string(),
});

/**
 * Deletes the specified API key.
 * @summary Delete Api Key
 */
export const deleteApiKeyParams = zod.object({
	datasource_id: zod.string(),
	api_key_id: zod.string(),
});

/**
 * @summary Create Experiment
 */
export const createExperimentParams = zod.object({
	datasource_id: zod.string(),
});

export const createExperimentQueryStratifyOnMetricsDefault = true;

export const createExperimentQueryParams = zod.object({
	chosen_n: zod
		.number()
		.or(zod.null())
		.optional()
		.describe("Number of participants to assign."),
	stratify_on_metrics: zod
		.boolean()
		.default(createExperimentQueryStratifyOnMetricsDefault)
		.describe("Whether to also stratify on metrics during assignment."),
});

export const createExperimentBodyDesignSpecExperimentNameMax = 100;
export const createExperimentBodyDesignSpecDescriptionMax = 2000;
export const createExperimentBodyDesignSpecArmsItemArmNameMax = 100;
export const createExperimentBodyDesignSpecArmsItemArmDescriptionMaxOne = 2000;
export const createExperimentBodyDesignSpecArmsMin = 2;

export const createExperimentBodyDesignSpecArmsMax = 10;
export const createExperimentBodyDesignSpecStrataFieldNamesItemRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyDesignSpecStrataFieldNamesMax = 150;
export const createExperimentBodyDesignSpecMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyDesignSpecMetricsMax = 150;
export const createExperimentBodyDesignSpecPowerDefault = 0.8;
export const createExperimentBodyDesignSpecPowerMin = 0;

export const createExperimentBodyDesignSpecPowerMax = 1;
export const createExperimentBodyDesignSpecAlphaDefault = 0.05;
export const createExperimentBodyDesignSpecAlphaMin = 0;

export const createExperimentBodyDesignSpecAlphaMax = 1;
export const createExperimentBodyDesignSpecFstatThreshDefault = 0.6;
export const createExperimentBodyDesignSpecFstatThreshMin = 0;

export const createExperimentBodyDesignSpecFstatThreshMax = 1;
export const createExperimentBodyDesignSpecExperimentNameMaxOne = 100;
export const createExperimentBodyDesignSpecDescriptionMaxOne = 2000;
export const createExperimentBodyDesignSpecArmsItemArmNameMaxOne = 100;
export const createExperimentBodyDesignSpecArmsItemArmDescriptionMaxFour = 2000;
export const createExperimentBodyDesignSpecArmsMinOne = 2;

export const createExperimentBodyDesignSpecArmsMaxOne = 10;
export const createExperimentBodyDesignSpecStrataFieldNamesItemRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyDesignSpecStrataFieldNamesMaxOne = 150;
export const createExperimentBodyDesignSpecMetricsItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyDesignSpecMetricsMaxOne = 150;
export const createExperimentBodyDesignSpecPowerDefaultOne = 0.8;
export const createExperimentBodyDesignSpecPowerMinOne = 0;

export const createExperimentBodyDesignSpecPowerMaxOne = 1;
export const createExperimentBodyDesignSpecAlphaDefaultOne = 0.05;
export const createExperimentBodyDesignSpecAlphaMinOne = 0;

export const createExperimentBodyDesignSpecAlphaMaxOne = 1;
export const createExperimentBodyDesignSpecFstatThreshDefaultOne = 0.6;
export const createExperimentBodyDesignSpecFstatThreshMinOne = 0;

export const createExperimentBodyDesignSpecFstatThreshMaxOne = 1;
export const createExperimentBodyAudienceSpecParticipantTypeMax = 100;
export const createExperimentBodyAudienceSpecFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyAudienceSpecFiltersMax = 20;
export const createExperimentBodyPowerAnalysesAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyPowerAnalysesAnalysesMax = 150;

export const createExperimentBody = zod.object({
	design_spec: zod.discriminatedUnion("experiment_type", [
		zod
			.object({
				experiment_id: zod
					.string()
					.or(zod.null())
					.optional()
					.describe(
						"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
					),
				experiment_type: zod.enum(["preassigned"]),
				experiment_name: zod
					.string()
					.max(createExperimentBodyDesignSpecExperimentNameMax),
				description: zod
					.string()
					.max(createExperimentBodyDesignSpecDescriptionMax),
				start_date: zod.string().datetime({}),
				end_date: zod.string().datetime({}),
				arms: zod
					.array(
						zod
							.object({
								arm_id: zod
									.string()
									.or(zod.null())
									.optional()
									.describe(
										"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
									),
								arm_name: zod
									.string()
									.max(createExperimentBodyDesignSpecArmsItemArmNameMax),
								arm_description: zod
									.string()
									.max(
										createExperimentBodyDesignSpecArmsItemArmDescriptionMaxOne,
									)
									.or(zod.null())
									.optional(),
							})
							.describe("Describes an experiment treatment arm."),
					)
					.min(createExperimentBodyDesignSpecArmsMin)
					.max(createExperimentBodyDesignSpecArmsMax),
				strata_field_names: zod
					.array(
						zod
							.string()
							.regex(createExperimentBodyDesignSpecStrataFieldNamesItemRegExp),
					)
					.max(createExperimentBodyDesignSpecStrataFieldNamesMax)
					.describe(
						"List of participant_type variables to use for stratification.",
					),
				metrics: zod
					.array(
						zod
							.object({
								field_name: zod
									.string()
									.regex(
										createExperimentBodyDesignSpecMetricsItemFieldNameRegExp,
									),
								metric_pct_change: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
									),
								metric_target: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
									),
							})
							.describe(
								"Defines a request to look up baseline stats for a metric to measure in an experiment.",
							),
					)
					.min(1)
					.max(createExperimentBodyDesignSpecMetricsMax)
					.describe("Primary and optional secondary metrics to target."),
				power: zod
					.number()
					.min(createExperimentBodyDesignSpecPowerMin)
					.max(createExperimentBodyDesignSpecPowerMax)
					.default(createExperimentBodyDesignSpecPowerDefault)
					.describe(
						"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
					),
				alpha: zod
					.number()
					.min(createExperimentBodyDesignSpecAlphaMin)
					.max(createExperimentBodyDesignSpecAlphaMax)
					.default(createExperimentBodyDesignSpecAlphaDefault)
					.describe(
						"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
					),
				fstat_thresh: zod
					.number()
					.min(createExperimentBodyDesignSpecFstatThreshMin)
					.max(createExperimentBodyDesignSpecFstatThreshMax)
					.default(createExperimentBodyDesignSpecFstatThreshDefault)
					.describe(
						'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
					),
			})
			.describe(
				"Use this type to randomly select and assign from existing participants at design time.",
			),
		zod
			.object({
				experiment_id: zod
					.string()
					.or(zod.null())
					.optional()
					.describe(
						"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
					),
				experiment_type: zod.enum(["online"]),
				experiment_name: zod
					.string()
					.max(createExperimentBodyDesignSpecExperimentNameMaxOne),
				description: zod
					.string()
					.max(createExperimentBodyDesignSpecDescriptionMaxOne),
				start_date: zod.string().datetime({}),
				end_date: zod.string().datetime({}),
				arms: zod
					.array(
						zod
							.object({
								arm_id: zod
									.string()
									.or(zod.null())
									.optional()
									.describe(
										"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
									),
								arm_name: zod
									.string()
									.max(createExperimentBodyDesignSpecArmsItemArmNameMaxOne),
								arm_description: zod
									.string()
									.max(
										createExperimentBodyDesignSpecArmsItemArmDescriptionMaxFour,
									)
									.or(zod.null())
									.optional(),
							})
							.describe("Describes an experiment treatment arm."),
					)
					.min(createExperimentBodyDesignSpecArmsMinOne)
					.max(createExperimentBodyDesignSpecArmsMaxOne),
				strata_field_names: zod
					.array(
						zod
							.string()
							.regex(
								createExperimentBodyDesignSpecStrataFieldNamesItemRegExpOne,
							),
					)
					.max(createExperimentBodyDesignSpecStrataFieldNamesMaxOne)
					.describe(
						"List of participant_type variables to use for stratification.",
					),
				metrics: zod
					.array(
						zod
							.object({
								field_name: zod
									.string()
									.regex(
										createExperimentBodyDesignSpecMetricsItemFieldNameRegExpOne,
									),
								metric_pct_change: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
									),
								metric_target: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
									),
							})
							.describe(
								"Defines a request to look up baseline stats for a metric to measure in an experiment.",
							),
					)
					.min(1)
					.max(createExperimentBodyDesignSpecMetricsMaxOne)
					.describe("Primary and optional secondary metrics to target."),
				power: zod
					.number()
					.min(createExperimentBodyDesignSpecPowerMinOne)
					.max(createExperimentBodyDesignSpecPowerMaxOne)
					.default(createExperimentBodyDesignSpecPowerDefaultOne)
					.describe(
						"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
					),
				alpha: zod
					.number()
					.min(createExperimentBodyDesignSpecAlphaMinOne)
					.max(createExperimentBodyDesignSpecAlphaMaxOne)
					.default(createExperimentBodyDesignSpecAlphaDefaultOne)
					.describe(
						"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
					),
				fstat_thresh: zod
					.number()
					.min(createExperimentBodyDesignSpecFstatThreshMinOne)
					.max(createExperimentBodyDesignSpecFstatThreshMaxOne)
					.default(createExperimentBodyDesignSpecFstatThreshDefaultOne)
					.describe(
						'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
					),
			})
			.describe(
				"Use this type to randomly assign participants into arms during live experiment execution.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
			),
	]),
	audience_spec: zod
		.object({
			participant_type: zod
				.string()
				.max(createExperimentBodyAudienceSpecParticipantTypeMax),
			filters: zod
				.array(
					zod
						.object({
							field_name: zod
								.string()
								.regex(
									createExperimentBodyAudienceSpecFiltersItemFieldNameRegExp,
								),
							relation: zod
								.enum(["includes", "excludes", "between"])
								.describe(
									"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
								),
							value: zod
								.array(zod.number().or(zod.null()))
								.or(zod.array(zod.number().or(zod.null())))
								.or(zod.array(zod.string().or(zod.null())))
								.or(zod.array(zod.boolean().or(zod.null()))),
						})
						.describe(
							'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value       | logical Result                                    |\n|----------|-------------|---------------------------------------------------|\n| INCLUDES | [None]      | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |\n\nString comparisons are case-sensitive.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of datetime and timestamp values\n\nDATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
						),
				)
				.max(createExperimentBodyAudienceSpecFiltersMax),
		})
		.describe("Defines target participants for an experiment using filters."),
	power_analyses: zod
		.object({
			analyses: zod
				.array(
					zod
						.object({
							metric_spec: zod
								.object({
									field_name: zod
										.string()
										.regex(
											createExperimentBodyPowerAnalysesAnalysesItemMetricSpecFieldNameRegExp,
										),
									metric_pct_change: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Percent change target relative to the metric_baseline.",
										),
									metric_target: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Absolute target value = metric_baseline*(1 + metric_pct_change)",
										),
									metric_type: zod
										.enum(["binary", "numeric"])
										.describe("Classifies metrics by their value type.")
										.or(zod.null())
										.optional()
										.describe("Inferred from dwh type."),
									metric_baseline: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Mean of the tracked metric."),
									metric_stddev: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Standard deviation is set only for metric_type.NUMERIC metrics. Must be set for numeric metrics when available_n > 0.",
										),
									available_nonnull_n: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"The number of participants meeting the filtering criteria with a *non-null* value for this metric.",
										),
									available_n: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n.",
										),
								})
								.describe(
									"Defines a metric to measure in an experiment with its baseline stats.",
								),
							target_n: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"Minimum sample size needed to meet the design specs.",
								),
							sufficient_n: zod
								.boolean()
								.or(zod.null())
								.optional()
								.describe(
									"Whether or not there are enough available units to sample from to meet target_n.",
								),
							target_possible: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.",
								),
							pct_change_possible: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.",
								),
							msg: zod
								.object({
									type: zod
										.enum([
											"sufficient",
											"insufficient",
											"no baseline",
											"no available n",
											"zero effect size",
											"zero variation",
										])
										.describe("Classifies metric power analysis results."),
									msg: zod
										.string()
										.describe(
											"Main power analysis result stated in human-friendly English.",
										),
									source_msg: zod
										.string()
										.describe(
											"Power analysis result formatted as a template string with curly-braced {} named placeholders. Use with the dictionary of values to support localization of messages.",
										),
									values: zod
										.record(zod.string(), zod.number().or(zod.number()))
										.or(zod.null())
										.optional(),
								})
								.describe("Describes interpretation of power analysis results.")
								.or(zod.null())
								.optional()
								.describe("Human friendly message about the above results."),
						})
						.describe("Describes analysis results of a single metric."),
				)
				.max(createExperimentBodyPowerAnalysesAnalysesMax),
		})
		.or(zod.null())
		.optional(),
});

export const createExperimentResponseDesignSpecExperimentNameMax = 100;
export const createExperimentResponseDesignSpecDescriptionMax = 2000;
export const createExperimentResponseDesignSpecArmsItemArmNameMax = 100;
export const createExperimentResponseDesignSpecArmsItemArmDescriptionMaxOne = 2000;
export const createExperimentResponseDesignSpecArmsMin = 2;

export const createExperimentResponseDesignSpecArmsMax = 10;
export const createExperimentResponseDesignSpecStrataFieldNamesItemRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponseDesignSpecStrataFieldNamesMax = 150;
export const createExperimentResponseDesignSpecMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponseDesignSpecMetricsMax = 150;
export const createExperimentResponseDesignSpecPowerDefault = 0.8;
export const createExperimentResponseDesignSpecPowerMin = 0;

export const createExperimentResponseDesignSpecPowerMax = 1;
export const createExperimentResponseDesignSpecAlphaDefault = 0.05;
export const createExperimentResponseDesignSpecAlphaMin = 0;

export const createExperimentResponseDesignSpecAlphaMax = 1;
export const createExperimentResponseDesignSpecFstatThreshDefault = 0.6;
export const createExperimentResponseDesignSpecFstatThreshMin = 0;

export const createExperimentResponseDesignSpecFstatThreshMax = 1;
export const createExperimentResponseDesignSpecExperimentNameMaxOne = 100;
export const createExperimentResponseDesignSpecDescriptionMaxOne = 2000;
export const createExperimentResponseDesignSpecArmsItemArmNameMaxOne = 100;
export const createExperimentResponseDesignSpecArmsItemArmDescriptionMaxFour = 2000;
export const createExperimentResponseDesignSpecArmsMinOne = 2;

export const createExperimentResponseDesignSpecArmsMaxOne = 10;
export const createExperimentResponseDesignSpecStrataFieldNamesItemRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponseDesignSpecStrataFieldNamesMaxOne = 150;
export const createExperimentResponseDesignSpecMetricsItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponseDesignSpecMetricsMaxOne = 150;
export const createExperimentResponseDesignSpecPowerDefaultOne = 0.8;
export const createExperimentResponseDesignSpecPowerMinOne = 0;

export const createExperimentResponseDesignSpecPowerMaxOne = 1;
export const createExperimentResponseDesignSpecAlphaDefaultOne = 0.05;
export const createExperimentResponseDesignSpecAlphaMinOne = 0;

export const createExperimentResponseDesignSpecAlphaMaxOne = 1;
export const createExperimentResponseDesignSpecFstatThreshDefaultOne = 0.6;
export const createExperimentResponseDesignSpecFstatThreshMinOne = 0;

export const createExperimentResponseDesignSpecFstatThreshMaxOne = 1;
export const createExperimentResponseAudienceSpecParticipantTypeMax = 100;
export const createExperimentResponseAudienceSpecFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponseAudienceSpecFiltersMax = 20;
export const createExperimentResponsePowerAnalysesAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponsePowerAnalysesAnalysesMax = 150;
export const createExperimentResponseAssignSummaryArmSizesItemArmArmNameMax = 100;
export const createExperimentResponseAssignSummaryArmSizesItemArmArmDescriptionMaxOne = 2000;
export const createExperimentResponseAssignSummaryArmSizesItemSizeDefault = 0;
export const createExperimentResponseAssignSummaryArmSizesMaxOne = 10;

export const createExperimentResponse = zod
	.object({
		datasource_id: zod.string(),
		state: zod
			.enum(["designing", "assigned", "abandoned", "committed", "aborted"])
			.describe(
				"Experiment lifecycle states.\n\nnote: [starting state], [[terminal state]]\n[DESIGNING]->[ASSIGNED]->{[[ABANDONED]], COMMITTED}->[[ABORTED]]",
			),
		design_spec: zod.discriminatedUnion("experiment_type", [
			zod
				.object({
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
						),
					experiment_type: zod.enum(["preassigned"]),
					experiment_name: zod
						.string()
						.max(createExperimentResponseDesignSpecExperimentNameMax),
					description: zod
						.string()
						.max(createExperimentResponseDesignSpecDescriptionMax),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(createExperimentResponseDesignSpecArmsItemArmNameMax),
									arm_description: zod
										.string()
										.max(
											createExperimentResponseDesignSpecArmsItemArmDescriptionMaxOne,
										)
										.or(zod.null())
										.optional(),
								})
								.describe("Describes an experiment treatment arm."),
						)
						.min(createExperimentResponseDesignSpecArmsMin)
						.max(createExperimentResponseDesignSpecArmsMax),
					strata_field_names: zod
						.array(
							zod
								.string()
								.regex(
									createExperimentResponseDesignSpecStrataFieldNamesItemRegExp,
								),
						)
						.max(createExperimentResponseDesignSpecStrataFieldNamesMax)
						.describe(
							"List of participant_type variables to use for stratification.",
						),
					metrics: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											createExperimentResponseDesignSpecMetricsItemFieldNameRegExp,
										),
									metric_pct_change: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
										),
									metric_target: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
										),
								})
								.describe(
									"Defines a request to look up baseline stats for a metric to measure in an experiment.",
								),
						)
						.min(1)
						.max(createExperimentResponseDesignSpecMetricsMax)
						.describe("Primary and optional secondary metrics to target."),
					power: zod
						.number()
						.min(createExperimentResponseDesignSpecPowerMin)
						.max(createExperimentResponseDesignSpecPowerMax)
						.default(createExperimentResponseDesignSpecPowerDefault)
						.describe(
							"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
						),
					alpha: zod
						.number()
						.min(createExperimentResponseDesignSpecAlphaMin)
						.max(createExperimentResponseDesignSpecAlphaMax)
						.default(createExperimentResponseDesignSpecAlphaDefault)
						.describe(
							"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
						),
					fstat_thresh: zod
						.number()
						.min(createExperimentResponseDesignSpecFstatThreshMin)
						.max(createExperimentResponseDesignSpecFstatThreshMax)
						.default(createExperimentResponseDesignSpecFstatThreshDefault)
						.describe(
							'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
						),
				})
				.describe(
					"Use this type to randomly select and assign from existing participants at design time.",
				),
			zod
				.object({
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
						),
					experiment_type: zod.enum(["online"]),
					experiment_name: zod
						.string()
						.max(createExperimentResponseDesignSpecExperimentNameMaxOne),
					description: zod
						.string()
						.max(createExperimentResponseDesignSpecDescriptionMaxOne),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(
											createExperimentResponseDesignSpecArmsItemArmNameMaxOne,
										),
									arm_description: zod
										.string()
										.max(
											createExperimentResponseDesignSpecArmsItemArmDescriptionMaxFour,
										)
										.or(zod.null())
										.optional(),
								})
								.describe("Describes an experiment treatment arm."),
						)
						.min(createExperimentResponseDesignSpecArmsMinOne)
						.max(createExperimentResponseDesignSpecArmsMaxOne),
					strata_field_names: zod
						.array(
							zod
								.string()
								.regex(
									createExperimentResponseDesignSpecStrataFieldNamesItemRegExpOne,
								),
						)
						.max(createExperimentResponseDesignSpecStrataFieldNamesMaxOne)
						.describe(
							"List of participant_type variables to use for stratification.",
						),
					metrics: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											createExperimentResponseDesignSpecMetricsItemFieldNameRegExpOne,
										),
									metric_pct_change: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
										),
									metric_target: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
										),
								})
								.describe(
									"Defines a request to look up baseline stats for a metric to measure in an experiment.",
								),
						)
						.min(1)
						.max(createExperimentResponseDesignSpecMetricsMaxOne)
						.describe("Primary and optional secondary metrics to target."),
					power: zod
						.number()
						.min(createExperimentResponseDesignSpecPowerMinOne)
						.max(createExperimentResponseDesignSpecPowerMaxOne)
						.default(createExperimentResponseDesignSpecPowerDefaultOne)
						.describe(
							"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
						),
					alpha: zod
						.number()
						.min(createExperimentResponseDesignSpecAlphaMinOne)
						.max(createExperimentResponseDesignSpecAlphaMaxOne)
						.default(createExperimentResponseDesignSpecAlphaDefaultOne)
						.describe(
							"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
						),
					fstat_thresh: zod
						.number()
						.min(createExperimentResponseDesignSpecFstatThreshMinOne)
						.max(createExperimentResponseDesignSpecFstatThreshMaxOne)
						.default(createExperimentResponseDesignSpecFstatThreshDefaultOne)
						.describe(
							'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
						),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
		]),
		audience_spec: zod
			.object({
				participant_type: zod
					.string()
					.max(createExperimentResponseAudienceSpecParticipantTypeMax),
				filters: zod
					.array(
						zod
							.object({
								field_name: zod
									.string()
									.regex(
										createExperimentResponseAudienceSpecFiltersItemFieldNameRegExp,
									),
								relation: zod
									.enum(["includes", "excludes", "between"])
									.describe(
										"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
									),
								value: zod
									.array(zod.number().or(zod.null()))
									.or(zod.array(zod.number().or(zod.null())))
									.or(zod.array(zod.string().or(zod.null())))
									.or(zod.array(zod.boolean().or(zod.null()))),
							})
							.describe(
								'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value       | logical Result                                    |\n|----------|-------------|---------------------------------------------------|\n| INCLUDES | [None]      | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |\n\nString comparisons are case-sensitive.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of datetime and timestamp values\n\nDATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
							),
					)
					.max(createExperimentResponseAudienceSpecFiltersMax),
			})
			.describe("Defines target participants for an experiment using filters."),
		power_analyses: zod
			.object({
				analyses: zod
					.array(
						zod
							.object({
								metric_spec: zod
									.object({
										field_name: zod
											.string()
											.regex(
												createExperimentResponsePowerAnalysesAnalysesItemMetricSpecFieldNameRegExp,
											),
										metric_pct_change: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Percent change target relative to the metric_baseline.",
											),
										metric_target: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Absolute target value = metric_baseline*(1 + metric_pct_change)",
											),
										metric_type: zod
											.enum(["binary", "numeric"])
											.describe("Classifies metrics by their value type.")
											.or(zod.null())
											.optional()
											.describe("Inferred from dwh type."),
										metric_baseline: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Mean of the tracked metric."),
										metric_stddev: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Standard deviation is set only for metric_type.NUMERIC metrics. Must be set for numeric metrics when available_n > 0.",
											),
										available_nonnull_n: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"The number of participants meeting the filtering criteria with a *non-null* value for this metric.",
											),
										available_n: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n.",
											),
									})
									.describe(
										"Defines a metric to measure in an experiment with its baseline stats.",
									),
								target_n: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Minimum sample size needed to meet the design specs.",
									),
								sufficient_n: zod
									.boolean()
									.or(zod.null())
									.optional()
									.describe(
										"Whether or not there are enough available units to sample from to meet target_n.",
									),
								target_possible: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.",
									),
								pct_change_possible: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.",
									),
								msg: zod
									.object({
										type: zod
											.enum([
												"sufficient",
												"insufficient",
												"no baseline",
												"no available n",
												"zero effect size",
												"zero variation",
											])
											.describe("Classifies metric power analysis results."),
										msg: zod
											.string()
											.describe(
												"Main power analysis result stated in human-friendly English.",
											),
										source_msg: zod
											.string()
											.describe(
												"Power analysis result formatted as a template string with curly-braced {} named placeholders. Use with the dictionary of values to support localization of messages.",
											),
										values: zod
											.record(zod.string(), zod.number().or(zod.number()))
											.or(zod.null())
											.optional(),
									})
									.describe(
										"Describes interpretation of power analysis results.",
									)
									.or(zod.null())
									.optional()
									.describe("Human friendly message about the above results."),
							})
							.describe("Describes analysis results of a single metric."),
					)
					.max(createExperimentResponsePowerAnalysesAnalysesMax),
			})
			.or(zod.null()),
		assign_summary: zod
			.object({
				balance_check: zod
					.object({
						f_statistic: zod
							.number()
							.describe(
								"F-statistic testing the overall significance of the model predicting treatment assignment.",
							),
						numerator_df: zod
							.number()
							.describe(
								"The numerator degrees of freedom for the f-statistic related to number of dependent variables.",
							),
						denominator_df: zod
							.number()
							.describe(
								"Denominator degrees of freedom related to the number of observations.",
							),
						p_value: zod
							.number()
							.describe(
								"Probability of observing these data if strata do not predict treatment assignment, i.e. our randomization is balanced.",
							),
						balance_ok: zod
							.boolean()
							.describe(
								"Whether the p-value for our observed f_statistic is greater than the f-stat threshold specified in our design specification. (See DesignSpec.fstat_thresh)",
							),
					})
					.describe("Describes balance test results for treatment assignment.")
					.or(zod.null())
					.optional()
					.describe(
						"Balance test results if available. 'online' experiments do not have balance checks.",
					),
				sample_size: zod
					.number()
					.describe("The number of participants across all arms in total."),
				arm_sizes: zod
					.array(
						zod
							.object({
								arm: zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												createExperimentResponseAssignSummaryArmSizesItemArmArmNameMax,
											),
										arm_description: zod
											.string()
											.max(
												createExperimentResponseAssignSummaryArmSizesItemArmArmDescriptionMaxOne,
											)
											.or(zod.null())
											.optional(),
									})
									.describe("Describes an experiment treatment arm."),
								size: zod.number().optional(),
							})
							.describe(
								"Describes the number of participants assigned to each arm.",
							),
					)
					.max(createExperimentResponseAssignSummaryArmSizesMaxOne)
					.or(zod.null())
					.optional()
					.describe(
						"For each arm, the number of participants assigned. TODO: make required once development has stabilized. May be None if unknown due to persisting prior versions of an AssignSummary.",
					),
			})
			.describe("Key pieces of an AssignResponse without the assignments."),
	})
	.describe(
		"Same as the request but with ids filled for the experiment and arms, and summary info on the assignment.",
	);

/**
 * Returns the list of experiments in the datasource.
 * @summary List Experiments
 */
export const listExperimentsParams = zod.object({
	datasource_id: zod.string(),
});

export const listExperimentsResponseItemsItemDesignSpecExperimentNameMax = 100;
export const listExperimentsResponseItemsItemDesignSpecDescriptionMax = 2000;
export const listExperimentsResponseItemsItemDesignSpecArmsItemArmNameMax = 100;
export const listExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxOne = 2000;
export const listExperimentsResponseItemsItemDesignSpecArmsMin = 2;

export const listExperimentsResponseItemsItemDesignSpecArmsMax = 10;
export const listExperimentsResponseItemsItemDesignSpecStrataFieldNamesItemRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listExperimentsResponseItemsItemDesignSpecStrataFieldNamesMax = 150;
export const listExperimentsResponseItemsItemDesignSpecMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listExperimentsResponseItemsItemDesignSpecMetricsMax = 150;
export const listExperimentsResponseItemsItemDesignSpecPowerDefault = 0.8;
export const listExperimentsResponseItemsItemDesignSpecPowerMin = 0;

export const listExperimentsResponseItemsItemDesignSpecPowerMax = 1;
export const listExperimentsResponseItemsItemDesignSpecAlphaDefault = 0.05;
export const listExperimentsResponseItemsItemDesignSpecAlphaMin = 0;

export const listExperimentsResponseItemsItemDesignSpecAlphaMax = 1;
export const listExperimentsResponseItemsItemDesignSpecFstatThreshDefault = 0.6;
export const listExperimentsResponseItemsItemDesignSpecFstatThreshMin = 0;

export const listExperimentsResponseItemsItemDesignSpecFstatThreshMax = 1;
export const listExperimentsResponseItemsItemDesignSpecExperimentNameMaxOne = 100;
export const listExperimentsResponseItemsItemDesignSpecDescriptionMaxOne = 2000;
export const listExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxOne = 100;
export const listExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxFour = 2000;
export const listExperimentsResponseItemsItemDesignSpecArmsMinOne = 2;

export const listExperimentsResponseItemsItemDesignSpecArmsMaxOne = 10;
export const listExperimentsResponseItemsItemDesignSpecStrataFieldNamesItemRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listExperimentsResponseItemsItemDesignSpecStrataFieldNamesMaxOne = 150;
export const listExperimentsResponseItemsItemDesignSpecMetricsItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listExperimentsResponseItemsItemDesignSpecMetricsMaxOne = 150;
export const listExperimentsResponseItemsItemDesignSpecPowerDefaultOne = 0.8;
export const listExperimentsResponseItemsItemDesignSpecPowerMinOne = 0;

export const listExperimentsResponseItemsItemDesignSpecPowerMaxOne = 1;
export const listExperimentsResponseItemsItemDesignSpecAlphaDefaultOne = 0.05;
export const listExperimentsResponseItemsItemDesignSpecAlphaMinOne = 0;

export const listExperimentsResponseItemsItemDesignSpecAlphaMaxOne = 1;
export const listExperimentsResponseItemsItemDesignSpecFstatThreshDefaultOne = 0.6;
export const listExperimentsResponseItemsItemDesignSpecFstatThreshMinOne = 0;

export const listExperimentsResponseItemsItemDesignSpecFstatThreshMaxOne = 1;
export const listExperimentsResponseItemsItemAudienceSpecParticipantTypeMax = 100;
export const listExperimentsResponseItemsItemAudienceSpecFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listExperimentsResponseItemsItemAudienceSpecFiltersMax = 20;
export const listExperimentsResponseItemsItemPowerAnalysesAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listExperimentsResponseItemsItemPowerAnalysesAnalysesMax = 150;
export const listExperimentsResponseItemsItemAssignSummaryArmSizesItemArmArmNameMax = 100;
export const listExperimentsResponseItemsItemAssignSummaryArmSizesItemArmArmDescriptionMaxOne = 2000;
export const listExperimentsResponseItemsItemAssignSummaryArmSizesItemSizeDefault = 0;
export const listExperimentsResponseItemsItemAssignSummaryArmSizesMaxOne = 10;

export const listExperimentsResponse = zod.object({
	items: zod.array(
		zod
			.object({
				datasource_id: zod.string(),
				state: zod
					.enum(["designing", "assigned", "abandoned", "committed", "aborted"])
					.describe(
						"Experiment lifecycle states.\n\nnote: [starting state], [[terminal state]]\n[DESIGNING]->[ASSIGNED]->{[[ABANDONED]], COMMITTED}->[[ABORTED]]",
					),
				design_spec: zod.discriminatedUnion("experiment_type", [
					zod
						.object({
							experiment_id: zod
								.string()
								.or(zod.null())
								.optional()
								.describe(
									"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
								),
							experiment_type: zod.enum(["preassigned"]),
							experiment_name: zod
								.string()
								.max(
									listExperimentsResponseItemsItemDesignSpecExperimentNameMax,
								),
							description: zod
								.string()
								.max(listExperimentsResponseItemsItemDesignSpecDescriptionMax),
							start_date: zod.string().datetime({}),
							end_date: zod.string().datetime({}),
							arms: zod
								.array(
									zod
										.object({
											arm_id: zod
												.string()
												.or(zod.null())
												.optional()
												.describe(
													"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
												),
											arm_name: zod
												.string()
												.max(
													listExperimentsResponseItemsItemDesignSpecArmsItemArmNameMax,
												),
											arm_description: zod
												.string()
												.max(
													listExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxOne,
												)
												.or(zod.null())
												.optional(),
										})
										.describe("Describes an experiment treatment arm."),
								)
								.min(listExperimentsResponseItemsItemDesignSpecArmsMin)
								.max(listExperimentsResponseItemsItemDesignSpecArmsMax),
							strata_field_names: zod
								.array(
									zod
										.string()
										.regex(
											listExperimentsResponseItemsItemDesignSpecStrataFieldNamesItemRegExp,
										),
								)
								.max(
									listExperimentsResponseItemsItemDesignSpecStrataFieldNamesMax,
								)
								.describe(
									"List of participant_type variables to use for stratification.",
								),
							metrics: zod
								.array(
									zod
										.object({
											field_name: zod
												.string()
												.regex(
													listExperimentsResponseItemsItemDesignSpecMetricsItemFieldNameRegExp,
												),
											metric_pct_change: zod
												.number()
												.or(zod.null())
												.optional()
												.describe(
													"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
												),
											metric_target: zod
												.number()
												.or(zod.null())
												.optional()
												.describe(
													"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
												),
										})
										.describe(
											"Defines a request to look up baseline stats for a metric to measure in an experiment.",
										),
								)
								.min(1)
								.max(listExperimentsResponseItemsItemDesignSpecMetricsMax)
								.describe("Primary and optional secondary metrics to target."),
							power: zod
								.number()
								.min(listExperimentsResponseItemsItemDesignSpecPowerMin)
								.max(listExperimentsResponseItemsItemDesignSpecPowerMax)
								.default(listExperimentsResponseItemsItemDesignSpecPowerDefault)
								.describe(
									"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
								),
							alpha: zod
								.number()
								.min(listExperimentsResponseItemsItemDesignSpecAlphaMin)
								.max(listExperimentsResponseItemsItemDesignSpecAlphaMax)
								.default(listExperimentsResponseItemsItemDesignSpecAlphaDefault)
								.describe(
									"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
								),
							fstat_thresh: zod
								.number()
								.min(listExperimentsResponseItemsItemDesignSpecFstatThreshMin)
								.max(listExperimentsResponseItemsItemDesignSpecFstatThreshMax)
								.default(
									listExperimentsResponseItemsItemDesignSpecFstatThreshDefault,
								)
								.describe(
									'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
								),
						})
						.describe(
							"Use this type to randomly select and assign from existing participants at design time.",
						),
					zod
						.object({
							experiment_id: zod
								.string()
								.or(zod.null())
								.optional()
								.describe(
									"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
								),
							experiment_type: zod.enum(["online"]),
							experiment_name: zod
								.string()
								.max(
									listExperimentsResponseItemsItemDesignSpecExperimentNameMaxOne,
								),
							description: zod
								.string()
								.max(
									listExperimentsResponseItemsItemDesignSpecDescriptionMaxOne,
								),
							start_date: zod.string().datetime({}),
							end_date: zod.string().datetime({}),
							arms: zod
								.array(
									zod
										.object({
											arm_id: zod
												.string()
												.or(zod.null())
												.optional()
												.describe(
													"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
												),
											arm_name: zod
												.string()
												.max(
													listExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxOne,
												),
											arm_description: zod
												.string()
												.max(
													listExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxFour,
												)
												.or(zod.null())
												.optional(),
										})
										.describe("Describes an experiment treatment arm."),
								)
								.min(listExperimentsResponseItemsItemDesignSpecArmsMinOne)
								.max(listExperimentsResponseItemsItemDesignSpecArmsMaxOne),
							strata_field_names: zod
								.array(
									zod
										.string()
										.regex(
											listExperimentsResponseItemsItemDesignSpecStrataFieldNamesItemRegExpOne,
										),
								)
								.max(
									listExperimentsResponseItemsItemDesignSpecStrataFieldNamesMaxOne,
								)
								.describe(
									"List of participant_type variables to use for stratification.",
								),
							metrics: zod
								.array(
									zod
										.object({
											field_name: zod
												.string()
												.regex(
													listExperimentsResponseItemsItemDesignSpecMetricsItemFieldNameRegExpOne,
												),
											metric_pct_change: zod
												.number()
												.or(zod.null())
												.optional()
												.describe(
													"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
												),
											metric_target: zod
												.number()
												.or(zod.null())
												.optional()
												.describe(
													"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
												),
										})
										.describe(
											"Defines a request to look up baseline stats for a metric to measure in an experiment.",
										),
								)
								.min(1)
								.max(listExperimentsResponseItemsItemDesignSpecMetricsMaxOne)
								.describe("Primary and optional secondary metrics to target."),
							power: zod
								.number()
								.min(listExperimentsResponseItemsItemDesignSpecPowerMinOne)
								.max(listExperimentsResponseItemsItemDesignSpecPowerMaxOne)
								.default(
									listExperimentsResponseItemsItemDesignSpecPowerDefaultOne,
								)
								.describe(
									"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
								),
							alpha: zod
								.number()
								.min(listExperimentsResponseItemsItemDesignSpecAlphaMinOne)
								.max(listExperimentsResponseItemsItemDesignSpecAlphaMaxOne)
								.default(
									listExperimentsResponseItemsItemDesignSpecAlphaDefaultOne,
								)
								.describe(
									"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
								),
							fstat_thresh: zod
								.number()
								.min(
									listExperimentsResponseItemsItemDesignSpecFstatThreshMinOne,
								)
								.max(
									listExperimentsResponseItemsItemDesignSpecFstatThreshMaxOne,
								)
								.default(
									listExperimentsResponseItemsItemDesignSpecFstatThreshDefaultOne,
								)
								.describe(
									'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
								),
						})
						.describe(
							"Use this type to randomly assign participants into arms during live experiment execution.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
						),
				]),
				audience_spec: zod
					.object({
						participant_type: zod
							.string()
							.max(
								listExperimentsResponseItemsItemAudienceSpecParticipantTypeMax,
							),
						filters: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												listExperimentsResponseItemsItemAudienceSpecFiltersItemFieldNameRegExp,
											),
										relation: zod
											.enum(["includes", "excludes", "between"])
											.describe(
												"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
											),
										value: zod
											.array(zod.number().or(zod.null()))
											.or(zod.array(zod.number().or(zod.null())))
											.or(zod.array(zod.string().or(zod.null())))
											.or(zod.array(zod.boolean().or(zod.null()))),
									})
									.describe(
										'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value       | logical Result                                    |\n|----------|-------------|---------------------------------------------------|\n| INCLUDES | [None]      | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |\n\nString comparisons are case-sensitive.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of datetime and timestamp values\n\nDATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
									),
							)
							.max(listExperimentsResponseItemsItemAudienceSpecFiltersMax),
					})
					.describe(
						"Defines target participants for an experiment using filters.",
					),
				power_analyses: zod
					.object({
						analyses: zod
							.array(
								zod
									.object({
										metric_spec: zod
											.object({
												field_name: zod
													.string()
													.regex(
														listExperimentsResponseItemsItemPowerAnalysesAnalysesItemMetricSpecFieldNameRegExp,
													),
												metric_pct_change: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Percent change target relative to the metric_baseline.",
													),
												metric_target: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Absolute target value = metric_baseline*(1 + metric_pct_change)",
													),
												metric_type: zod
													.enum(["binary", "numeric"])
													.describe("Classifies metrics by their value type.")
													.or(zod.null())
													.optional()
													.describe("Inferred from dwh type."),
												metric_baseline: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Mean of the tracked metric."),
												metric_stddev: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Standard deviation is set only for metric_type.NUMERIC metrics. Must be set for numeric metrics when available_n > 0.",
													),
												available_nonnull_n: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"The number of participants meeting the filtering criteria with a *non-null* value for this metric.",
													),
												available_n: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n.",
													),
											})
											.describe(
												"Defines a metric to measure in an experiment with its baseline stats.",
											),
										target_n: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Minimum sample size needed to meet the design specs.",
											),
										sufficient_n: zod
											.boolean()
											.or(zod.null())
											.optional()
											.describe(
												"Whether or not there are enough available units to sample from to meet target_n.",
											),
										target_possible: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.",
											),
										pct_change_possible: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.",
											),
										msg: zod
											.object({
												type: zod
													.enum([
														"sufficient",
														"insufficient",
														"no baseline",
														"no available n",
														"zero effect size",
														"zero variation",
													])
													.describe(
														"Classifies metric power analysis results.",
													),
												msg: zod
													.string()
													.describe(
														"Main power analysis result stated in human-friendly English.",
													),
												source_msg: zod
													.string()
													.describe(
														"Power analysis result formatted as a template string with curly-braced {} named placeholders. Use with the dictionary of values to support localization of messages.",
													),
												values: zod
													.record(zod.string(), zod.number().or(zod.number()))
													.or(zod.null())
													.optional(),
											})
											.describe(
												"Describes interpretation of power analysis results.",
											)
											.or(zod.null())
											.optional()
											.describe(
												"Human friendly message about the above results.",
											),
									})
									.describe("Describes analysis results of a single metric."),
							)
							.max(listExperimentsResponseItemsItemPowerAnalysesAnalysesMax),
					})
					.or(zod.null()),
				assign_summary: zod
					.object({
						balance_check: zod
							.object({
								f_statistic: zod
									.number()
									.describe(
										"F-statistic testing the overall significance of the model predicting treatment assignment.",
									),
								numerator_df: zod
									.number()
									.describe(
										"The numerator degrees of freedom for the f-statistic related to number of dependent variables.",
									),
								denominator_df: zod
									.number()
									.describe(
										"Denominator degrees of freedom related to the number of observations.",
									),
								p_value: zod
									.number()
									.describe(
										"Probability of observing these data if strata do not predict treatment assignment, i.e. our randomization is balanced.",
									),
								balance_ok: zod
									.boolean()
									.describe(
										"Whether the p-value for our observed f_statistic is greater than the f-stat threshold specified in our design specification. (See DesignSpec.fstat_thresh)",
									),
							})
							.describe(
								"Describes balance test results for treatment assignment.",
							)
							.or(zod.null())
							.optional()
							.describe(
								"Balance test results if available. 'online' experiments do not have balance checks.",
							),
						sample_size: zod
							.number()
							.describe("The number of participants across all arms in total."),
						arm_sizes: zod
							.array(
								zod
									.object({
										arm: zod
											.object({
												arm_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
													),
												arm_name: zod
													.string()
													.max(
														listExperimentsResponseItemsItemAssignSummaryArmSizesItemArmArmNameMax,
													),
												arm_description: zod
													.string()
													.max(
														listExperimentsResponseItemsItemAssignSummaryArmSizesItemArmArmDescriptionMaxOne,
													)
													.or(zod.null())
													.optional(),
											})
											.describe("Describes an experiment treatment arm."),
										size: zod.number().optional(),
									})
									.describe(
										"Describes the number of participants assigned to each arm.",
									),
							)
							.max(listExperimentsResponseItemsItemAssignSummaryArmSizesMaxOne)
							.or(zod.null())
							.optional()
							.describe(
								"For each arm, the number of participants assigned. TODO: make required once development has stabilized. May be None if unknown due to persisting prior versions of an AssignSummary.",
							),
					})
					.describe("Key pieces of an AssignResponse without the assignments."),
			})
			.describe("Representation of our stored Experiment information."),
	),
});

/**
 * @summary Analyze Experiment
 */
export const analyzeExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const analyzeExperimentQueryParams = zod.object({
	baseline_arm_id: zod
		.string()
		.or(zod.null())
		.optional()
		.describe(
			"UUID of the baseline arm. If None, the first design spec arm is used.",
		),
});

export const analyzeExperimentResponseMetricAnalysesItemMetricFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const analyzeExperimentResponseMetricAnalysesItemArmAnalysesItemArmNameMax = 100;
export const analyzeExperimentResponseMetricAnalysesItemArmAnalysesItemArmDescriptionMaxOne = 2000;

export const analyzeExperimentResponse = zod
	.object({
		experiment_id: zod.string().describe("ID of the experiment."),
		metric_analyses: zod
			.array(
				zod
					.object({
						metric_name: zod.string().or(zod.null()).optional(),
						metric: zod
							.object({
								field_name: zod
									.string()
									.regex(
										analyzeExperimentResponseMetricAnalysesItemMetricFieldNameRegExp,
									),
								metric_pct_change: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
									),
								metric_target: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
									),
							})
							.describe(
								"Defines a request to look up baseline stats for a metric to measure in an experiment.",
							)
							.or(zod.null())
							.optional(),
						arm_analyses: zod
							.array(
								zod.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(
											analyzeExperimentResponseMetricAnalysesItemArmAnalysesItemArmNameMax,
										),
									arm_description: zod
										.string()
										.max(
											analyzeExperimentResponseMetricAnalysesItemArmAnalysesItemArmDescriptionMaxOne,
										)
										.or(zod.null())
										.optional(),
									is_baseline: zod
										.boolean()
										.describe(
											"Whether this arm is the baseline/control arm for comparison.",
										),
									estimate: zod
										.number()
										.describe(
											"The estimated treatment effect relative to the baseline arm.",
										),
									p_value: zod
										.number()
										.or(zod.null())
										.describe(
											"The p-value indicating statistical significance of the treatment effect.",
										),
									t_stat: zod
										.number()
										.or(zod.null())
										.describe("The t-statistic from the statistical test."),
									std_error: zod
										.number()
										.describe(
											"The standard error of the treatment effect estimate.",
										),
								}),
							)
							.describe(
								"The results of the analysis for each arm (coefficient) for this specific metric.",
							),
					})
					.describe(
						"Describes the change in a single metric for each arm of an experiment.",
					),
			)
			.describe("Contains one analysis per metric targeted by the experiment."),
	})
	.describe(
		"Describes the change if any in metrics targeted by an experiment.",
	);

/**
 * @summary Commit Experiment
 */
export const commitExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const commitExperimentResponse = zod.any();

/**
 * @summary Abandon Experiment
 */
export const abandonExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const abandonExperimentResponse = zod.any();

/**
 * Returns the experiment with the specified ID.
 * @summary Get Experiment
 */
export const getExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const getExperimentResponseDesignSpecExperimentNameMax = 100;
export const getExperimentResponseDesignSpecDescriptionMax = 2000;
export const getExperimentResponseDesignSpecArmsItemArmNameMax = 100;
export const getExperimentResponseDesignSpecArmsItemArmDescriptionMaxOne = 2000;
export const getExperimentResponseDesignSpecArmsMin = 2;

export const getExperimentResponseDesignSpecArmsMax = 10;
export const getExperimentResponseDesignSpecStrataFieldNamesItemRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentResponseDesignSpecStrataFieldNamesMax = 150;
export const getExperimentResponseDesignSpecMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentResponseDesignSpecMetricsMax = 150;
export const getExperimentResponseDesignSpecPowerDefault = 0.8;
export const getExperimentResponseDesignSpecPowerMin = 0;

export const getExperimentResponseDesignSpecPowerMax = 1;
export const getExperimentResponseDesignSpecAlphaDefault = 0.05;
export const getExperimentResponseDesignSpecAlphaMin = 0;

export const getExperimentResponseDesignSpecAlphaMax = 1;
export const getExperimentResponseDesignSpecFstatThreshDefault = 0.6;
export const getExperimentResponseDesignSpecFstatThreshMin = 0;

export const getExperimentResponseDesignSpecFstatThreshMax = 1;
export const getExperimentResponseDesignSpecExperimentNameMaxOne = 100;
export const getExperimentResponseDesignSpecDescriptionMaxOne = 2000;
export const getExperimentResponseDesignSpecArmsItemArmNameMaxOne = 100;
export const getExperimentResponseDesignSpecArmsItemArmDescriptionMaxFour = 2000;
export const getExperimentResponseDesignSpecArmsMinOne = 2;

export const getExperimentResponseDesignSpecArmsMaxOne = 10;
export const getExperimentResponseDesignSpecStrataFieldNamesItemRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentResponseDesignSpecStrataFieldNamesMaxOne = 150;
export const getExperimentResponseDesignSpecMetricsItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentResponseDesignSpecMetricsMaxOne = 150;
export const getExperimentResponseDesignSpecPowerDefaultOne = 0.8;
export const getExperimentResponseDesignSpecPowerMinOne = 0;

export const getExperimentResponseDesignSpecPowerMaxOne = 1;
export const getExperimentResponseDesignSpecAlphaDefaultOne = 0.05;
export const getExperimentResponseDesignSpecAlphaMinOne = 0;

export const getExperimentResponseDesignSpecAlphaMaxOne = 1;
export const getExperimentResponseDesignSpecFstatThreshDefaultOne = 0.6;
export const getExperimentResponseDesignSpecFstatThreshMinOne = 0;

export const getExperimentResponseDesignSpecFstatThreshMaxOne = 1;
export const getExperimentResponseAudienceSpecParticipantTypeMax = 100;
export const getExperimentResponseAudienceSpecFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentResponseAudienceSpecFiltersMax = 20;
export const getExperimentResponsePowerAnalysesAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentResponsePowerAnalysesAnalysesMax = 150;
export const getExperimentResponseAssignSummaryArmSizesItemArmArmNameMax = 100;
export const getExperimentResponseAssignSummaryArmSizesItemArmArmDescriptionMaxOne = 2000;
export const getExperimentResponseAssignSummaryArmSizesItemSizeDefault = 0;
export const getExperimentResponseAssignSummaryArmSizesMaxOne = 10;

export const getExperimentResponse = zod
	.object({
		datasource_id: zod.string(),
		state: zod
			.enum(["designing", "assigned", "abandoned", "committed", "aborted"])
			.describe(
				"Experiment lifecycle states.\n\nnote: [starting state], [[terminal state]]\n[DESIGNING]->[ASSIGNED]->{[[ABANDONED]], COMMITTED}->[[ABORTED]]",
			),
		design_spec: zod.discriminatedUnion("experiment_type", [
			zod
				.object({
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
						),
					experiment_type: zod.enum(["preassigned"]),
					experiment_name: zod
						.string()
						.max(getExperimentResponseDesignSpecExperimentNameMax),
					description: zod
						.string()
						.max(getExperimentResponseDesignSpecDescriptionMax),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(getExperimentResponseDesignSpecArmsItemArmNameMax),
									arm_description: zod
										.string()
										.max(
											getExperimentResponseDesignSpecArmsItemArmDescriptionMaxOne,
										)
										.or(zod.null())
										.optional(),
								})
								.describe("Describes an experiment treatment arm."),
						)
						.min(getExperimentResponseDesignSpecArmsMin)
						.max(getExperimentResponseDesignSpecArmsMax),
					strata_field_names: zod
						.array(
							zod
								.string()
								.regex(
									getExperimentResponseDesignSpecStrataFieldNamesItemRegExp,
								),
						)
						.max(getExperimentResponseDesignSpecStrataFieldNamesMax)
						.describe(
							"List of participant_type variables to use for stratification.",
						),
					metrics: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											getExperimentResponseDesignSpecMetricsItemFieldNameRegExp,
										),
									metric_pct_change: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
										),
									metric_target: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
										),
								})
								.describe(
									"Defines a request to look up baseline stats for a metric to measure in an experiment.",
								),
						)
						.min(1)
						.max(getExperimentResponseDesignSpecMetricsMax)
						.describe("Primary and optional secondary metrics to target."),
					power: zod
						.number()
						.min(getExperimentResponseDesignSpecPowerMin)
						.max(getExperimentResponseDesignSpecPowerMax)
						.default(getExperimentResponseDesignSpecPowerDefault)
						.describe(
							"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
						),
					alpha: zod
						.number()
						.min(getExperimentResponseDesignSpecAlphaMin)
						.max(getExperimentResponseDesignSpecAlphaMax)
						.default(getExperimentResponseDesignSpecAlphaDefault)
						.describe(
							"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
						),
					fstat_thresh: zod
						.number()
						.min(getExperimentResponseDesignSpecFstatThreshMin)
						.max(getExperimentResponseDesignSpecFstatThreshMax)
						.default(getExperimentResponseDesignSpecFstatThreshDefault)
						.describe(
							'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
						),
				})
				.describe(
					"Use this type to randomly select and assign from existing participants at design time.",
				),
			zod
				.object({
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
						),
					experiment_type: zod.enum(["online"]),
					experiment_name: zod
						.string()
						.max(getExperimentResponseDesignSpecExperimentNameMaxOne),
					description: zod
						.string()
						.max(getExperimentResponseDesignSpecDescriptionMaxOne),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(getExperimentResponseDesignSpecArmsItemArmNameMaxOne),
									arm_description: zod
										.string()
										.max(
											getExperimentResponseDesignSpecArmsItemArmDescriptionMaxFour,
										)
										.or(zod.null())
										.optional(),
								})
								.describe("Describes an experiment treatment arm."),
						)
						.min(getExperimentResponseDesignSpecArmsMinOne)
						.max(getExperimentResponseDesignSpecArmsMaxOne),
					strata_field_names: zod
						.array(
							zod
								.string()
								.regex(
									getExperimentResponseDesignSpecStrataFieldNamesItemRegExpOne,
								),
						)
						.max(getExperimentResponseDesignSpecStrataFieldNamesMaxOne)
						.describe(
							"List of participant_type variables to use for stratification.",
						),
					metrics: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											getExperimentResponseDesignSpecMetricsItemFieldNameRegExpOne,
										),
									metric_pct_change: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
										),
									metric_target: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
										),
								})
								.describe(
									"Defines a request to look up baseline stats for a metric to measure in an experiment.",
								),
						)
						.min(1)
						.max(getExperimentResponseDesignSpecMetricsMaxOne)
						.describe("Primary and optional secondary metrics to target."),
					power: zod
						.number()
						.min(getExperimentResponseDesignSpecPowerMinOne)
						.max(getExperimentResponseDesignSpecPowerMaxOne)
						.default(getExperimentResponseDesignSpecPowerDefaultOne)
						.describe(
							"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
						),
					alpha: zod
						.number()
						.min(getExperimentResponseDesignSpecAlphaMinOne)
						.max(getExperimentResponseDesignSpecAlphaMaxOne)
						.default(getExperimentResponseDesignSpecAlphaDefaultOne)
						.describe(
							"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
						),
					fstat_thresh: zod
						.number()
						.min(getExperimentResponseDesignSpecFstatThreshMinOne)
						.max(getExperimentResponseDesignSpecFstatThreshMaxOne)
						.default(getExperimentResponseDesignSpecFstatThreshDefaultOne)
						.describe(
							'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
						),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
		]),
		audience_spec: zod
			.object({
				participant_type: zod
					.string()
					.max(getExperimentResponseAudienceSpecParticipantTypeMax),
				filters: zod
					.array(
						zod
							.object({
								field_name: zod
									.string()
									.regex(
										getExperimentResponseAudienceSpecFiltersItemFieldNameRegExp,
									),
								relation: zod
									.enum(["includes", "excludes", "between"])
									.describe(
										"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
									),
								value: zod
									.array(zod.number().or(zod.null()))
									.or(zod.array(zod.number().or(zod.null())))
									.or(zod.array(zod.string().or(zod.null())))
									.or(zod.array(zod.boolean().or(zod.null()))),
							})
							.describe(
								'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value       | logical Result                                    |\n|----------|-------------|---------------------------------------------------|\n| INCLUDES | [None]      | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |\n\nString comparisons are case-sensitive.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of datetime and timestamp values\n\nDATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
							),
					)
					.max(getExperimentResponseAudienceSpecFiltersMax),
			})
			.describe("Defines target participants for an experiment using filters."),
		power_analyses: zod
			.object({
				analyses: zod
					.array(
						zod
							.object({
								metric_spec: zod
									.object({
										field_name: zod
											.string()
											.regex(
												getExperimentResponsePowerAnalysesAnalysesItemMetricSpecFieldNameRegExp,
											),
										metric_pct_change: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Percent change target relative to the metric_baseline.",
											),
										metric_target: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Absolute target value = metric_baseline*(1 + metric_pct_change)",
											),
										metric_type: zod
											.enum(["binary", "numeric"])
											.describe("Classifies metrics by their value type.")
											.or(zod.null())
											.optional()
											.describe("Inferred from dwh type."),
										metric_baseline: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Mean of the tracked metric."),
										metric_stddev: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Standard deviation is set only for metric_type.NUMERIC metrics. Must be set for numeric metrics when available_n > 0.",
											),
										available_nonnull_n: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"The number of participants meeting the filtering criteria with a *non-null* value for this metric.",
											),
										available_n: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n.",
											),
									})
									.describe(
										"Defines a metric to measure in an experiment with its baseline stats.",
									),
								target_n: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Minimum sample size needed to meet the design specs.",
									),
								sufficient_n: zod
									.boolean()
									.or(zod.null())
									.optional()
									.describe(
										"Whether or not there are enough available units to sample from to meet target_n.",
									),
								target_possible: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.",
									),
								pct_change_possible: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.",
									),
								msg: zod
									.object({
										type: zod
											.enum([
												"sufficient",
												"insufficient",
												"no baseline",
												"no available n",
												"zero effect size",
												"zero variation",
											])
											.describe("Classifies metric power analysis results."),
										msg: zod
											.string()
											.describe(
												"Main power analysis result stated in human-friendly English.",
											),
										source_msg: zod
											.string()
											.describe(
												"Power analysis result formatted as a template string with curly-braced {} named placeholders. Use with the dictionary of values to support localization of messages.",
											),
										values: zod
											.record(zod.string(), zod.number().or(zod.number()))
											.or(zod.null())
											.optional(),
									})
									.describe(
										"Describes interpretation of power analysis results.",
									)
									.or(zod.null())
									.optional()
									.describe("Human friendly message about the above results."),
							})
							.describe("Describes analysis results of a single metric."),
					)
					.max(getExperimentResponsePowerAnalysesAnalysesMax),
			})
			.or(zod.null()),
		assign_summary: zod
			.object({
				balance_check: zod
					.object({
						f_statistic: zod
							.number()
							.describe(
								"F-statistic testing the overall significance of the model predicting treatment assignment.",
							),
						numerator_df: zod
							.number()
							.describe(
								"The numerator degrees of freedom for the f-statistic related to number of dependent variables.",
							),
						denominator_df: zod
							.number()
							.describe(
								"Denominator degrees of freedom related to the number of observations.",
							),
						p_value: zod
							.number()
							.describe(
								"Probability of observing these data if strata do not predict treatment assignment, i.e. our randomization is balanced.",
							),
						balance_ok: zod
							.boolean()
							.describe(
								"Whether the p-value for our observed f_statistic is greater than the f-stat threshold specified in our design specification. (See DesignSpec.fstat_thresh)",
							),
					})
					.describe("Describes balance test results for treatment assignment.")
					.or(zod.null())
					.optional()
					.describe(
						"Balance test results if available. 'online' experiments do not have balance checks.",
					),
				sample_size: zod
					.number()
					.describe("The number of participants across all arms in total."),
				arm_sizes: zod
					.array(
						zod
							.object({
								arm: zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												getExperimentResponseAssignSummaryArmSizesItemArmArmNameMax,
											),
										arm_description: zod
											.string()
											.max(
												getExperimentResponseAssignSummaryArmSizesItemArmArmDescriptionMaxOne,
											)
											.or(zod.null())
											.optional(),
									})
									.describe("Describes an experiment treatment arm."),
								size: zod.number().optional(),
							})
							.describe(
								"Describes the number of participants assigned to each arm.",
							),
					)
					.max(getExperimentResponseAssignSummaryArmSizesMaxOne)
					.or(zod.null())
					.optional()
					.describe(
						"For each arm, the number of participants assigned. TODO: make required once development has stabilized. May be None if unknown due to persisting prior versions of an AssignSummary.",
					),
			})
			.describe("Key pieces of an AssignResponse without the assignments."),
	})
	.describe("Representation of our stored Experiment information.");

/**
 * Deletes the experiment with the specified ID.
 * @summary Delete Experiment
 */
export const deleteExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

/**
 * @summary Get Experiment Assignments
 */
export const getExperimentAssignmentsParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const getExperimentAssignmentsResponseAssignmentsItemParticipantIdMax = 64;
export const getExperimentAssignmentsResponseAssignmentsItemArmNameMax = 100;
export const getExperimentAssignmentsResponseAssignmentsItemStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentAssignmentsResponseAssignmentsItemStrataMaxOne = 150;

export const getExperimentAssignmentsResponse = zod
	.object({
		balance_check: zod
			.object({
				f_statistic: zod
					.number()
					.describe(
						"F-statistic testing the overall significance of the model predicting treatment assignment.",
					),
				numerator_df: zod
					.number()
					.describe(
						"The numerator degrees of freedom for the f-statistic related to number of dependent variables.",
					),
				denominator_df: zod
					.number()
					.describe(
						"Denominator degrees of freedom related to the number of observations.",
					),
				p_value: zod
					.number()
					.describe(
						"Probability of observing these data if strata do not predict treatment assignment, i.e. our randomization is balanced.",
					),
				balance_ok: zod
					.boolean()
					.describe(
						"Whether the p-value for our observed f_statistic is greater than the f-stat threshold specified in our design specification. (See DesignSpec.fstat_thresh)",
					),
			})
			.describe("Describes balance test results for treatment assignment.")
			.or(zod.null())
			.optional()
			.describe(
				"Balance test results if available. 'online' experiments do not have balance checks.",
			),
		experiment_id: zod.string(),
		sample_size: zod.number(),
		assignments: zod.array(
			zod
				.object({
					participant_id: zod
						.string()
						.max(
							getExperimentAssignmentsResponseAssignmentsItemParticipantIdMax,
						),
					arm_id: zod
						.string()
						.describe(
							"ID of the arm this participant was assigned to. Same as Arm.arm_id.",
						),
					arm_name: zod
						.string()
						.max(getExperimentAssignmentsResponseAssignmentsItemArmNameMax)
						.describe(
							"The arm this participant was assigned to. Same as Arm.arm_name.",
						),
					strata: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											getExperimentAssignmentsResponseAssignmentsItemStrataItemFieldNameRegExp,
										),
									strata_value: zod.string().or(zod.null()).optional(),
								})
								.describe(
									"Describes stratification for an experiment participant.",
								),
						)
						.max(getExperimentAssignmentsResponseAssignmentsItemStrataMaxOne)
						.or(zod.null())
						.optional()
						.describe(
							"List of properties and their values for this participant used for stratification or tracking metrics. If stratification is not used, this will be None.",
						),
				})
				.describe(
					"Describes treatment assignment for an experiment participant.",
				),
		),
	})
	.describe(
		"Describes assignments for all participants and balance test results if available.",
	);

/**
 * @summary Export experiment assignments as CSV file; BalanceCheck not included. csv header form: participant_id,arm_id,arm_name,strata_name1,strata_name2,...
 */
export const getExperimentAssignmentsAsCsvParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const getExperimentAssignmentsAsCsvResponse = zod.any();

/**
 * Get the assignment for a specific participant, excluding strata if any.
    For 'preassigned' experiments, the participant's Assignment is returned if it exists.
    For 'online', returns the assignment if it exists, else generates an assignment.
 * @summary Get Experiment Assignment For Participant
 */
export const getExperimentAssignmentForParticipantParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
	participant_id: zod.string(),
});

export const getExperimentAssignmentForParticipantResponseAssignmentParticipantIdMax = 64;
export const getExperimentAssignmentForParticipantResponseAssignmentArmNameMax = 100;
export const getExperimentAssignmentForParticipantResponseAssignmentStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentAssignmentForParticipantResponseAssignmentStrataMaxOne = 150;

export const getExperimentAssignmentForParticipantResponse = zod
	.object({
		experiment_id: zod.string(),
		participant_id: zod.string(),
		assignment: zod
			.object({
				participant_id: zod
					.string()
					.max(
						getExperimentAssignmentForParticipantResponseAssignmentParticipantIdMax,
					),
				arm_id: zod
					.string()
					.describe(
						"ID of the arm this participant was assigned to. Same as Arm.arm_id.",
					),
				arm_name: zod
					.string()
					.max(
						getExperimentAssignmentForParticipantResponseAssignmentArmNameMax,
					)
					.describe(
						"The arm this participant was assigned to. Same as Arm.arm_name.",
					),
				strata: zod
					.array(
						zod
							.object({
								field_name: zod
									.string()
									.regex(
										getExperimentAssignmentForParticipantResponseAssignmentStrataItemFieldNameRegExp,
									),
								strata_value: zod.string().or(zod.null()).optional(),
							})
							.describe(
								"Describes stratification for an experiment participant.",
							),
					)
					.max(
						getExperimentAssignmentForParticipantResponseAssignmentStrataMaxOne,
					)
					.or(zod.null())
					.optional()
					.describe(
						"List of properties and their values for this participant used for stratification or tracking metrics. If stratification is not used, this will be None.",
					),
			})
			.describe("Describes treatment assignment for an experiment participant.")
			.or(zod.null())
			.describe("Null if no assignment. assignment.strata are not included."),
	})
	.describe(
		"Describes assignment for a single <experiment, participant> pair.",
	);

/**
 * @summary Power Check
 */
export const powerCheckParams = zod.object({
	datasource_id: zod.string(),
});

export const powerCheckBodyDesignSpecExperimentNameMax = 100;
export const powerCheckBodyDesignSpecDescriptionMax = 2000;
export const powerCheckBodyDesignSpecArmsItemArmNameMax = 100;
export const powerCheckBodyDesignSpecArmsItemArmDescriptionMaxOne = 2000;
export const powerCheckBodyDesignSpecArmsMin = 2;

export const powerCheckBodyDesignSpecArmsMax = 10;
export const powerCheckBodyDesignSpecStrataFieldNamesItemRegExp = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecStrataFieldNamesMax = 150;
export const powerCheckBodyDesignSpecMetricsItemFieldNameRegExp = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecMetricsMax = 150;
export const powerCheckBodyDesignSpecPowerDefault = 0.8;
export const powerCheckBodyDesignSpecPowerMin = 0;

export const powerCheckBodyDesignSpecPowerMax = 1;
export const powerCheckBodyDesignSpecAlphaDefault = 0.05;
export const powerCheckBodyDesignSpecAlphaMin = 0;

export const powerCheckBodyDesignSpecAlphaMax = 1;
export const powerCheckBodyDesignSpecFstatThreshDefault = 0.6;
export const powerCheckBodyDesignSpecFstatThreshMin = 0;

export const powerCheckBodyDesignSpecFstatThreshMax = 1;
export const powerCheckBodyDesignSpecExperimentNameMaxOne = 100;
export const powerCheckBodyDesignSpecDescriptionMaxOne = 2000;
export const powerCheckBodyDesignSpecArmsItemArmNameMaxOne = 100;
export const powerCheckBodyDesignSpecArmsItemArmDescriptionMaxFour = 2000;
export const powerCheckBodyDesignSpecArmsMinOne = 2;

export const powerCheckBodyDesignSpecArmsMaxOne = 10;
export const powerCheckBodyDesignSpecStrataFieldNamesItemRegExpOne = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecStrataFieldNamesMaxOne = 150;
export const powerCheckBodyDesignSpecMetricsItemFieldNameRegExpOne = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecMetricsMaxOne = 150;
export const powerCheckBodyDesignSpecPowerDefaultOne = 0.8;
export const powerCheckBodyDesignSpecPowerMinOne = 0;

export const powerCheckBodyDesignSpecPowerMaxOne = 1;
export const powerCheckBodyDesignSpecAlphaDefaultOne = 0.05;
export const powerCheckBodyDesignSpecAlphaMinOne = 0;

export const powerCheckBodyDesignSpecAlphaMaxOne = 1;
export const powerCheckBodyDesignSpecFstatThreshDefaultOne = 0.6;
export const powerCheckBodyDesignSpecFstatThreshMinOne = 0;

export const powerCheckBodyDesignSpecFstatThreshMaxOne = 1;
export const powerCheckBodyAudienceSpecParticipantTypeMax = 100;
export const powerCheckBodyAudienceSpecFiltersItemFieldNameRegExp = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyAudienceSpecFiltersMax = 20;

export const powerCheckBody = zod.object({
	design_spec: zod.discriminatedUnion("experiment_type", [
		zod
			.object({
				experiment_id: zod
					.string()
					.or(zod.null())
					.optional()
					.describe(
						"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
					),
				experiment_type: zod.enum(["preassigned"]),
				experiment_name: zod
					.string()
					.max(powerCheckBodyDesignSpecExperimentNameMax),
				description: zod.string().max(powerCheckBodyDesignSpecDescriptionMax),
				start_date: zod.string().datetime({}),
				end_date: zod.string().datetime({}),
				arms: zod
					.array(
						zod
							.object({
								arm_id: zod
									.string()
									.or(zod.null())
									.optional()
									.describe(
										"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
									),
								arm_name: zod
									.string()
									.max(powerCheckBodyDesignSpecArmsItemArmNameMax),
								arm_description: zod
									.string()
									.max(powerCheckBodyDesignSpecArmsItemArmDescriptionMaxOne)
									.or(zod.null())
									.optional(),
							})
							.describe("Describes an experiment treatment arm."),
					)
					.min(powerCheckBodyDesignSpecArmsMin)
					.max(powerCheckBodyDesignSpecArmsMax),
				strata_field_names: zod
					.array(
						zod
							.string()
							.regex(powerCheckBodyDesignSpecStrataFieldNamesItemRegExp),
					)
					.max(powerCheckBodyDesignSpecStrataFieldNamesMax)
					.describe(
						"List of participant_type variables to use for stratification.",
					),
				metrics: zod
					.array(
						zod
							.object({
								field_name: zod
									.string()
									.regex(powerCheckBodyDesignSpecMetricsItemFieldNameRegExp),
								metric_pct_change: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
									),
								metric_target: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
									),
							})
							.describe(
								"Defines a request to look up baseline stats for a metric to measure in an experiment.",
							),
					)
					.min(1)
					.max(powerCheckBodyDesignSpecMetricsMax)
					.describe("Primary and optional secondary metrics to target."),
				power: zod
					.number()
					.min(powerCheckBodyDesignSpecPowerMin)
					.max(powerCheckBodyDesignSpecPowerMax)
					.default(powerCheckBodyDesignSpecPowerDefault)
					.describe(
						"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
					),
				alpha: zod
					.number()
					.min(powerCheckBodyDesignSpecAlphaMin)
					.max(powerCheckBodyDesignSpecAlphaMax)
					.default(powerCheckBodyDesignSpecAlphaDefault)
					.describe(
						"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
					),
				fstat_thresh: zod
					.number()
					.min(powerCheckBodyDesignSpecFstatThreshMin)
					.max(powerCheckBodyDesignSpecFstatThreshMax)
					.default(powerCheckBodyDesignSpecFstatThreshDefault)
					.describe(
						'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
					),
			})
			.describe(
				"Use this type to randomly select and assign from existing participants at design time.",
			),
		zod
			.object({
				experiment_id: zod
					.string()
					.or(zod.null())
					.optional()
					.describe(
						"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
					),
				experiment_type: zod.enum(["online"]),
				experiment_name: zod
					.string()
					.max(powerCheckBodyDesignSpecExperimentNameMaxOne),
				description: zod
					.string()
					.max(powerCheckBodyDesignSpecDescriptionMaxOne),
				start_date: zod.string().datetime({}),
				end_date: zod.string().datetime({}),
				arms: zod
					.array(
						zod
							.object({
								arm_id: zod
									.string()
									.or(zod.null())
									.optional()
									.describe(
										"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
									),
								arm_name: zod
									.string()
									.max(powerCheckBodyDesignSpecArmsItemArmNameMaxOne),
								arm_description: zod
									.string()
									.max(powerCheckBodyDesignSpecArmsItemArmDescriptionMaxFour)
									.or(zod.null())
									.optional(),
							})
							.describe("Describes an experiment treatment arm."),
					)
					.min(powerCheckBodyDesignSpecArmsMinOne)
					.max(powerCheckBodyDesignSpecArmsMaxOne),
				strata_field_names: zod
					.array(
						zod
							.string()
							.regex(powerCheckBodyDesignSpecStrataFieldNamesItemRegExpOne),
					)
					.max(powerCheckBodyDesignSpecStrataFieldNamesMaxOne)
					.describe(
						"List of participant_type variables to use for stratification.",
					),
				metrics: zod
					.array(
						zod
							.object({
								field_name: zod
									.string()
									.regex(powerCheckBodyDesignSpecMetricsItemFieldNameRegExpOne),
								metric_pct_change: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
									),
								metric_target: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
									),
							})
							.describe(
								"Defines a request to look up baseline stats for a metric to measure in an experiment.",
							),
					)
					.min(1)
					.max(powerCheckBodyDesignSpecMetricsMaxOne)
					.describe("Primary and optional secondary metrics to target."),
				power: zod
					.number()
					.min(powerCheckBodyDesignSpecPowerMinOne)
					.max(powerCheckBodyDesignSpecPowerMaxOne)
					.default(powerCheckBodyDesignSpecPowerDefaultOne)
					.describe(
						"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
					),
				alpha: zod
					.number()
					.min(powerCheckBodyDesignSpecAlphaMinOne)
					.max(powerCheckBodyDesignSpecAlphaMaxOne)
					.default(powerCheckBodyDesignSpecAlphaDefaultOne)
					.describe(
						"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
					),
				fstat_thresh: zod
					.number()
					.min(powerCheckBodyDesignSpecFstatThreshMinOne)
					.max(powerCheckBodyDesignSpecFstatThreshMaxOne)
					.default(powerCheckBodyDesignSpecFstatThreshDefaultOne)
					.describe(
						'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
					),
			})
			.describe(
				"Use this type to randomly assign participants into arms during live experiment execution.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
			),
	]),
	audience_spec: zod
		.object({
			participant_type: zod
				.string()
				.max(powerCheckBodyAudienceSpecParticipantTypeMax),
			filters: zod
				.array(
					zod
						.object({
							field_name: zod
								.string()
								.regex(powerCheckBodyAudienceSpecFiltersItemFieldNameRegExp),
							relation: zod
								.enum(["includes", "excludes", "between"])
								.describe(
									"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
								),
							value: zod
								.array(zod.number().or(zod.null()))
								.or(zod.array(zod.number().or(zod.null())))
								.or(zod.array(zod.string().or(zod.null())))
								.or(zod.array(zod.boolean().or(zod.null()))),
						})
						.describe(
							'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value       | logical Result                                    |\n|----------|-------------|---------------------------------------------------|\n| INCLUDES | [None]      | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |\n\nString comparisons are case-sensitive.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of datetime and timestamp values\n\nDATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
						),
				)
				.max(powerCheckBodyAudienceSpecFiltersMax),
		})
		.describe("Defines target participants for an experiment using filters."),
});

export const powerCheckResponseAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const powerCheckResponseAnalysesMax = 150;

export const powerCheckResponse = zod.object({
	analyses: zod
		.array(
			zod
				.object({
					metric_spec: zod
						.object({
							field_name: zod
								.string()
								.regex(powerCheckResponseAnalysesItemMetricSpecFieldNameRegExp),
							metric_pct_change: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"Percent change target relative to the metric_baseline.",
								),
							metric_target: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"Absolute target value = metric_baseline*(1 + metric_pct_change)",
								),
							metric_type: zod
								.enum(["binary", "numeric"])
								.describe("Classifies metrics by their value type.")
								.or(zod.null())
								.optional()
								.describe("Inferred from dwh type."),
							metric_baseline: zod
								.number()
								.or(zod.null())
								.optional()
								.describe("Mean of the tracked metric."),
							metric_stddev: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"Standard deviation is set only for metric_type.NUMERIC metrics. Must be set for numeric metrics when available_n > 0.",
								),
							available_nonnull_n: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"The number of participants meeting the filtering criteria with a *non-null* value for this metric.",
								),
							available_n: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n.",
								),
						})
						.describe(
							"Defines a metric to measure in an experiment with its baseline stats.",
						),
					target_n: zod
						.number()
						.or(zod.null())
						.optional()
						.describe("Minimum sample size needed to meet the design specs."),
					sufficient_n: zod
						.boolean()
						.or(zod.null())
						.optional()
						.describe(
							"Whether or not there are enough available units to sample from to meet target_n.",
						),
					target_possible: zod
						.number()
						.or(zod.null())
						.optional()
						.describe(
							"If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.",
						),
					pct_change_possible: zod
						.number()
						.or(zod.null())
						.optional()
						.describe(
							"If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.",
						),
					msg: zod
						.object({
							type: zod
								.enum([
									"sufficient",
									"insufficient",
									"no baseline",
									"no available n",
									"zero effect size",
									"zero variation",
								])
								.describe("Classifies metric power analysis results."),
							msg: zod
								.string()
								.describe(
									"Main power analysis result stated in human-friendly English.",
								),
							source_msg: zod
								.string()
								.describe(
									"Power analysis result formatted as a template string with curly-braced {} named placeholders. Use with the dictionary of values to support localization of messages.",
								),
							values: zod
								.record(zod.string(), zod.number().or(zod.number()))
								.or(zod.null())
								.optional(),
						})
						.describe("Describes interpretation of power analysis results.")
						.or(zod.null())
						.optional()
						.describe("Human friendly message about the above results."),
				})
				.describe("Describes analysis results of a single metric."),
		)
		.max(powerCheckResponseAnalysesMax),
});
