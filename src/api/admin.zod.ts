/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Evidential Experiments API
 * OpenAPI spec version: 0.9.0
 */
import { z as zod } from "zod";

/**
 * Returns basic metadata about the authenticated caller of this method.
 * @summary Caller Identity
 */
export const callerIdentityResponse = zod
	.object({
		email: zod.string(),
		iss: zod.string(),
		sub: zod.string(),
		hd: zod.string(),
		is_privileged: zod.boolean(),
	})
	.describe(
		"Describes the user's identity in a format suitable for use in the frontend.",
	);

/**
 * Fetches a snapshot by ID.
 * @summary Get Snapshot
 */
export const getSnapshotParams = zod.object({
	organization_id: zod.string(),
	datasource_id: zod.string(),
	experiment_id: zod.string(),
	snapshot_id: zod.string(),
});

export const getSnapshotResponseSnapshotDataMetricAnalysesItemMetricFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getSnapshotResponseSnapshotDataMetricAnalysesItemArmAnalysesItemArmNameMax = 100;
export const getSnapshotResponseSnapshotDataMetricAnalysesItemArmAnalysesItemArmDescriptionMaxOne = 2000;
export const getSnapshotResponseSnapshotDataMetricAnalysesItemArmAnalysesItemNumMissingValuesMin =
	-1;
export const getSnapshotResponseSnapshotDataArmAnalysesItemArmNameMax = 100;
export const getSnapshotResponseSnapshotDataArmAnalysesItemArmDescriptionMaxOne = 2000;

export const getSnapshotResponse = zod
	.object({
		snapshot: zod
			.object({
				experiment_id: zod
					.string()
					.describe("The experiment that this snapshot was captured for."),
				id: zod.string().describe("The unique ID of the snapshot."),
				status: zod
					.enum(["success", "running", "failed"])
					.describe("Describes the status of a snapshot."),
				details: zod
					.record(zod.string(), zod.any())
					.or(zod.null())
					.describe("Additional data about this snapshot."),
				created_at: zod
					.string()
					.datetime({})
					.describe("The time the snapshot was requested."),
				updated_at: zod
					.string()
					.datetime({})
					.describe("The time the snapshot was acquired."),
				data: zod
					.object({
						type: zod.enum(["freq"]),
						experiment_id: zod.string().describe("ID of the experiment."),
						metric_analyses: zod
							.array(
								zod
									.object({
										metric_name: zod.string(),
										metric: zod
											.object({
												field_name: zod
													.string()
													.regex(
														getSnapshotResponseSnapshotDataMetricAnalysesItemMetricFieldNameRegExp,
													),
												metric_pct_change: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
													),
												metric_target: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
													),
											})
											.describe(
												"Defines a request to look up baseline stats for a metric to measure in an experiment.",
											),
										arm_analyses: zod
											.array(
												zod.object({
													arm_id: zod
														.string()
														.or(zod.null())
														.optional()
														.describe(
															"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
														),
													arm_name: zod
														.string()
														.max(
															getSnapshotResponseSnapshotDataMetricAnalysesItemArmAnalysesItemArmNameMax,
														),
													arm_description: zod
														.string()
														.max(
															getSnapshotResponseSnapshotDataMetricAnalysesItemArmAnalysesItemArmDescriptionMaxOne,
														)
														.or(zod.null())
														.optional(),
													estimate: zod
														.number()
														.describe(
															"The estimated treatment effect relative to the baseline arm.",
														),
													p_value: zod
														.number()
														.or(zod.null())
														.describe(
															"The p-value indicating statistical significance of the treatment effect. Value may be None if the t-stat is not available, e.g. due to inability to calculate the standard error.",
														),
													t_stat: zod
														.number()
														.or(zod.null())
														.describe(
															"The t-statistic from the statistical test. If the value is actually NaN, e.g. due to inability to calculate the standard error, we return None.",
														),
													std_error: zod
														.number()
														.or(zod.null())
														.describe(
															"The standard error of the treatment effect estimate.",
														),
													num_missing_values: zod
														.number()
														.min(
															getSnapshotResponseSnapshotDataMetricAnalysesItemArmAnalysesItemNumMissingValuesMin,
														)
														.describe(
															"The number of participants assigned to this arm with missing values (NaNs) for this metric. These rows are excluded from the analysis. -1 indicates arm analysis not available due to all assignments missing outcomes for this metric.",
														),
													is_baseline: zod
														.boolean()
														.describe(
															"Whether this arm is the baseline/control arm for comparison.",
														),
												}),
											)
											.describe(
												"The results of the analysis for each arm (coefficient) for this specific metric.",
											),
									})
									.describe(
										"Describes the change in a single metric for each arm of an experiment.",
									),
							)
							.describe(
								"Contains one analysis per metric targeted by the experiment.",
							),
						num_participants: zod
							.number()
							.describe(
								"The number of participants assigned to the experiment pulled from the dwh across all arms. Metric outcomes are not guaranteed to be present for all participants.",
							),
						num_missing_participants: zod
							.number()
							.or(zod.null())
							.optional()
							.describe(
								"The number of participants assigned to the experiment across all arms that are not found in the data warehouse when pulling metrics.",
							),
						created_at: zod
							.string()
							.datetime({})
							.describe(
								"The date and time the experiment analysis was created.",
							),
					})
					.describe(
						"Describes the change if any in metrics targeted by an experiment.",
					)
					.or(
						zod
							.object({
								type: zod.enum(["bandit"]),
								experiment_id: zod.string().describe("ID of the experiment."),
								arm_analyses: zod
									.array(
										zod
											.object({
												arm_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
													),
												arm_name: zod
													.string()
													.max(
														getSnapshotResponseSnapshotDataArmAnalysesItemArmNameMax,
													),
												arm_description: zod
													.string()
													.max(
														getSnapshotResponseSnapshotDataArmAnalysesItemArmDescriptionMaxOne,
													)
													.or(zod.null())
													.optional(),
												alpha_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial alpha parameter for Beta prior"),
												beta_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial beta parameter for Beta prior"),
												mu_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial mean parameter for Normal prior"),
												sigma_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Initial standard deviation parameter for Normal prior",
													),
												alpha: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Updated alpha parameter for Beta prior"),
												beta: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Updated beta parameter for Beta prior"),
												mu: zod
													.array(zod.number())
													.or(zod.null())
													.optional()
													.describe("Updated mean vector for Normal prior"),
												covariance: zod
													.array(zod.array(zod.number()))
													.or(zod.null())
													.optional()
													.describe(
														"Updated covariance matrix for Normal prior",
													),
												prior_pred_mean: zod
													.number()
													.describe("Posterior predictive mean for this arm."),
												prior_pred_stdev: zod
													.number()
													.describe(
														"Posterior predictive standard deviation for this arm.",
													),
												post_pred_mean: zod
													.number()
													.describe("Posterior predictive mean for this arm."),
												post_pred_stdev: zod
													.number()
													.describe(
														"Posterior predictive standard deviation for this arm.",
													),
											})
											.describe(
												"Describes an experiment arm analysis for bandit experiments.",
											),
									)
									.describe(
										"Contains one analysis per metric targeted by the experiment.",
									),
								n_outcomes: zod
									.number()
									.describe(
										"The number of outcomes observed for this experiment.",
									),
								created_at: zod
									.string()
									.datetime({})
									.describe(
										"The date and time the experiment analysis was created.",
									),
								contexts: zod
									.array(zod.number())
									.or(zod.null())
									.optional()
									.describe(
										"The context values used for the analysis, if applicable.",
									),
							})
							.describe("Describes changes in arms for a bandit experiment"),
					)
					.describe("The type of experiment analysis response.")
					.or(zod.null())
					.describe("Analysis results as of the updated_at time."),
			})
			.or(zod.null())
			.describe("The completed snapshot."),
	})
	.describe("Describes the status and content of a snapshot.");

/**
 * Deletes a snapshot.
 * @summary Delete Snapshot
 */
export const deleteSnapshotParams = zod.object({
	organization_id: zod.string(),
	datasource_id: zod.string(),
	experiment_id: zod.string(),
	snapshot_id: zod.string(),
});

export const deleteSnapshotQueryAllowMissingDefault = false;

export const deleteSnapshotQueryParams = zod.object({
	allow_missing: zod
		.boolean()
		.optional()
		.describe("If true, return a 204 even if the resource does not exist."),
});

export const deleteSnapshotResponse = zod.any();

/**
 * Lists snapshots for an experiment, ordered by timestamp.
 * @summary List Snapshots
 */
export const listSnapshotsParams = zod.object({
	organization_id: zod.string(),
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const listSnapshotsQueryParams = zod.object({
	status: zod
		.array(
			zod
				.enum(["success", "running", "failed"])
				.describe("Describes the status of a snapshot."),
		)
		.or(zod.null())
		.optional()
		.describe(
			"Filter the returned snapshots to only those of this status. May be specified multiple times.",
		),
});

export const listSnapshotsResponseItemsItemDataMetricAnalysesItemMetricFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listSnapshotsResponseItemsItemDataMetricAnalysesItemArmAnalysesItemArmNameMax = 100;
export const listSnapshotsResponseItemsItemDataMetricAnalysesItemArmAnalysesItemArmDescriptionMaxOne = 2000;
export const listSnapshotsResponseItemsItemDataMetricAnalysesItemArmAnalysesItemNumMissingValuesMin =
	-1;
export const listSnapshotsResponseItemsItemDataArmAnalysesItemArmNameMax = 100;
export const listSnapshotsResponseItemsItemDataArmAnalysesItemArmDescriptionMaxOne = 2000;

export const listSnapshotsResponse = zod.object({
	items: zod.array(
		zod.object({
			experiment_id: zod
				.string()
				.describe("The experiment that this snapshot was captured for."),
			id: zod.string().describe("The unique ID of the snapshot."),
			status: zod
				.enum(["success", "running", "failed"])
				.describe("Describes the status of a snapshot."),
			details: zod
				.record(zod.string(), zod.any())
				.or(zod.null())
				.describe("Additional data about this snapshot."),
			created_at: zod
				.string()
				.datetime({})
				.describe("The time the snapshot was requested."),
			updated_at: zod
				.string()
				.datetime({})
				.describe("The time the snapshot was acquired."),
			data: zod
				.object({
					type: zod.enum(["freq"]),
					experiment_id: zod.string().describe("ID of the experiment."),
					metric_analyses: zod
						.array(
							zod
								.object({
									metric_name: zod.string(),
									metric: zod
										.object({
											field_name: zod
												.string()
												.regex(
													listSnapshotsResponseItemsItemDataMetricAnalysesItemMetricFieldNameRegExp,
												),
											metric_pct_change: zod
												.number()
												.or(zod.null())
												.optional()
												.describe(
													"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
												),
											metric_target: zod
												.number()
												.or(zod.null())
												.optional()
												.describe(
													"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
												),
										})
										.describe(
											"Defines a request to look up baseline stats for a metric to measure in an experiment.",
										),
									arm_analyses: zod
										.array(
											zod.object({
												arm_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
													),
												arm_name: zod
													.string()
													.max(
														listSnapshotsResponseItemsItemDataMetricAnalysesItemArmAnalysesItemArmNameMax,
													),
												arm_description: zod
													.string()
													.max(
														listSnapshotsResponseItemsItemDataMetricAnalysesItemArmAnalysesItemArmDescriptionMaxOne,
													)
													.or(zod.null())
													.optional(),
												estimate: zod
													.number()
													.describe(
														"The estimated treatment effect relative to the baseline arm.",
													),
												p_value: zod
													.number()
													.or(zod.null())
													.describe(
														"The p-value indicating statistical significance of the treatment effect. Value may be None if the t-stat is not available, e.g. due to inability to calculate the standard error.",
													),
												t_stat: zod
													.number()
													.or(zod.null())
													.describe(
														"The t-statistic from the statistical test. If the value is actually NaN, e.g. due to inability to calculate the standard error, we return None.",
													),
												std_error: zod
													.number()
													.or(zod.null())
													.describe(
														"The standard error of the treatment effect estimate.",
													),
												num_missing_values: zod
													.number()
													.min(
														listSnapshotsResponseItemsItemDataMetricAnalysesItemArmAnalysesItemNumMissingValuesMin,
													)
													.describe(
														"The number of participants assigned to this arm with missing values (NaNs) for this metric. These rows are excluded from the analysis. -1 indicates arm analysis not available due to all assignments missing outcomes for this metric.",
													),
												is_baseline: zod
													.boolean()
													.describe(
														"Whether this arm is the baseline/control arm for comparison.",
													),
											}),
										)
										.describe(
											"The results of the analysis for each arm (coefficient) for this specific metric.",
										),
								})
								.describe(
									"Describes the change in a single metric for each arm of an experiment.",
								),
						)
						.describe(
							"Contains one analysis per metric targeted by the experiment.",
						),
					num_participants: zod
						.number()
						.describe(
							"The number of participants assigned to the experiment pulled from the dwh across all arms. Metric outcomes are not guaranteed to be present for all participants.",
						),
					num_missing_participants: zod
						.number()
						.or(zod.null())
						.optional()
						.describe(
							"The number of participants assigned to the experiment across all arms that are not found in the data warehouse when pulling metrics.",
						),
					created_at: zod
						.string()
						.datetime({})
						.describe("The date and time the experiment analysis was created."),
				})
				.describe(
					"Describes the change if any in metrics targeted by an experiment.",
				)
				.or(
					zod
						.object({
							type: zod.enum(["bandit"]),
							experiment_id: zod.string().describe("ID of the experiment."),
							arm_analyses: zod
								.array(
									zod
										.object({
											arm_id: zod
												.string()
												.or(zod.null())
												.optional()
												.describe(
													"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
												),
											arm_name: zod
												.string()
												.max(
													listSnapshotsResponseItemsItemDataArmAnalysesItemArmNameMax,
												),
											arm_description: zod
												.string()
												.max(
													listSnapshotsResponseItemsItemDataArmAnalysesItemArmDescriptionMaxOne,
												)
												.or(zod.null())
												.optional(),
											alpha_init: zod
												.number()
												.or(zod.null())
												.optional()
												.describe("Initial alpha parameter for Beta prior"),
											beta_init: zod
												.number()
												.or(zod.null())
												.optional()
												.describe("Initial beta parameter for Beta prior"),
											mu_init: zod
												.number()
												.or(zod.null())
												.optional()
												.describe("Initial mean parameter for Normal prior"),
											sigma_init: zod
												.number()
												.or(zod.null())
												.optional()
												.describe(
													"Initial standard deviation parameter for Normal prior",
												),
											alpha: zod
												.number()
												.or(zod.null())
												.optional()
												.describe("Updated alpha parameter for Beta prior"),
											beta: zod
												.number()
												.or(zod.null())
												.optional()
												.describe("Updated beta parameter for Beta prior"),
											mu: zod
												.array(zod.number())
												.or(zod.null())
												.optional()
												.describe("Updated mean vector for Normal prior"),
											covariance: zod
												.array(zod.array(zod.number()))
												.or(zod.null())
												.optional()
												.describe("Updated covariance matrix for Normal prior"),
											prior_pred_mean: zod
												.number()
												.describe("Posterior predictive mean for this arm."),
											prior_pred_stdev: zod
												.number()
												.describe(
													"Posterior predictive standard deviation for this arm.",
												),
											post_pred_mean: zod
												.number()
												.describe("Posterior predictive mean for this arm."),
											post_pred_stdev: zod
												.number()
												.describe(
													"Posterior predictive standard deviation for this arm.",
												),
										})
										.describe(
											"Describes an experiment arm analysis for bandit experiments.",
										),
								)
								.describe(
									"Contains one analysis per metric targeted by the experiment.",
								),
							n_outcomes: zod
								.number()
								.describe(
									"The number of outcomes observed for this experiment.",
								),
							created_at: zod
								.string()
								.datetime({})
								.describe(
									"The date and time the experiment analysis was created.",
								),
							contexts: zod
								.array(zod.number())
								.or(zod.null())
								.optional()
								.describe(
									"The context values used for the analysis, if applicable.",
								),
						})
						.describe("Describes changes in arms for a bandit experiment"),
				)
				.describe("The type of experiment analysis response.")
				.or(zod.null())
				.describe("Analysis results as of the updated_at time."),
		}),
	),
});

/**
 * Request the asynchronous creation of a snapshot for an experiment.

Returns the ID of the snapshot. Poll get_snapshot until the job is completed.
 * @summary Create Snapshot
 */
export const createSnapshotParams = zod.object({
	organization_id: zod.string(),
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const createSnapshotResponse = zod.object({
	id: zod.string(),
});

/**
 * Returns a list of organizations that the authenticated user is a member of.
 * @summary List Organizations
 */
export const listOrganizationsResponseItemsItemIdMax = 64;
export const listOrganizationsResponseItemsItemNameMax = 100;

export const listOrganizationsResponse = zod.object({
	items: zod.array(
		zod.object({
			id: zod.string().max(listOrganizationsResponseItemsItemIdMax),
			name: zod.string().max(listOrganizationsResponseItemsItemNameMax),
		}),
	),
});

/**
 * Creates a new organization.

Only privileged users can create organizations.
 * @summary Create Organizations
 */
export const createOrganizationsBodyNameMax = 100;

export const createOrganizationsBody = zod.object({
	name: zod.string().max(createOrganizationsBodyNameMax),
});

export const createOrganizationsResponseIdMax = 64;

export const createOrganizationsResponse = zod.object({
	id: zod.string().max(createOrganizationsResponseIdMax),
});

/**
 * Adds a Webhook to an organization.
 * @summary Add Webhook To Organization
 */
export const addWebhookToOrganizationParams = zod.object({
	organization_id: zod.string(),
});

export const addWebhookToOrganizationBodyNameMax = 100;
export const addWebhookToOrganizationBodyUrlMax = 500;

export const addWebhookToOrganizationBody = zod.object({
	type: zod.string(),
	name: zod
		.string()
		.max(addWebhookToOrganizationBodyNameMax)
		.describe(
			"User-friendly name for the webhook. This name is displayed in the UI and helps identify the webhook's purpose.",
		),
	url: zod
		.string()
		.max(addWebhookToOrganizationBodyUrlMax)
		.describe(
			"The HTTP or HTTPS URL that will receive webhook notifications when events occur.",
		),
});

export const addWebhookToOrganizationResponse = zod
	.object({
		id: zod.string().describe("The ID of the newly created webhook."),
		type: zod.string().describe("The type of webhook; e.g. experiment.created"),
		name: zod.string().describe("User-friendly name for the webhook."),
		url: zod.string().describe("The URL to notify."),
		auth_token: zod
			.string()
			.or(zod.null())
			.describe(
				"The value of the Webhook-Token: header that will be sent with the request to the configured URL.",
			),
	})
	.describe("Information on the successfully created webhook.");

/**
 * Lists all the webhooks for an organization.
 * @summary List Organization Webhooks
 */
export const listOrganizationWebhooksParams = zod.object({
	organization_id: zod.string(),
});

export const listOrganizationWebhooksResponse = zod.object({
	items: zod.array(
		zod
			.object({
				id: zod.string().describe("The ID of the webhook."),
				type: zod
					.string()
					.describe("The type of webhook; e.g. experiment.created"),
				name: zod.string().describe("User-friendly name for the webhook."),
				url: zod.string().describe("The URL to notify."),
				auth_token: zod
					.string()
					.or(zod.null())
					.describe(
						"The value of the Webhook-Token: header that will be sent with the request to the configured URL.",
					),
			})
			.describe("Summarizes a Webhook configuration for an organization."),
	),
});

/**
 * Updates a webhook's name and URL in an organization.
 * @summary Update Organization Webhook
 */
export const updateOrganizationWebhookParams = zod.object({
	organization_id: zod.string(),
	webhook_id: zod.string(),
});

export const updateOrganizationWebhookBodyNameMax = 100;
export const updateOrganizationWebhookBodyUrlMax = 500;

export const updateOrganizationWebhookBody = zod
	.object({
		name: zod
			.string()
			.max(updateOrganizationWebhookBodyNameMax)
			.describe(
				"User-friendly name for the webhook. This name is displayed in the UI and helps identify the webhook's purpose.",
			),
		url: zod
			.string()
			.max(updateOrganizationWebhookBodyUrlMax)
			.describe(
				"The HTTP or HTTPS URL that will receive webhook notifications when events occur.",
			),
	})
	.describe("Request to update a webhook's name and URL.");

/**
 * Removes a Webhook from an organization.
 * @summary Delete Webhook From Organization
 */
export const deleteWebhookFromOrganizationParams = zod.object({
	organization_id: zod.string(),
	webhook_id: zod.string(),
});

export const deleteWebhookFromOrganizationQueryAllowMissingDefault = false;

export const deleteWebhookFromOrganizationQueryParams = zod.object({
	allow_missing: zod
		.boolean()
		.optional()
		.describe("If true, return a 204 even if the resource does not exist."),
});

/**
 * Regenerates the auth token for a webhook in an organization.
 * @summary Regenerate Webhook Auth Token
 */
export const regenerateWebhookAuthTokenParams = zod.object({
	organization_id: zod.string(),
	webhook_id: zod.string(),
});

/**
 * Returns the most recent 200 events in an organization.
 * @summary List Organization Events
 */
export const listOrganizationEventsParams = zod.object({
	organization_id: zod.string(),
});

export const listOrganizationEventsResponse = zod.object({
	items: zod.array(
		zod
			.object({
				id: zod.string().describe("The ID of the event."),
				created_at: zod
					.string()
					.datetime({})
					.describe("The time the event was created."),
				type: zod.string().describe("The type of event."),
				summary: zod.string().describe("Human-readable summary of the event."),
				link: zod
					.string()
					.or(zod.null())
					.optional()
					.describe("A navigable link to related information."),
				details: zod
					.record(zod.string(), zod.any())
					.or(zod.null())
					.describe("Details"),
			})
			.describe("Describes an event."),
	),
});

/**
 * Adds a new member to an organization.

The authenticated user must be part of the organization to add members.
 * @summary Add Member To Organization
 */
export const addMemberToOrganizationParams = zod.object({
	organization_id: zod.string(),
});

export const addMemberToOrganizationBody = zod.object({
	email: zod.string(),
});

/**
 * Removes a member from an organization.

The authenticated user must be part of the organization to remove members.
 * @summary Remove Member From Organization
 */
export const removeMemberFromOrganizationParams = zod.object({
	organization_id: zod.string(),
	user_id: zod.string(),
});

export const removeMemberFromOrganizationQueryAllowMissingDefault = false;

export const removeMemberFromOrganizationQueryParams = zod.object({
	allow_missing: zod
		.boolean()
		.optional()
		.describe("If true, return a 204 even if the resource does not exist."),
});

/**
 * Updates an organization's properties.

The authenticated user must be a member of the organization.
Currently only supports updating the organization name.
 * @summary Update Organization
 */
export const updateOrganizationParams = zod.object({
	organization_id: zod.string(),
});

export const updateOrganizationBodyNameMaxOne = 100;

export const updateOrganizationBody = zod.object({
	name: zod
		.string()
		.max(updateOrganizationBodyNameMaxOne)
		.or(zod.null())
		.optional(),
});

export const updateOrganizationResponse = zod.any();

/**
 * Returns detailed information about a specific organization.

The authenticated user must be a member of the organization.
 * @summary Get Organization
 */
export const getOrganizationParams = zod.object({
	organization_id: zod.string(),
});

export const getOrganizationResponseIdMax = 64;
export const getOrganizationResponseNameMax = 100;
export const getOrganizationResponseUsersItemIdMax = 64;
export const getOrganizationResponseUsersItemEmailMax = 64;
export const getOrganizationResponseDatasourcesItemIdMax = 64;
export const getOrganizationResponseDatasourcesItemNameMax = 100;
export const getOrganizationResponseDatasourcesItemOrganizationIdMax = 64;
export const getOrganizationResponseDatasourcesItemOrganizationNameMax = 100;

export const getOrganizationResponse = zod.object({
	id: zod.string().max(getOrganizationResponseIdMax),
	name: zod.string().max(getOrganizationResponseNameMax),
	users: zod.array(
		zod.object({
			id: zod.string().max(getOrganizationResponseUsersItemIdMax),
			email: zod.string().max(getOrganizationResponseUsersItemEmailMax),
		}),
	),
	datasources: zod.array(
		zod.object({
			id: zod.string().max(getOrganizationResponseDatasourcesItemIdMax),
			name: zod.string().max(getOrganizationResponseDatasourcesItemNameMax),
			driver: zod.string(),
			type: zod.string(),
			organization_id: zod
				.string()
				.max(getOrganizationResponseDatasourcesItemOrganizationIdMax),
			organization_name: zod
				.string()
				.max(getOrganizationResponseDatasourcesItemOrganizationNameMax),
		}),
	),
});

/**
 * Returns a list of datasources accessible to the authenticated user for an org.
 * @summary List Organization Datasources
 */
export const listOrganizationDatasourcesParams = zod.object({
	organization_id: zod.string(),
});

export const listOrganizationDatasourcesResponseItemsItemIdMax = 64;
export const listOrganizationDatasourcesResponseItemsItemNameMax = 100;
export const listOrganizationDatasourcesResponseItemsItemOrganizationIdMax = 64;
export const listOrganizationDatasourcesResponseItemsItemOrganizationNameMax = 100;

export const listOrganizationDatasourcesResponse = zod.object({
	items: zod.array(
		zod.object({
			id: zod.string().max(listOrganizationDatasourcesResponseItemsItemIdMax),
			name: zod
				.string()
				.max(listOrganizationDatasourcesResponseItemsItemNameMax),
			driver: zod.string(),
			type: zod.string(),
			organization_id: zod
				.string()
				.max(listOrganizationDatasourcesResponseItemsItemOrganizationIdMax),
			organization_name: zod
				.string()
				.max(listOrganizationDatasourcesResponseItemsItemOrganizationNameMax),
		}),
	),
});

/**
 * Creates a new datasource for the specified organization.
 * @summary Create Datasource
 */
export const createDatasourceBodyOrganizationIdMax = 64;
export const createDatasourceBodyDsnPortMin = 1024;

export const createDatasourceBodyDsnPortMax = 65535;
export const createDatasourceBodyDsnPasswordTypeDefault = "revealed";
export const createDatasourceBodyDsnPasswordTypeDefaultOne = "hidden";
export const createDatasourceBodyDsnProjectIdMin = 6;

export const createDatasourceBodyDsnProjectIdMax = 30;

export const createDatasourceBodyDsnProjectIdRegExp = new RegExp(
	"^[a-z0-9-]+$",
);
export const createDatasourceBodyDsnDatasetIdMax = 1024;

export const createDatasourceBodyDsnDatasetIdRegExp = new RegExp(
	"^[a-zA-Z0-9_]+$",
);
export const createDatasourceBodyDsnCredentialsTypeDefault =
	"serviceaccountinfo";
export const createDatasourceBodyDsnCredentialsContentMin = 4;

export const createDatasourceBodyDsnCredentialsContentMax = 8000;
export const createDatasourceBodyDsnCredentialsTypeDefaultOne = "hidden";
export const createDatasourceBodyDsnPortMinOne = 1024;

export const createDatasourceBodyDsnPortMaxOne = 65535;
export const createDatasourceBodyDsnPasswordTypeDefaultTwo = "revealed";
export const createDatasourceBodyDsnPasswordTypeDefaultThree = "hidden";

export const createDatasourceBody = zod.object({
	organization_id: zod.string().max(createDatasourceBodyOrganizationIdMax),
	name: zod.string(),
	dsn: zod
		.object({
			type: zod.enum(["api_only"]),
		})
		.describe(
			"ApiOnlyDsn describes a datasource where data is included in Evidential API requests.",
		)
		.or(
			zod
				.object({
					type: zod.enum(["postgres"]),
					host: zod.string(),
					port: zod
						.number()
						.min(createDatasourceBodyDsnPortMin)
						.max(createDatasourceBodyDsnPortMax),
					user: zod.string(),
					password: zod
						.object({
							type: zod
								.string()
								.default(createDatasourceBodyDsnPasswordTypeDefault),
							value: zod.string(),
						})
						.describe("RevealedStr contains a credential.")
						.or(
							zod
								.object({
									type: zod
										.string()
										.default(createDatasourceBodyDsnPasswordTypeDefaultOne),
								})
								.describe(
									"Hidden represents a credential that is intentionally omitted.",
								),
						)
						.describe(
							"This value must be a RevealedStr when creating the datasource or when updating a datasource's credentials. It may be a Hidden when updating a datasource. When hidden, the existing credentials are retained.",
						),
					dbname: zod.string(),
					sslmode: zod.enum(["disable", "require", "verify-ca", "verify-full"]),
					search_path: zod.string().or(zod.null()),
				})
				.describe(
					"PostgresDsn describes a connection to a Postgres-compatible database.",
				),
		)
		.or(
			zod
				.object({
					type: zod.enum(["bigquery"]),
					project_id: zod
						.string()
						.min(createDatasourceBodyDsnProjectIdMin)
						.max(createDatasourceBodyDsnProjectIdMax)
						.regex(createDatasourceBodyDsnProjectIdRegExp)
						.describe("The Google Cloud Project ID containing the dataset."),
					dataset_id: zod
						.string()
						.min(1)
						.max(createDatasourceBodyDsnDatasetIdMax)
						.regex(createDatasourceBodyDsnDatasetIdRegExp)
						.describe("The dataset name."),
					credentials: zod
						.object({
							type: zod
								.string()
								.default(createDatasourceBodyDsnCredentialsTypeDefault),
							content: zod
								.string()
								.min(createDatasourceBodyDsnCredentialsContentMin)
								.max(createDatasourceBodyDsnCredentialsContentMax)
								.describe(
									"The service account info in the canonical JSON form. Required fields: type, project_id, private_key_id, private_key, client_email.",
								),
						})
						.describe("Describes a Google Cloud Platform service account.")
						.or(
							zod
								.object({
									type: zod
										.string()
										.default(createDatasourceBodyDsnCredentialsTypeDefaultOne),
								})
								.describe(
									"Hidden represents a credential that is intentionally omitted.",
								),
						)
						.describe(
							"This value must be a GcpServiceAccount when creating the datasource or when updating a datasource's credentials. It may be a Hidden when updating a datasource. When hidden, the existing credentials are retained.",
						),
				})
				.describe("BqDsn describes a connection to a BigQuery database."),
		)
		.or(
			zod
				.object({
					type: zod.enum(["redshift"]),
					host: zod.string(),
					port: zod
						.number()
						.min(createDatasourceBodyDsnPortMinOne)
						.max(createDatasourceBodyDsnPortMaxOne),
					user: zod.string(),
					password: zod
						.object({
							type: zod
								.string()
								.default(createDatasourceBodyDsnPasswordTypeDefaultTwo),
							value: zod.string(),
						})
						.describe("RevealedStr contains a credential.")
						.or(
							zod
								.object({
									type: zod
										.string()
										.default(createDatasourceBodyDsnPasswordTypeDefaultThree),
								})
								.describe(
									"Hidden represents a credential that is intentionally omitted.",
								),
						)
						.describe(
							"This value must be a RevealedStr when creating the datasource or when updating a datasource's credentials. It may be a Hidden when updating a datasource. When hidden, the existing credentials are retained.",
						),
					dbname: zod.string(),
					search_path: zod.string().or(zod.null()),
				})
				.describe("RedshiftDsn describes a connection to a Redshift database."),
		),
});

export const createDatasourceResponseIdMax = 64;

export const createDatasourceResponse = zod.object({
	id: zod.string().max(createDatasourceResponseIdMax),
});

/**
 * @summary Update Datasource
 */
export const updateDatasourceParams = zod.object({
	datasource_id: zod.string(),
});

export const updateDatasourceBodyNameMaxOne = 100;
export const updateDatasourceBodyDsnPortMin = 1024;

export const updateDatasourceBodyDsnPortMax = 65535;
export const updateDatasourceBodyDsnPasswordTypeDefault = "revealed";
export const updateDatasourceBodyDsnPasswordTypeDefaultOne = "hidden";
export const updateDatasourceBodyDsnProjectIdMin = 6;

export const updateDatasourceBodyDsnProjectIdMax = 30;

export const updateDatasourceBodyDsnProjectIdRegExp = new RegExp(
	"^[a-z0-9-]+$",
);
export const updateDatasourceBodyDsnDatasetIdMax = 1024;

export const updateDatasourceBodyDsnDatasetIdRegExp = new RegExp(
	"^[a-zA-Z0-9_]+$",
);
export const updateDatasourceBodyDsnCredentialsTypeDefault =
	"serviceaccountinfo";
export const updateDatasourceBodyDsnCredentialsContentMin = 4;

export const updateDatasourceBodyDsnCredentialsContentMax = 8000;
export const updateDatasourceBodyDsnCredentialsTypeDefaultOne = "hidden";
export const updateDatasourceBodyDsnPortMinOne = 1024;

export const updateDatasourceBodyDsnPortMaxOne = 65535;
export const updateDatasourceBodyDsnPasswordTypeDefaultTwo = "revealed";
export const updateDatasourceBodyDsnPasswordTypeDefaultThree = "hidden";

export const updateDatasourceBody = zod.object({
	name: zod
		.string()
		.max(updateDatasourceBodyNameMaxOne)
		.or(zod.null())
		.optional(),
	dsn: zod
		.object({
			type: zod.enum(["api_only"]),
		})
		.describe(
			"ApiOnlyDsn describes a datasource where data is included in Evidential API requests.",
		)
		.or(
			zod
				.object({
					type: zod.enum(["postgres"]),
					host: zod.string(),
					port: zod
						.number()
						.min(updateDatasourceBodyDsnPortMin)
						.max(updateDatasourceBodyDsnPortMax),
					user: zod.string(),
					password: zod
						.object({
							type: zod
								.string()
								.default(updateDatasourceBodyDsnPasswordTypeDefault),
							value: zod.string(),
						})
						.describe("RevealedStr contains a credential.")
						.or(
							zod
								.object({
									type: zod
										.string()
										.default(updateDatasourceBodyDsnPasswordTypeDefaultOne),
								})
								.describe(
									"Hidden represents a credential that is intentionally omitted.",
								),
						)
						.describe(
							"This value must be a RevealedStr when creating the datasource or when updating a datasource's credentials. It may be a Hidden when updating a datasource. When hidden, the existing credentials are retained.",
						),
					dbname: zod.string(),
					sslmode: zod.enum(["disable", "require", "verify-ca", "verify-full"]),
					search_path: zod.string().or(zod.null()),
				})
				.describe(
					"PostgresDsn describes a connection to a Postgres-compatible database.",
				),
		)
		.or(
			zod
				.object({
					type: zod.enum(["bigquery"]),
					project_id: zod
						.string()
						.min(updateDatasourceBodyDsnProjectIdMin)
						.max(updateDatasourceBodyDsnProjectIdMax)
						.regex(updateDatasourceBodyDsnProjectIdRegExp)
						.describe("The Google Cloud Project ID containing the dataset."),
					dataset_id: zod
						.string()
						.min(1)
						.max(updateDatasourceBodyDsnDatasetIdMax)
						.regex(updateDatasourceBodyDsnDatasetIdRegExp)
						.describe("The dataset name."),
					credentials: zod
						.object({
							type: zod
								.string()
								.default(updateDatasourceBodyDsnCredentialsTypeDefault),
							content: zod
								.string()
								.min(updateDatasourceBodyDsnCredentialsContentMin)
								.max(updateDatasourceBodyDsnCredentialsContentMax)
								.describe(
									"The service account info in the canonical JSON form. Required fields: type, project_id, private_key_id, private_key, client_email.",
								),
						})
						.describe("Describes a Google Cloud Platform service account.")
						.or(
							zod
								.object({
									type: zod
										.string()
										.default(updateDatasourceBodyDsnCredentialsTypeDefaultOne),
								})
								.describe(
									"Hidden represents a credential that is intentionally omitted.",
								),
						)
						.describe(
							"This value must be a GcpServiceAccount when creating the datasource or when updating a datasource's credentials. It may be a Hidden when updating a datasource. When hidden, the existing credentials are retained.",
						),
				})
				.describe("BqDsn describes a connection to a BigQuery database."),
		)
		.or(
			zod
				.object({
					type: zod.enum(["redshift"]),
					host: zod.string(),
					port: zod
						.number()
						.min(updateDatasourceBodyDsnPortMinOne)
						.max(updateDatasourceBodyDsnPortMaxOne),
					user: zod.string(),
					password: zod
						.object({
							type: zod
								.string()
								.default(updateDatasourceBodyDsnPasswordTypeDefaultTwo),
							value: zod.string(),
						})
						.describe("RevealedStr contains a credential.")
						.or(
							zod
								.object({
									type: zod
										.string()
										.default(updateDatasourceBodyDsnPasswordTypeDefaultThree),
								})
								.describe(
									"Hidden represents a credential that is intentionally omitted.",
								),
						)
						.describe(
							"This value must be a RevealedStr when creating the datasource or when updating a datasource's credentials. It may be a Hidden when updating a datasource. When hidden, the existing credentials are retained.",
						),
					dbname: zod.string(),
					search_path: zod.string().or(zod.null()),
				})
				.describe("RedshiftDsn describes a connection to a Redshift database."),
		)
		.or(zod.null())
		.optional(),
});

/**
 * Returns detailed information about a specific datasource.
 * @summary Get Datasource
 */
export const getDatasourceParams = zod.object({
	datasource_id: zod.string(),
});

export const getDatasourceResponseIdMax = 64;
export const getDatasourceResponseNameMax = 100;
export const getDatasourceResponseDsnPortMin = 1024;

export const getDatasourceResponseDsnPortMax = 65535;
export const getDatasourceResponseDsnPasswordTypeDefault = "revealed";
export const getDatasourceResponseDsnPasswordTypeDefaultOne = "hidden";
export const getDatasourceResponseDsnProjectIdMin = 6;

export const getDatasourceResponseDsnProjectIdMax = 30;

export const getDatasourceResponseDsnProjectIdRegExp = new RegExp(
	"^[a-z0-9-]+$",
);
export const getDatasourceResponseDsnDatasetIdMax = 1024;

export const getDatasourceResponseDsnDatasetIdRegExp = new RegExp(
	"^[a-zA-Z0-9_]+$",
);
export const getDatasourceResponseDsnCredentialsTypeDefault =
	"serviceaccountinfo";
export const getDatasourceResponseDsnCredentialsContentMin = 4;

export const getDatasourceResponseDsnCredentialsContentMax = 8000;
export const getDatasourceResponseDsnCredentialsTypeDefaultOne = "hidden";
export const getDatasourceResponseDsnPortMinOne = 1024;

export const getDatasourceResponseDsnPortMaxOne = 65535;
export const getDatasourceResponseDsnPasswordTypeDefaultTwo = "revealed";
export const getDatasourceResponseDsnPasswordTypeDefaultThree = "hidden";
export const getDatasourceResponseOrganizationIdMax = 64;
export const getDatasourceResponseOrganizationNameMax = 100;

export const getDatasourceResponse = zod.object({
	id: zod.string().max(getDatasourceResponseIdMax),
	name: zod.string().max(getDatasourceResponseNameMax),
	dsn: zod
		.object({
			type: zod.enum(["api_only"]),
		})
		.describe(
			"ApiOnlyDsn describes a datasource where data is included in Evidential API requests.",
		)
		.or(
			zod
				.object({
					type: zod.enum(["postgres"]),
					host: zod.string(),
					port: zod
						.number()
						.min(getDatasourceResponseDsnPortMin)
						.max(getDatasourceResponseDsnPortMax),
					user: zod.string(),
					password: zod
						.object({
							type: zod
								.string()
								.default(getDatasourceResponseDsnPasswordTypeDefault),
							value: zod.string(),
						})
						.describe("RevealedStr contains a credential.")
						.or(
							zod
								.object({
									type: zod
										.string()
										.default(getDatasourceResponseDsnPasswordTypeDefaultOne),
								})
								.describe(
									"Hidden represents a credential that is intentionally omitted.",
								),
						)
						.describe(
							"This value must be a RevealedStr when creating the datasource or when updating a datasource's credentials. It may be a Hidden when updating a datasource. When hidden, the existing credentials are retained.",
						),
					dbname: zod.string(),
					sslmode: zod.enum(["disable", "require", "verify-ca", "verify-full"]),
					search_path: zod.string().or(zod.null()),
				})
				.describe(
					"PostgresDsn describes a connection to a Postgres-compatible database.",
				),
		)
		.or(
			zod
				.object({
					type: zod.enum(["bigquery"]),
					project_id: zod
						.string()
						.min(getDatasourceResponseDsnProjectIdMin)
						.max(getDatasourceResponseDsnProjectIdMax)
						.regex(getDatasourceResponseDsnProjectIdRegExp)
						.describe("The Google Cloud Project ID containing the dataset."),
					dataset_id: zod
						.string()
						.min(1)
						.max(getDatasourceResponseDsnDatasetIdMax)
						.regex(getDatasourceResponseDsnDatasetIdRegExp)
						.describe("The dataset name."),
					credentials: zod
						.object({
							type: zod
								.string()
								.default(getDatasourceResponseDsnCredentialsTypeDefault),
							content: zod
								.string()
								.min(getDatasourceResponseDsnCredentialsContentMin)
								.max(getDatasourceResponseDsnCredentialsContentMax)
								.describe(
									"The service account info in the canonical JSON form. Required fields: type, project_id, private_key_id, private_key, client_email.",
								),
						})
						.describe("Describes a Google Cloud Platform service account.")
						.or(
							zod
								.object({
									type: zod
										.string()
										.default(getDatasourceResponseDsnCredentialsTypeDefaultOne),
								})
								.describe(
									"Hidden represents a credential that is intentionally omitted.",
								),
						)
						.describe(
							"This value must be a GcpServiceAccount when creating the datasource or when updating a datasource's credentials. It may be a Hidden when updating a datasource. When hidden, the existing credentials are retained.",
						),
				})
				.describe("BqDsn describes a connection to a BigQuery database."),
		)
		.or(
			zod
				.object({
					type: zod.enum(["redshift"]),
					host: zod.string(),
					port: zod
						.number()
						.min(getDatasourceResponseDsnPortMinOne)
						.max(getDatasourceResponseDsnPortMaxOne),
					user: zod.string(),
					password: zod
						.object({
							type: zod
								.string()
								.default(getDatasourceResponseDsnPasswordTypeDefaultTwo),
							value: zod.string(),
						})
						.describe("RevealedStr contains a credential.")
						.or(
							zod
								.object({
									type: zod
										.string()
										.default(getDatasourceResponseDsnPasswordTypeDefaultThree),
								})
								.describe(
									"Hidden represents a credential that is intentionally omitted.",
								),
						)
						.describe(
							"This value must be a RevealedStr when creating the datasource or when updating a datasource's credentials. It may be a Hidden when updating a datasource. When hidden, the existing credentials are retained.",
						),
					dbname: zod.string(),
					search_path: zod.string().or(zod.null()),
				})
				.describe("RedshiftDsn describes a connection to a Redshift database."),
		),
	organization_id: zod.string().max(getDatasourceResponseOrganizationIdMax),
	organization_name: zod.string().max(getDatasourceResponseOrganizationNameMax),
});

/**
 * Verifies connectivity to a datasource and returns a list of readable tables.
 * @summary Inspect Datasource
 */
export const inspectDatasourceParams = zod.object({
	datasource_id: zod.string(),
});

export const inspectDatasourceQueryRefreshDefault = false;

export const inspectDatasourceQueryParams = zod.object({
	refresh: zod.boolean().optional().describe("Refresh the cache."),
});

export const inspectDatasourceResponse = zod.object({
	tables: zod.array(zod.string()),
});

/**
 * Inspects a single table in a datasource and returns a summary of its fields.
 * @summary Inspect Table In Datasource
 */
export const inspectTableInDatasourceParams = zod.object({
	datasource_id: zod.string(),
	table_name: zod.string(),
});

export const inspectTableInDatasourceQueryRefreshDefault = false;

export const inspectTableInDatasourceQueryParams = zod.object({
	refresh: zod.boolean().optional().describe("Refresh the cache."),
});

export const inspectTableInDatasourceResponseFieldsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectTableInDatasourceResponseFieldsItemDescriptionMax = 2000;

export const inspectTableInDatasourceResponse = zod
	.object({
		detected_unique_id_fields: zod
			.array(zod.string())
			.describe("Fields that are possibly candidates for unique IDs."),
		fields: zod
			.array(
				zod
					.object({
						field_name: zod
							.string()
							.regex(inspectTableInDatasourceResponseFieldsItemFieldNameRegExp),
						data_type: zod
							.enum([
								"boolean",
								"character varying",
								"uuid",
								"date",
								"integer",
								"double precision",
								"numeric",
								"timestamp without time zone",
								"timestamp with time zone",
								"bigint",
								"jsonb (unsupported)",
								"json (unsupported)",
								"unsupported",
							])
							.describe(
								"Defines the supported data types for fields in the data source.",
							),
						description: zod
							.string()
							.max(inspectTableInDatasourceResponseFieldsItemDescriptionMax),
					})
					.describe("Concise summary of fields in the table."),
			)
			.describe("Fields in the table."),
	})
	.describe("Describes a table in the datasource.");

/**
 * Deletes a datasource.

The user must be a member of the organization that owns the datasource.
 * @summary Delete Datasource
 */
export const deleteDatasourceParams = zod.object({
	organization_id: zod.string(),
	datasource_id: zod.string(),
});

export const deleteDatasourceQueryAllowMissingDefault = false;

export const deleteDatasourceQueryParams = zod.object({
	allow_missing: zod
		.boolean()
		.optional()
		.describe("If true, return a 204 even if the resource does not exist."),
});

/**
 * @summary List Participant Types
 */
export const listParticipantTypesParams = zod.object({
	datasource_id: zod.string(),
});

export const listParticipantTypesResponseItemsItemFieldsItemDescriptionDefault =
	"";
export const listParticipantTypesResponseItemsItemFieldsItemIsUniqueIdDefault = false;
export const listParticipantTypesResponseItemsItemFieldsItemIsStrataDefault = false;
export const listParticipantTypesResponseItemsItemFieldsItemIsFilterDefault = false;
export const listParticipantTypesResponseItemsItemFieldsItemIsMetricDefault = false;

export const listParticipantTypesResponse = zod.object({
	items: zod.array(
		zod.object({
			table_name: zod
				.string()
				.describe("Name of the table in the data warehouse"),
			fields: zod
				.array(
					zod.object({
						field_name: zod
							.string()
							.describe("Name of the field in the data source"),
						data_type: zod
							.enum([
								"boolean",
								"character varying",
								"uuid",
								"date",
								"integer",
								"double precision",
								"numeric",
								"timestamp without time zone",
								"timestamp with time zone",
								"bigint",
								"jsonb (unsupported)",
								"json (unsupported)",
								"unsupported",
							])
							.describe(
								"Defines the supported data types for fields in the data source.",
							),
						description: zod
							.string()
							.optional()
							.describe("Human-readable description of the field"),
						is_unique_id: zod
							.boolean()
							.optional()
							.describe("Whether this field uniquely identifies records"),
						is_strata: zod
							.boolean()
							.optional()
							.describe("Whether this field should be used for stratification"),
						is_filter: zod
							.boolean()
							.optional()
							.describe("Whether this field can be used as a filter"),
						is_metric: zod
							.boolean()
							.optional()
							.describe("Whether this field can be used as a metric"),
						extra: zod
							.record(zod.string(), zod.string())
							.or(zod.null())
							.optional()
							.describe("Additional field metadata"),
					}),
				)
				.describe("List of fields available in this table"),
			participant_type: zod
				.string()
				.describe(
					"The name of the set of participants defined by the filters. This name must be unique within a datasource.",
				),
			type: zod.enum(["schema"]),
		}),
	),
});

/**
 * @summary Create Participant Type
 */
export const createParticipantTypeParams = zod.object({
	datasource_id: zod.string(),
});

export const createParticipantTypeBodyParticipantTypeMax = 100;
export const createParticipantTypeBodySchemaDefFieldsItemDescriptionDefault =
	"";
export const createParticipantTypeBodySchemaDefFieldsItemIsUniqueIdDefault = false;
export const createParticipantTypeBodySchemaDefFieldsItemIsStrataDefault = false;
export const createParticipantTypeBodySchemaDefFieldsItemIsFilterDefault = false;
export const createParticipantTypeBodySchemaDefFieldsItemIsMetricDefault = false;

export const createParticipantTypeBody = zod.object({
	participant_type: zod
		.string()
		.max(createParticipantTypeBodyParticipantTypeMax),
	schema_def: zod
		.object({
			table_name: zod
				.string()
				.describe("Name of the table in the data warehouse"),
			fields: zod
				.array(
					zod.object({
						field_name: zod
							.string()
							.describe("Name of the field in the data source"),
						data_type: zod
							.enum([
								"boolean",
								"character varying",
								"uuid",
								"date",
								"integer",
								"double precision",
								"numeric",
								"timestamp without time zone",
								"timestamp with time zone",
								"bigint",
								"jsonb (unsupported)",
								"json (unsupported)",
								"unsupported",
							])
							.describe(
								"Defines the supported data types for fields in the data source.",
							),
						description: zod
							.string()
							.optional()
							.describe("Human-readable description of the field"),
						is_unique_id: zod
							.boolean()
							.optional()
							.describe("Whether this field uniquely identifies records"),
						is_strata: zod
							.boolean()
							.optional()
							.describe("Whether this field should be used for stratification"),
						is_filter: zod
							.boolean()
							.optional()
							.describe("Whether this field can be used as a filter"),
						is_metric: zod
							.boolean()
							.optional()
							.describe("Whether this field can be used as a metric"),
						extra: zod
							.record(zod.string(), zod.string())
							.or(zod.null())
							.optional()
							.describe("Additional field metadata"),
					}),
				)
				.describe("List of fields available in this table"),
		})
		.describe(
			"Represents a single worksheet describing metadata about a type of Participant.",
		),
});

export const createParticipantTypeResponseParticipantTypeMax = 100;
export const createParticipantTypeResponseSchemaDefFieldsItemDescriptionDefault =
	"";
export const createParticipantTypeResponseSchemaDefFieldsItemIsUniqueIdDefault = false;
export const createParticipantTypeResponseSchemaDefFieldsItemIsStrataDefault = false;
export const createParticipantTypeResponseSchemaDefFieldsItemIsFilterDefault = false;
export const createParticipantTypeResponseSchemaDefFieldsItemIsMetricDefault = false;

export const createParticipantTypeResponse = zod.object({
	participant_type: zod
		.string()
		.max(createParticipantTypeResponseParticipantTypeMax),
	schema_def: zod
		.object({
			table_name: zod
				.string()
				.describe("Name of the table in the data warehouse"),
			fields: zod
				.array(
					zod.object({
						field_name: zod
							.string()
							.describe("Name of the field in the data source"),
						data_type: zod
							.enum([
								"boolean",
								"character varying",
								"uuid",
								"date",
								"integer",
								"double precision",
								"numeric",
								"timestamp without time zone",
								"timestamp with time zone",
								"bigint",
								"jsonb (unsupported)",
								"json (unsupported)",
								"unsupported",
							])
							.describe(
								"Defines the supported data types for fields in the data source.",
							),
						description: zod
							.string()
							.optional()
							.describe("Human-readable description of the field"),
						is_unique_id: zod
							.boolean()
							.optional()
							.describe("Whether this field uniquely identifies records"),
						is_strata: zod
							.boolean()
							.optional()
							.describe("Whether this field should be used for stratification"),
						is_filter: zod
							.boolean()
							.optional()
							.describe("Whether this field can be used as a filter"),
						is_metric: zod
							.boolean()
							.optional()
							.describe("Whether this field can be used as a metric"),
						extra: zod
							.record(zod.string(), zod.string())
							.or(zod.null())
							.optional()
							.describe("Additional field metadata"),
					}),
				)
				.describe("List of fields available in this table"),
		})
		.describe(
			"Represents a single worksheet describing metadata about a type of Participant.",
		),
});

/**
 * Returns filter, strata, and metric field metadata for a participant type, including exemplars for
filter fields.
 * @summary Inspect Participant Types
 */
export const inspectParticipantTypesParams = zod.object({
	datasource_id: zod.string(),
	participant_id: zod.string(),
});

export const inspectParticipantTypesQueryRefreshDefault = false;

export const inspectParticipantTypesQueryParams = zod.object({
	refresh: zod.boolean().optional().describe("Refresh the cache."),
});

export const inspectParticipantTypesResponseFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectParticipantTypesResponseFiltersItemRelationsMax = 20;
export const inspectParticipantTypesResponseFiltersItemDescriptionMax = 2000;
export const inspectParticipantTypesResponseFiltersItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectParticipantTypesResponseFiltersItemRelationsMaxOne = 20;
export const inspectParticipantTypesResponseFiltersItemDescriptionMaxOne = 2000;
export const inspectParticipantTypesResponseMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectParticipantTypesResponseMetricsItemDescriptionMax = 2000;
export const inspectParticipantTypesResponseStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const inspectParticipantTypesResponseStrataItemDescriptionMax = 2000;

export const inspectParticipantTypesResponse = zod
	.object({
		filters: zod.array(
			zod
				.object({
					field_name: zod
						.string()
						.regex(inspectParticipantTypesResponseFiltersItemFieldNameRegExp)
						.describe("Name of the field."),
					data_type: zod
						.enum([
							"boolean",
							"character varying",
							"uuid",
							"date",
							"integer",
							"double precision",
							"numeric",
							"timestamp without time zone",
							"timestamp with time zone",
							"bigint",
							"jsonb (unsupported)",
							"json (unsupported)",
							"unsupported",
						])
						.describe(
							"Defines the supported data types for fields in the data source.",
						),
					relations: zod
						.array(
							zod
								.enum(["includes", "excludes", "between"])
								.describe(
									"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
								),
						)
						.min(1)
						.max(inspectParticipantTypesResponseFiltersItemRelationsMax),
					description: zod
						.string()
						.max(inspectParticipantTypesResponseFiltersItemDescriptionMax),
					min: zod
						.string()
						.datetime({})
						.or(zod.string().date())
						.or(zod.number())
						.or(zod.number())
						.or(zod.null())
						.describe("The minimum observed value."),
					max: zod
						.string()
						.datetime({})
						.or(zod.string().date())
						.or(zod.number())
						.or(zod.number())
						.or(zod.null())
						.describe("The maximum observed value."),
				})
				.describe("Describes a numeric or date filter variable.")
				.or(
					zod
						.object({
							field_name: zod
								.string()
								.regex(
									inspectParticipantTypesResponseFiltersItemFieldNameRegExpOne,
								)
								.describe("Name of the field."),
							data_type: zod
								.enum([
									"boolean",
									"character varying",
									"uuid",
									"date",
									"integer",
									"double precision",
									"numeric",
									"timestamp without time zone",
									"timestamp with time zone",
									"bigint",
									"jsonb (unsupported)",
									"json (unsupported)",
									"unsupported",
								])
								.describe(
									"Defines the supported data types for fields in the data source.",
								),
							relations: zod
								.array(
									zod
										.enum(["includes", "excludes", "between"])
										.describe(
											"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
										),
								)
								.min(1)
								.max(inspectParticipantTypesResponseFiltersItemRelationsMaxOne),
							description: zod
								.string()
								.max(
									inspectParticipantTypesResponseFiltersItemDescriptionMaxOne,
								),
							distinct_values: zod
								.array(zod.string())
								.or(zod.null())
								.describe("Sorted list of unique values."),
						})
						.describe("Describes a discrete filter variable."),
				),
		),
		metrics: zod.array(
			zod
				.object({
					field_name: zod
						.string()
						.regex(inspectParticipantTypesResponseMetricsItemFieldNameRegExp),
					data_type: zod
						.enum([
							"boolean",
							"character varying",
							"uuid",
							"date",
							"integer",
							"double precision",
							"numeric",
							"timestamp without time zone",
							"timestamp with time zone",
							"bigint",
							"jsonb (unsupported)",
							"json (unsupported)",
							"unsupported",
						])
						.describe(
							"Defines the supported data types for fields in the data source.",
						),
					description: zod
						.string()
						.max(inspectParticipantTypesResponseMetricsItemDescriptionMax),
				})
				.describe("Describes a metric."),
		),
		strata: zod.array(
			zod
				.object({
					data_type: zod
						.enum([
							"boolean",
							"character varying",
							"uuid",
							"date",
							"integer",
							"double precision",
							"numeric",
							"timestamp without time zone",
							"timestamp with time zone",
							"bigint",
							"jsonb (unsupported)",
							"json (unsupported)",
							"unsupported",
						])
						.describe(
							"Defines the supported data types for fields in the data source.",
						),
					field_name: zod
						.string()
						.regex(inspectParticipantTypesResponseStrataItemFieldNameRegExp),
					description: zod
						.string()
						.max(inspectParticipantTypesResponseStrataItemDescriptionMax),
					extra: zod
						.record(zod.string(), zod.string())
						.or(zod.null())
						.optional(),
				})
				.describe("Describes a stratification variable."),
		),
	})
	.describe(
		"Describes a participant type's strata, metrics, and filters (including exemplar values).",
	);

/**
 * @summary Get Participant Types
 */
export const getParticipantTypesParams = zod.object({
	datasource_id: zod.string(),
	participant_id: zod.string(),
});

export const getParticipantTypesResponseFieldsItemDescriptionDefault = "";
export const getParticipantTypesResponseFieldsItemIsUniqueIdDefault = false;
export const getParticipantTypesResponseFieldsItemIsStrataDefault = false;
export const getParticipantTypesResponseFieldsItemIsFilterDefault = false;
export const getParticipantTypesResponseFieldsItemIsMetricDefault = false;

export const getParticipantTypesResponse = zod.object({
	table_name: zod.string().describe("Name of the table in the data warehouse"),
	fields: zod
		.array(
			zod.object({
				field_name: zod
					.string()
					.describe("Name of the field in the data source"),
				data_type: zod
					.enum([
						"boolean",
						"character varying",
						"uuid",
						"date",
						"integer",
						"double precision",
						"numeric",
						"timestamp without time zone",
						"timestamp with time zone",
						"bigint",
						"jsonb (unsupported)",
						"json (unsupported)",
						"unsupported",
					])
					.describe(
						"Defines the supported data types for fields in the data source.",
					),
				description: zod
					.string()
					.optional()
					.describe("Human-readable description of the field"),
				is_unique_id: zod
					.boolean()
					.optional()
					.describe("Whether this field uniquely identifies records"),
				is_strata: zod
					.boolean()
					.optional()
					.describe("Whether this field should be used for stratification"),
				is_filter: zod
					.boolean()
					.optional()
					.describe("Whether this field can be used as a filter"),
				is_metric: zod
					.boolean()
					.optional()
					.describe("Whether this field can be used as a metric"),
				extra: zod
					.record(zod.string(), zod.string())
					.or(zod.null())
					.optional()
					.describe("Additional field metadata"),
			}),
		)
		.describe("List of fields available in this table"),
	participant_type: zod
		.string()
		.describe(
			"The name of the set of participants defined by the filters. This name must be unique within a datasource.",
		),
	type: zod.enum(["schema"]),
});

/**
 * @summary Update Participant Type
 */
export const updateParticipantTypeParams = zod.object({
	datasource_id: zod.string(),
	participant_id: zod.string(),
});

export const updateParticipantTypeBodyParticipantTypeMaxOne = 100;
export const updateParticipantTypeBodyTableNameRegExpOne = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const updateParticipantTypeBodyFieldsItemDescriptionDefault = "";
export const updateParticipantTypeBodyFieldsItemIsUniqueIdDefault = false;
export const updateParticipantTypeBodyFieldsItemIsStrataDefault = false;
export const updateParticipantTypeBodyFieldsItemIsFilterDefault = false;
export const updateParticipantTypeBodyFieldsItemIsMetricDefault = false;
export const updateParticipantTypeBodyFieldsMaxOne = 150;

export const updateParticipantTypeBody = zod.object({
	participant_type: zod
		.string()
		.max(updateParticipantTypeBodyParticipantTypeMaxOne)
		.or(zod.null())
		.optional(),
	table_name: zod
		.string()
		.regex(updateParticipantTypeBodyTableNameRegExpOne)
		.or(zod.null())
		.optional(),
	fields: zod
		.array(
			zod.object({
				field_name: zod
					.string()
					.describe("Name of the field in the data source"),
				data_type: zod
					.enum([
						"boolean",
						"character varying",
						"uuid",
						"date",
						"integer",
						"double precision",
						"numeric",
						"timestamp without time zone",
						"timestamp with time zone",
						"bigint",
						"jsonb (unsupported)",
						"json (unsupported)",
						"unsupported",
					])
					.describe(
						"Defines the supported data types for fields in the data source.",
					),
				description: zod
					.string()
					.optional()
					.describe("Human-readable description of the field"),
				is_unique_id: zod
					.boolean()
					.optional()
					.describe("Whether this field uniquely identifies records"),
				is_strata: zod
					.boolean()
					.optional()
					.describe("Whether this field should be used for stratification"),
				is_filter: zod
					.boolean()
					.optional()
					.describe("Whether this field can be used as a filter"),
				is_metric: zod
					.boolean()
					.optional()
					.describe("Whether this field can be used as a metric"),
				extra: zod
					.record(zod.string(), zod.string())
					.or(zod.null())
					.optional()
					.describe("Additional field metadata"),
			}),
		)
		.max(updateParticipantTypeBodyFieldsMaxOne)
		.or(zod.null())
		.optional(),
});

export const updateParticipantTypeResponseParticipantTypeMax = 100;
export const updateParticipantTypeResponseTableNameRegExpOne = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const updateParticipantTypeResponseFieldsItemDescriptionDefault = "";
export const updateParticipantTypeResponseFieldsItemIsUniqueIdDefault = false;
export const updateParticipantTypeResponseFieldsItemIsStrataDefault = false;
export const updateParticipantTypeResponseFieldsItemIsFilterDefault = false;
export const updateParticipantTypeResponseFieldsItemIsMetricDefault = false;
export const updateParticipantTypeResponseFieldsMaxOne = 150;

export const updateParticipantTypeResponse = zod.object({
	participant_type: zod
		.string()
		.max(updateParticipantTypeResponseParticipantTypeMax),
	table_name: zod
		.string()
		.regex(updateParticipantTypeResponseTableNameRegExpOne)
		.or(zod.null())
		.optional(),
	fields: zod
		.array(
			zod.object({
				field_name: zod
					.string()
					.describe("Name of the field in the data source"),
				data_type: zod
					.enum([
						"boolean",
						"character varying",
						"uuid",
						"date",
						"integer",
						"double precision",
						"numeric",
						"timestamp without time zone",
						"timestamp with time zone",
						"bigint",
						"jsonb (unsupported)",
						"json (unsupported)",
						"unsupported",
					])
					.describe(
						"Defines the supported data types for fields in the data source.",
					),
				description: zod
					.string()
					.optional()
					.describe("Human-readable description of the field"),
				is_unique_id: zod
					.boolean()
					.optional()
					.describe("Whether this field uniquely identifies records"),
				is_strata: zod
					.boolean()
					.optional()
					.describe("Whether this field should be used for stratification"),
				is_filter: zod
					.boolean()
					.optional()
					.describe("Whether this field can be used as a filter"),
				is_metric: zod
					.boolean()
					.optional()
					.describe("Whether this field can be used as a metric"),
				extra: zod
					.record(zod.string(), zod.string())
					.or(zod.null())
					.optional()
					.describe("Additional field metadata"),
			}),
		)
		.max(updateParticipantTypeResponseFieldsMaxOne)
		.or(zod.null())
		.optional(),
});

/**
 * @summary Delete Participant
 */
export const deleteParticipantParams = zod.object({
	datasource_id: zod.string(),
	participant_id: zod.string(),
});

export const deleteParticipantQueryAllowMissingDefault = false;

export const deleteParticipantQueryParams = zod.object({
	allow_missing: zod
		.boolean()
		.optional()
		.describe("If true, return a 204 even if the resource does not exist."),
});

/**
 * Returns API keys that have access to the datasource.
 * @summary List Api Keys
 */
export const listApiKeysParams = zod.object({
	datasource_id: zod.string(),
});

export const listApiKeysResponseItemsItemIdMax = 64;
export const listApiKeysResponseItemsItemDatasourceIdMax = 64;
export const listApiKeysResponseItemsItemOrganizationIdMax = 64;
export const listApiKeysResponseItemsItemOrganizationNameMax = 100;

export const listApiKeysResponse = zod.object({
	items: zod.array(
		zod.object({
			id: zod.string().max(listApiKeysResponseItemsItemIdMax),
			datasource_id: zod
				.string()
				.max(listApiKeysResponseItemsItemDatasourceIdMax),
			organization_id: zod
				.string()
				.max(listApiKeysResponseItemsItemOrganizationIdMax),
			organization_name: zod
				.string()
				.max(listApiKeysResponseItemsItemOrganizationNameMax),
		}),
	),
});

/**
 * Creates an API key for the specified datasource.

The user must belong to the organization that owns the requested datasource.
 * @summary Create Api Key
 */
export const createApiKeyParams = zod.object({
	datasource_id: zod.string(),
});

export const createApiKeyResponseIdMax = 64;

export const createApiKeyResponse = zod.object({
	id: zod.string().max(createApiKeyResponseIdMax),
	datasource_id: zod.string(),
	key: zod.string(),
});

/**
 * Deletes the specified API key.
 * @summary Delete Api Key
 */
export const deleteApiKeyParams = zod.object({
	datasource_id: zod.string(),
	api_key_id: zod.string(),
});

export const deleteApiKeyQueryAllowMissingDefault = false;

export const deleteApiKeyQueryParams = zod.object({
	allow_missing: zod
		.boolean()
		.optional()
		.describe("If true, return a 204 even if the resource does not exist."),
});

/**
 * Creates a new experiment in the specified datasource.
 * @summary Create Experiment
 */
export const createExperimentParams = zod.object({
	datasource_id: zod.string(),
});

export const createExperimentQueryStratifyOnMetricsDefault = true;

export const createExperimentQueryParams = zod.object({
	chosen_n: zod
		.number()
		.or(zod.null())
		.optional()
		.describe("Number of participants to assign."),
	stratify_on_metrics: zod
		.boolean()
		.default(createExperimentQueryStratifyOnMetricsDefault)
		.describe("Whether to also stratify on metrics during assignment."),
});

export const createExperimentBodyDesignSpecParticipantTypeMax = 100;
export const createExperimentBodyDesignSpecExperimentNameMax = 100;
export const createExperimentBodyDesignSpecDescriptionMax = 2000;
export const createExperimentBodyDesignSpecDesignUrlMaxOne = 500;
export const createExperimentBodyDesignSpecArmsItemArmNameMax = 100;
export const createExperimentBodyDesignSpecArmsItemArmDescriptionMaxOne = 2000;
export const createExperimentBodyDesignSpecArmsMin = 2;

export const createExperimentBodyDesignSpecArmsMax = 10;
export const createExperimentBodyDesignSpecStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyDesignSpecStrataMax = 150;
export const createExperimentBodyDesignSpecMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyDesignSpecMetricsMax = 150;
export const createExperimentBodyDesignSpecFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyDesignSpecFiltersMax = 20;
export const createExperimentBodyDesignSpecPowerDefault = 0.8;
export const createExperimentBodyDesignSpecPowerMin = 0;

export const createExperimentBodyDesignSpecPowerMax = 1;
export const createExperimentBodyDesignSpecAlphaDefault = 0.05;
export const createExperimentBodyDesignSpecAlphaMin = 0;

export const createExperimentBodyDesignSpecAlphaMax = 1;
export const createExperimentBodyDesignSpecFstatThreshDefault = 0.6;
export const createExperimentBodyDesignSpecFstatThreshMin = 0;

export const createExperimentBodyDesignSpecFstatThreshMax = 1;
export const createExperimentBodyDesignSpecParticipantTypeMaxOne = 100;
export const createExperimentBodyDesignSpecExperimentNameMaxOne = 100;
export const createExperimentBodyDesignSpecDescriptionMaxOne = 2000;
export const createExperimentBodyDesignSpecDesignUrlMaxFour = 500;
export const createExperimentBodyDesignSpecArmsItemArmNameMaxOne = 100;
export const createExperimentBodyDesignSpecArmsItemArmDescriptionMaxFour = 2000;
export const createExperimentBodyDesignSpecArmsMinOne = 2;

export const createExperimentBodyDesignSpecArmsMaxOne = 10;
export const createExperimentBodyDesignSpecStrataItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyDesignSpecStrataMaxOne = 150;
export const createExperimentBodyDesignSpecMetricsItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyDesignSpecMetricsMaxOne = 150;
export const createExperimentBodyDesignSpecFiltersItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyDesignSpecFiltersMaxOne = 20;
export const createExperimentBodyDesignSpecPowerDefaultOne = 0.8;
export const createExperimentBodyDesignSpecPowerMinOne = 0;

export const createExperimentBodyDesignSpecPowerMaxOne = 1;
export const createExperimentBodyDesignSpecAlphaDefaultOne = 0.05;
export const createExperimentBodyDesignSpecAlphaMinOne = 0;

export const createExperimentBodyDesignSpecAlphaMaxOne = 1;
export const createExperimentBodyDesignSpecFstatThreshDefaultOne = 0.6;
export const createExperimentBodyDesignSpecFstatThreshMinOne = 0;

export const createExperimentBodyDesignSpecFstatThreshMaxOne = 1;
export const createExperimentBodyDesignSpecParticipantTypeMaxTwo = 100;
export const createExperimentBodyDesignSpecExperimentNameMaxTwo = 100;
export const createExperimentBodyDesignSpecDescriptionMaxTwo = 2000;
export const createExperimentBodyDesignSpecDesignUrlMaxSeven = 500;
export const createExperimentBodyDesignSpecArmsItemArmNameMaxTwo = 100;
export const createExperimentBodyDesignSpecArmsItemArmDescriptionMaxSeven = 2000;
export const createExperimentBodyDesignSpecArmsMinTwo = 2;

export const createExperimentBodyDesignSpecArmsMaxTwo = 10;
export const createExperimentBodyDesignSpecContextsItemContextNameMax = 100;
export const createExperimentBodyDesignSpecContextsItemContextDescriptionMaxOne = 2000;
export const createExperimentBodyDesignSpecContextsMaxOne = 150;
export const createExperimentBodyDesignSpecParticipantTypeMaxThree = 100;
export const createExperimentBodyDesignSpecExperimentNameMaxThree = 100;
export const createExperimentBodyDesignSpecDescriptionMaxThree = 2000;
export const createExperimentBodyDesignSpecDesignUrlMaxOnezero = 500;
export const createExperimentBodyDesignSpecArmsItemArmNameMaxThree = 100;
export const createExperimentBodyDesignSpecArmsItemArmDescriptionMaxOnezero = 2000;
export const createExperimentBodyDesignSpecArmsMinThree = 2;

export const createExperimentBodyDesignSpecArmsMaxThree = 10;
export const createExperimentBodyDesignSpecContextsItemContextNameMaxOne = 100;
export const createExperimentBodyDesignSpecContextsItemContextDescriptionMaxFour = 2000;
export const createExperimentBodyDesignSpecContextsMaxFour = 150;
export const createExperimentBodyDesignSpecParticipantTypeMaxFour = 100;
export const createExperimentBodyDesignSpecExperimentNameMaxFour = 100;
export const createExperimentBodyDesignSpecDescriptionMaxFour = 2000;
export const createExperimentBodyDesignSpecDesignUrlMaxOnethree = 500;
export const createExperimentBodyDesignSpecArmsItemArmNameMaxFour = 100;
export const createExperimentBodyDesignSpecArmsItemArmDescriptionMaxOnethree = 2000;
export const createExperimentBodyDesignSpecArmsMinFour = 2;

export const createExperimentBodyDesignSpecArmsMaxFour = 10;
export const createExperimentBodyDesignSpecContextsItemContextNameMaxTwo = 100;
export const createExperimentBodyDesignSpecContextsItemContextDescriptionMaxSeven = 2000;
export const createExperimentBodyDesignSpecContextsMaxSeven = 150;
export const createExperimentBodyPowerAnalysesAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentBodyPowerAnalysesAnalysesMax = 150;
export const createExperimentBodyWebhooksDefault = [];

export const createExperimentBody = zod.object({
	design_spec: zod
		.object({
			participant_type: zod
				.string()
				.max(createExperimentBodyDesignSpecParticipantTypeMax),
			experiment_id: zod
				.string()
				.or(zod.null())
				.optional()
				.describe(
					"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
				),
			experiment_type: zod.enum(["freq_preassigned"]),
			experiment_name: zod
				.string()
				.max(createExperimentBodyDesignSpecExperimentNameMax),
			description: zod
				.string()
				.max(createExperimentBodyDesignSpecDescriptionMax),
			design_url: zod
				.string()
				.url()
				.min(1)
				.max(createExperimentBodyDesignSpecDesignUrlMaxOne)
				.or(zod.null())
				.optional()
				.describe("Optional URL to a more detailed experiment design doc."),
			start_date: zod.string().datetime({}),
			end_date: zod.string().datetime({}),
			arms: zod
				.array(
					zod
						.object({
							arm_id: zod
								.string()
								.or(zod.null())
								.optional()
								.describe(
									"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
								),
							arm_name: zod
								.string()
								.max(createExperimentBodyDesignSpecArmsItemArmNameMax),
							arm_description: zod
								.string()
								.max(createExperimentBodyDesignSpecArmsItemArmDescriptionMaxOne)
								.or(zod.null())
								.optional(),
						})
						.describe("Describes an experiment treatment arm."),
				)
				.min(createExperimentBodyDesignSpecArmsMin)
				.max(createExperimentBodyDesignSpecArmsMax),
			strata: zod
				.array(
					zod
						.object({
							field_name: zod
								.string()
								.regex(createExperimentBodyDesignSpecStrataItemFieldNameRegExp),
						})
						.describe("Describes a variable used for stratification."),
				)
				.max(createExperimentBodyDesignSpecStrataMax)
				.describe(
					"Optional participant_type fields to use for stratified assignment.",
				),
			metrics: zod
				.array(
					zod
						.object({
							field_name: zod
								.string()
								.regex(
									createExperimentBodyDesignSpecMetricsItemFieldNameRegExp,
								),
							metric_pct_change: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
								),
							metric_target: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
								),
						})
						.describe(
							"Defines a request to look up baseline stats for a metric to measure in an experiment.",
						),
				)
				.min(1)
				.max(createExperimentBodyDesignSpecMetricsMax)
				.describe("Primary and optional secondary metrics to target."),
			filters: zod
				.array(
					zod
						.object({
							field_name: zod
								.string()
								.regex(
									createExperimentBodyDesignSpecFiltersItemFieldNameRegExp,
								),
							relation: zod
								.enum(["includes", "excludes", "between"])
								.describe(
									"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
								),
							value: zod
								.array(zod.number().or(zod.null()))
								.or(zod.array(zod.number().or(zod.null())))
								.or(zod.array(zod.string().or(zod.null())))
								.or(zod.array(zod.boolean().or(zod.null()))),
						})
						.describe(
							'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value             | logical Result                                    |\n|----------|-------------------|---------------------------------------------------|\n| INCLUDES | [None]            | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]             | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None]       | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]        | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]            | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None]       | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]        | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]        | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", "z", None]  | Match `"a" <= x <= "z"` or `x IS NULL`            |\n| BETWEEN  | [None, "z"]       | Match `x <= "z"`                                  |\n| BETWEEN  | ["a", None]       | Match `x >= "a"`                                  |\n| BETWEEN  | [None, "a", None] | Match `x <= "a"` or `x IS NULL`                   |\n\nString comparisons are case-sensitive.\n\n## Special Handling for BETWEEN support of including NULL\n\nWhen the relation is BETWEEN, we allow for up to 3 values to support the special case of\nincluding null in addition to the values in the between range via an OR IS NULL clause, as\nindicated by a 3rd value of None. Any other 3rd value is invalid.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of DATE, DATETIME and TIMESTAMP values\n\nDATE, DATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
						),
				)
				.max(createExperimentBodyDesignSpecFiltersMax)
				.describe(
					"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
				),
			power: zod
				.number()
				.min(createExperimentBodyDesignSpecPowerMin)
				.max(createExperimentBodyDesignSpecPowerMax)
				.default(createExperimentBodyDesignSpecPowerDefault)
				.describe(
					"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
				),
			alpha: zod
				.number()
				.min(createExperimentBodyDesignSpecAlphaMin)
				.max(createExperimentBodyDesignSpecAlphaMax)
				.default(createExperimentBodyDesignSpecAlphaDefault)
				.describe(
					"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
				),
			fstat_thresh: zod
				.number()
				.min(createExperimentBodyDesignSpecFstatThreshMin)
				.max(createExperimentBodyDesignSpecFstatThreshMax)
				.default(createExperimentBodyDesignSpecFstatThreshDefault)
				.describe(
					'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
				),
		})
		.describe(
			"Use this type to randomly select and assign from existing participants at design time with\nfrequentist A/B experiments.",
		)
		.or(
			zod
				.object({
					participant_type: zod
						.string()
						.max(createExperimentBodyDesignSpecParticipantTypeMaxOne),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
						),
					experiment_type: zod.enum(["freq_online"]),
					experiment_name: zod
						.string()
						.max(createExperimentBodyDesignSpecExperimentNameMaxOne),
					description: zod
						.string()
						.max(createExperimentBodyDesignSpecDescriptionMaxOne),
					design_url: zod
						.string()
						.url()
						.min(1)
						.max(createExperimentBodyDesignSpecDesignUrlMaxFour)
						.or(zod.null())
						.optional()
						.describe("Optional URL to a more detailed experiment design doc."),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(createExperimentBodyDesignSpecArmsItemArmNameMaxOne),
									arm_description: zod
										.string()
										.max(
											createExperimentBodyDesignSpecArmsItemArmDescriptionMaxFour,
										)
										.or(zod.null())
										.optional(),
								})
								.describe("Describes an experiment treatment arm."),
						)
						.min(createExperimentBodyDesignSpecArmsMinOne)
						.max(createExperimentBodyDesignSpecArmsMaxOne),
					strata: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											createExperimentBodyDesignSpecStrataItemFieldNameRegExpOne,
										),
								})
								.describe("Describes a variable used for stratification."),
						)
						.max(createExperimentBodyDesignSpecStrataMaxOne)
						.describe(
							"Optional participant_type fields to use for stratified assignment.",
						),
					metrics: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											createExperimentBodyDesignSpecMetricsItemFieldNameRegExpOne,
										),
									metric_pct_change: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
										),
									metric_target: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
										),
								})
								.describe(
									"Defines a request to look up baseline stats for a metric to measure in an experiment.",
								),
						)
						.min(1)
						.max(createExperimentBodyDesignSpecMetricsMaxOne)
						.describe("Primary and optional secondary metrics to target."),
					filters: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											createExperimentBodyDesignSpecFiltersItemFieldNameRegExpOne,
										),
									relation: zod
										.enum(["includes", "excludes", "between"])
										.describe(
											"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
										),
									value: zod
										.array(zod.number().or(zod.null()))
										.or(zod.array(zod.number().or(zod.null())))
										.or(zod.array(zod.string().or(zod.null())))
										.or(zod.array(zod.boolean().or(zod.null()))),
								})
								.describe(
									'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value             | logical Result                                    |\n|----------|-------------------|---------------------------------------------------|\n| INCLUDES | [None]            | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]             | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None]       | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]        | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]            | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None]       | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]        | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]        | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", "z", None]  | Match `"a" <= x <= "z"` or `x IS NULL`            |\n| BETWEEN  | [None, "z"]       | Match `x <= "z"`                                  |\n| BETWEEN  | ["a", None]       | Match `x >= "a"`                                  |\n| BETWEEN  | [None, "a", None] | Match `x <= "a"` or `x IS NULL`                   |\n\nString comparisons are case-sensitive.\n\n## Special Handling for BETWEEN support of including NULL\n\nWhen the relation is BETWEEN, we allow for up to 3 values to support the special case of\nincluding null in addition to the values in the between range via an OR IS NULL clause, as\nindicated by a 3rd value of None. Any other 3rd value is invalid.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of DATE, DATETIME and TIMESTAMP values\n\nDATE, DATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
								),
						)
						.max(createExperimentBodyDesignSpecFiltersMaxOne)
						.describe(
							"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
						),
					power: zod
						.number()
						.min(createExperimentBodyDesignSpecPowerMinOne)
						.max(createExperimentBodyDesignSpecPowerMaxOne)
						.default(createExperimentBodyDesignSpecPowerDefaultOne)
						.describe(
							"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
						),
					alpha: zod
						.number()
						.min(createExperimentBodyDesignSpecAlphaMinOne)
						.max(createExperimentBodyDesignSpecAlphaMaxOne)
						.default(createExperimentBodyDesignSpecAlphaDefaultOne)
						.describe(
							"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
						),
					fstat_thresh: zod
						.number()
						.min(createExperimentBodyDesignSpecFstatThreshMinOne)
						.max(createExperimentBodyDesignSpecFstatThreshMaxOne)
						.default(createExperimentBodyDesignSpecFstatThreshDefaultOne)
						.describe(
							'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
						),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution with\nfrequentist A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
		)
		.or(
			zod
				.object({
					participant_type: zod
						.string()
						.max(createExperimentBodyDesignSpecParticipantTypeMaxTwo),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
						),
					experiment_type: zod.enum(["mab_online"]),
					experiment_name: zod
						.string()
						.max(createExperimentBodyDesignSpecExperimentNameMaxTwo),
					description: zod
						.string()
						.max(createExperimentBodyDesignSpecDescriptionMaxTwo),
					design_url: zod
						.string()
						.url()
						.min(1)
						.max(createExperimentBodyDesignSpecDesignUrlMaxSeven)
						.or(zod.null())
						.optional()
						.describe("Optional URL to a more detailed experiment design doc."),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(createExperimentBodyDesignSpecArmsItemArmNameMaxTwo),
									arm_description: zod
										.string()
										.max(
											createExperimentBodyDesignSpecArmsItemArmDescriptionMaxSeven,
										)
										.or(zod.null())
										.optional(),
									alpha_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial alpha parameter for Beta prior"),
									beta_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial beta parameter for Beta prior"),
									mu_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial mean parameter for Normal prior"),
									sigma_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Initial standard deviation parameter for Normal prior",
										),
									alpha: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated alpha parameter for Beta prior"),
									beta: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated beta parameter for Beta prior"),
									mu: zod
										.array(zod.number())
										.or(zod.null())
										.optional()
										.describe("Updated mean vector for Normal prior"),
									covariance: zod
										.array(zod.array(zod.number()))
										.or(zod.null())
										.optional()
										.describe("Updated covariance matrix for Normal prior"),
								})
								.describe(
									"Describes an experiment arm for bandit experiments.",
								),
						)
						.min(createExperimentBodyDesignSpecArmsMinTwo)
						.max(createExperimentBodyDesignSpecArmsMaxTwo),
					contexts: zod
						.array(
							zod
								.object({
									context_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"Unique identifier for the context, you should NOT set this when creating a new context.",
										),
									context_name: zod
										.string()
										.max(
											createExperimentBodyDesignSpecContextsItemContextNameMax,
										),
									context_description: zod
										.string()
										.max(
											createExperimentBodyDesignSpecContextsItemContextDescriptionMaxOne,
										)
										.or(zod.null())
										.optional(),
									value_type: zod
										.enum(["binary", "real-valued"])
										.optional()
										.describe("Enum for the type of context."),
								})
								.describe("Pydantic model for context of the experiment."),
						)
						.max(createExperimentBodyDesignSpecContextsMaxOne)
						.or(zod.null())
						.optional()
						.describe(
							"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
						),
					prior_type: zod
						.enum(["beta", "normal"])
						.optional()
						.describe("Enum for the prior distribution of the arm."),
					reward_type: zod
						.enum(["binary", "real-valued"])
						.optional()
						.describe("Enum for the likelihood distribution of the reward."),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution with MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
		)
		.or(
			zod
				.object({
					participant_type: zod
						.string()
						.max(createExperimentBodyDesignSpecParticipantTypeMaxThree),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
						),
					experiment_type: zod.enum(["cmab_online"]),
					experiment_name: zod
						.string()
						.max(createExperimentBodyDesignSpecExperimentNameMaxThree),
					description: zod
						.string()
						.max(createExperimentBodyDesignSpecDescriptionMaxThree),
					design_url: zod
						.string()
						.url()
						.min(1)
						.max(createExperimentBodyDesignSpecDesignUrlMaxOnezero)
						.or(zod.null())
						.optional()
						.describe("Optional URL to a more detailed experiment design doc."),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(createExperimentBodyDesignSpecArmsItemArmNameMaxThree),
									arm_description: zod
										.string()
										.max(
											createExperimentBodyDesignSpecArmsItemArmDescriptionMaxOnezero,
										)
										.or(zod.null())
										.optional(),
									alpha_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial alpha parameter for Beta prior"),
									beta_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial beta parameter for Beta prior"),
									mu_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial mean parameter for Normal prior"),
									sigma_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Initial standard deviation parameter for Normal prior",
										),
									alpha: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated alpha parameter for Beta prior"),
									beta: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated beta parameter for Beta prior"),
									mu: zod
										.array(zod.number())
										.or(zod.null())
										.optional()
										.describe("Updated mean vector for Normal prior"),
									covariance: zod
										.array(zod.array(zod.number()))
										.or(zod.null())
										.optional()
										.describe("Updated covariance matrix for Normal prior"),
								})
								.describe(
									"Describes an experiment arm for bandit experiments.",
								),
						)
						.min(createExperimentBodyDesignSpecArmsMinThree)
						.max(createExperimentBodyDesignSpecArmsMaxThree),
					contexts: zod
						.array(
							zod
								.object({
									context_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"Unique identifier for the context, you should NOT set this when creating a new context.",
										),
									context_name: zod
										.string()
										.max(
											createExperimentBodyDesignSpecContextsItemContextNameMaxOne,
										),
									context_description: zod
										.string()
										.max(
											createExperimentBodyDesignSpecContextsItemContextDescriptionMaxFour,
										)
										.or(zod.null())
										.optional(),
									value_type: zod
										.enum(["binary", "real-valued"])
										.optional()
										.describe("Enum for the type of context."),
								})
								.describe("Pydantic model for context of the experiment."),
						)
						.max(createExperimentBodyDesignSpecContextsMaxFour)
						.or(zod.null())
						.optional()
						.describe(
							"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
						),
					prior_type: zod
						.enum(["beta", "normal"])
						.optional()
						.describe("Enum for the prior distribution of the arm."),
					reward_type: zod
						.enum(["binary", "real-valued"])
						.optional()
						.describe("Enum for the likelihood distribution of the reward."),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution with\ncontextual MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
		)
		.or(
			zod
				.object({
					participant_type: zod
						.string()
						.max(createExperimentBodyDesignSpecParticipantTypeMaxFour),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
						),
					experiment_type: zod.enum(["bayes_ab_online"]),
					experiment_name: zod
						.string()
						.max(createExperimentBodyDesignSpecExperimentNameMaxFour),
					description: zod
						.string()
						.max(createExperimentBodyDesignSpecDescriptionMaxFour),
					design_url: zod
						.string()
						.url()
						.min(1)
						.max(createExperimentBodyDesignSpecDesignUrlMaxOnethree)
						.or(zod.null())
						.optional()
						.describe("Optional URL to a more detailed experiment design doc."),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(createExperimentBodyDesignSpecArmsItemArmNameMaxFour),
									arm_description: zod
										.string()
										.max(
											createExperimentBodyDesignSpecArmsItemArmDescriptionMaxOnethree,
										)
										.or(zod.null())
										.optional(),
									alpha_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial alpha parameter for Beta prior"),
									beta_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial beta parameter for Beta prior"),
									mu_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial mean parameter for Normal prior"),
									sigma_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Initial standard deviation parameter for Normal prior",
										),
									alpha: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated alpha parameter for Beta prior"),
									beta: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated beta parameter for Beta prior"),
									mu: zod
										.array(zod.number())
										.or(zod.null())
										.optional()
										.describe("Updated mean vector for Normal prior"),
									covariance: zod
										.array(zod.array(zod.number()))
										.or(zod.null())
										.optional()
										.describe("Updated covariance matrix for Normal prior"),
								})
								.describe(
									"Describes an experiment arm for bandit experiments.",
								),
						)
						.min(createExperimentBodyDesignSpecArmsMinFour)
						.max(createExperimentBodyDesignSpecArmsMaxFour),
					contexts: zod
						.array(
							zod
								.object({
									context_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"Unique identifier for the context, you should NOT set this when creating a new context.",
										),
									context_name: zod
										.string()
										.max(
											createExperimentBodyDesignSpecContextsItemContextNameMaxTwo,
										),
									context_description: zod
										.string()
										.max(
											createExperimentBodyDesignSpecContextsItemContextDescriptionMaxSeven,
										)
										.or(zod.null())
										.optional(),
									value_type: zod
										.enum(["binary", "real-valued"])
										.optional()
										.describe("Enum for the type of context."),
								})
								.describe("Pydantic model for context of the experiment."),
						)
						.max(createExperimentBodyDesignSpecContextsMaxSeven)
						.or(zod.null())
						.optional()
						.describe(
							"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
						),
					prior_type: zod
						.enum(["beta", "normal"])
						.optional()
						.describe("Enum for the prior distribution of the arm."),
					reward_type: zod
						.enum(["binary", "real-valued"])
						.optional()
						.describe("Enum for the likelihood distribution of the reward."),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution with\nBayesian A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
		)
		.describe("The type of assignment and experiment design."),
	power_analyses: zod
		.object({
			analyses: zod
				.array(
					zod
						.object({
							metric_spec: zod
								.object({
									field_name: zod
										.string()
										.regex(
											createExperimentBodyPowerAnalysesAnalysesItemMetricSpecFieldNameRegExp,
										),
									metric_pct_change: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Percent change target relative to the metric_baseline.",
										),
									metric_target: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Absolute target value = metric_baseline*(1 + metric_pct_change)",
										),
									metric_type: zod
										.enum(["binary", "numeric"])
										.describe("Classifies metrics by their value type.")
										.or(zod.null())
										.optional()
										.describe("Inferred from dwh type."),
									metric_baseline: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Mean of the tracked metric."),
									metric_stddev: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Standard deviation is set only for metric_type.NUMERIC metrics. Must be set for numeric metrics when available_n > 0.",
										),
									available_nonnull_n: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"The number of participants meeting the filtering criteria with a *non-null* value for this metric.",
										),
									available_n: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n.",
										),
								})
								.describe(
									"Defines a metric to measure in an experiment with its baseline stats.",
								),
							target_n: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"Minimum sample size needed to meet the design specs.",
								),
							sufficient_n: zod
								.boolean()
								.or(zod.null())
								.optional()
								.describe(
									"Whether or not there are enough available units to sample from to meet target_n.",
								),
							target_possible: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.",
								),
							pct_change_possible: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.",
								),
							msg: zod
								.object({
									type: zod
										.enum([
											"sufficient",
											"insufficient",
											"no baseline",
											"no available n",
											"zero effect size",
											"zero variation",
										])
										.describe("Classifies metric power analysis results."),
									msg: zod
										.string()
										.describe(
											"Main power analysis result stated in human-friendly English.",
										),
									source_msg: zod
										.string()
										.describe(
											"Power analysis result formatted as a template string with curly-braced {} named placeholders. Use with the dictionary of values to support localization of messages.",
										),
									values: zod
										.record(zod.string(), zod.number().or(zod.number()))
										.or(zod.null())
										.optional(),
								})
								.describe("Describes interpretation of power analysis results.")
								.or(zod.null())
								.optional()
								.describe("Human friendly message about the above results."),
						})
						.describe("Describes analysis results of a single metric."),
				)
				.max(createExperimentBodyPowerAnalysesAnalysesMax),
		})
		.or(zod.null())
		.optional(),
	webhooks: zod
		.array(zod.string())
		.default(createExperimentBodyWebhooksDefault)
		.describe(
			"List of webhook IDs to associate with this experiment. When the experiment is committed, these webhooks will be triggered with experiment details. Must contain unique values.",
		),
});

export const createExperimentResponseDesignSpecParticipantTypeMax = 100;
export const createExperimentResponseDesignSpecExperimentNameMax = 100;
export const createExperimentResponseDesignSpecDescriptionMax = 2000;
export const createExperimentResponseDesignSpecDesignUrlMaxOne = 500;
export const createExperimentResponseDesignSpecArmsItemArmNameMax = 100;
export const createExperimentResponseDesignSpecArmsItemArmDescriptionMaxOne = 2000;
export const createExperimentResponseDesignSpecArmsMin = 2;

export const createExperimentResponseDesignSpecArmsMax = 10;
export const createExperimentResponseDesignSpecStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponseDesignSpecStrataMax = 150;
export const createExperimentResponseDesignSpecMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponseDesignSpecMetricsMax = 150;
export const createExperimentResponseDesignSpecFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponseDesignSpecFiltersMax = 20;
export const createExperimentResponseDesignSpecPowerDefault = 0.8;
export const createExperimentResponseDesignSpecPowerMin = 0;

export const createExperimentResponseDesignSpecPowerMax = 1;
export const createExperimentResponseDesignSpecAlphaDefault = 0.05;
export const createExperimentResponseDesignSpecAlphaMin = 0;

export const createExperimentResponseDesignSpecAlphaMax = 1;
export const createExperimentResponseDesignSpecFstatThreshDefault = 0.6;
export const createExperimentResponseDesignSpecFstatThreshMin = 0;

export const createExperimentResponseDesignSpecFstatThreshMax = 1;
export const createExperimentResponseDesignSpecParticipantTypeMaxOne = 100;
export const createExperimentResponseDesignSpecExperimentNameMaxOne = 100;
export const createExperimentResponseDesignSpecDescriptionMaxOne = 2000;
export const createExperimentResponseDesignSpecDesignUrlMaxFour = 500;
export const createExperimentResponseDesignSpecArmsItemArmNameMaxOne = 100;
export const createExperimentResponseDesignSpecArmsItemArmDescriptionMaxFour = 2000;
export const createExperimentResponseDesignSpecArmsMinOne = 2;

export const createExperimentResponseDesignSpecArmsMaxOne = 10;
export const createExperimentResponseDesignSpecStrataItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponseDesignSpecStrataMaxOne = 150;
export const createExperimentResponseDesignSpecMetricsItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponseDesignSpecMetricsMaxOne = 150;
export const createExperimentResponseDesignSpecFiltersItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponseDesignSpecFiltersMaxOne = 20;
export const createExperimentResponseDesignSpecPowerDefaultOne = 0.8;
export const createExperimentResponseDesignSpecPowerMinOne = 0;

export const createExperimentResponseDesignSpecPowerMaxOne = 1;
export const createExperimentResponseDesignSpecAlphaDefaultOne = 0.05;
export const createExperimentResponseDesignSpecAlphaMinOne = 0;

export const createExperimentResponseDesignSpecAlphaMaxOne = 1;
export const createExperimentResponseDesignSpecFstatThreshDefaultOne = 0.6;
export const createExperimentResponseDesignSpecFstatThreshMinOne = 0;

export const createExperimentResponseDesignSpecFstatThreshMaxOne = 1;
export const createExperimentResponseDesignSpecParticipantTypeMaxTwo = 100;
export const createExperimentResponseDesignSpecExperimentNameMaxTwo = 100;
export const createExperimentResponseDesignSpecDescriptionMaxTwo = 2000;
export const createExperimentResponseDesignSpecDesignUrlMaxSeven = 500;
export const createExperimentResponseDesignSpecArmsItemArmNameMaxTwo = 100;
export const createExperimentResponseDesignSpecArmsItemArmDescriptionMaxSeven = 2000;
export const createExperimentResponseDesignSpecArmsMinTwo = 2;

export const createExperimentResponseDesignSpecArmsMaxTwo = 10;
export const createExperimentResponseDesignSpecContextsItemContextNameMax = 100;
export const createExperimentResponseDesignSpecContextsItemContextDescriptionMaxOne = 2000;
export const createExperimentResponseDesignSpecContextsMaxOne = 150;
export const createExperimentResponseDesignSpecParticipantTypeMaxThree = 100;
export const createExperimentResponseDesignSpecExperimentNameMaxThree = 100;
export const createExperimentResponseDesignSpecDescriptionMaxThree = 2000;
export const createExperimentResponseDesignSpecDesignUrlMaxOnezero = 500;
export const createExperimentResponseDesignSpecArmsItemArmNameMaxThree = 100;
export const createExperimentResponseDesignSpecArmsItemArmDescriptionMaxOnezero = 2000;
export const createExperimentResponseDesignSpecArmsMinThree = 2;

export const createExperimentResponseDesignSpecArmsMaxThree = 10;
export const createExperimentResponseDesignSpecContextsItemContextNameMaxOne = 100;
export const createExperimentResponseDesignSpecContextsItemContextDescriptionMaxFour = 2000;
export const createExperimentResponseDesignSpecContextsMaxFour = 150;
export const createExperimentResponseDesignSpecParticipantTypeMaxFour = 100;
export const createExperimentResponseDesignSpecExperimentNameMaxFour = 100;
export const createExperimentResponseDesignSpecDescriptionMaxFour = 2000;
export const createExperimentResponseDesignSpecDesignUrlMaxOnethree = 500;
export const createExperimentResponseDesignSpecArmsItemArmNameMaxFour = 100;
export const createExperimentResponseDesignSpecArmsItemArmDescriptionMaxOnethree = 2000;
export const createExperimentResponseDesignSpecArmsMinFour = 2;

export const createExperimentResponseDesignSpecArmsMaxFour = 10;
export const createExperimentResponseDesignSpecContextsItemContextNameMaxTwo = 100;
export const createExperimentResponseDesignSpecContextsItemContextDescriptionMaxSeven = 2000;
export const createExperimentResponseDesignSpecContextsMaxSeven = 150;
export const createExperimentResponsePowerAnalysesAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const createExperimentResponsePowerAnalysesAnalysesMax = 150;
export const createExperimentResponseAssignSummaryArmSizesItemArmArmNameMax = 100;
export const createExperimentResponseAssignSummaryArmSizesItemArmArmDescriptionMaxOne = 2000;
export const createExperimentResponseAssignSummaryArmSizesItemSizeDefault = 0;
export const createExperimentResponseAssignSummaryArmSizesMaxOne = 10;
export const createExperimentResponseWebhooksDefault = [];

export const createExperimentResponse = zod
	.object({
		experiment_id: zod
			.string()
			.describe("Server-generated ID of the experiment."),
		datasource_id: zod.string(),
		state: zod
			.enum(["designing", "assigned", "abandoned", "committed", "aborted"])
			.describe(
				"Experiment lifecycle states.\n\nnote: [starting state], [[terminal state]]\n[DESIGNING]->[ASSIGNED]->{[[ABANDONED]], COMMITTED}->[[ABORTED]]",
			),
		stopped_assignments_at: zod
			.string()
			.datetime({})
			.or(zod.null())
			.describe(
				"The date and time assignments were stopped. Null if assignments are still allowed to be made.",
			),
		stopped_assignments_reason: zod
			.enum(["preassigned", "end_date", "manual", "target_n"])
			.describe("The reason assignments were stopped.")
			.or(zod.null())
			.describe(
				"The reason assignments were stopped. Null if assignments are still allowed to be made.",
			),
		design_spec: zod
			.object({
				participant_type: zod
					.string()
					.max(createExperimentResponseDesignSpecParticipantTypeMax),
				experiment_id: zod
					.string()
					.or(zod.null())
					.optional()
					.describe(
						"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
					),
				experiment_type: zod.enum(["freq_preassigned"]),
				experiment_name: zod
					.string()
					.max(createExperimentResponseDesignSpecExperimentNameMax),
				description: zod
					.string()
					.max(createExperimentResponseDesignSpecDescriptionMax),
				design_url: zod
					.string()
					.url()
					.min(1)
					.max(createExperimentResponseDesignSpecDesignUrlMaxOne)
					.or(zod.null())
					.optional()
					.describe("Optional URL to a more detailed experiment design doc."),
				start_date: zod.string().datetime({}),
				end_date: zod.string().datetime({}),
				arms: zod
					.array(
						zod
							.object({
								arm_id: zod
									.string()
									.or(zod.null())
									.optional()
									.describe(
										"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
									),
								arm_name: zod
									.string()
									.max(createExperimentResponseDesignSpecArmsItemArmNameMax),
								arm_description: zod
									.string()
									.max(
										createExperimentResponseDesignSpecArmsItemArmDescriptionMaxOne,
									)
									.or(zod.null())
									.optional(),
							})
							.describe("Describes an experiment treatment arm."),
					)
					.min(createExperimentResponseDesignSpecArmsMin)
					.max(createExperimentResponseDesignSpecArmsMax),
				strata: zod
					.array(
						zod
							.object({
								field_name: zod
									.string()
									.regex(
										createExperimentResponseDesignSpecStrataItemFieldNameRegExp,
									),
							})
							.describe("Describes a variable used for stratification."),
					)
					.max(createExperimentResponseDesignSpecStrataMax)
					.describe(
						"Optional participant_type fields to use for stratified assignment.",
					),
				metrics: zod
					.array(
						zod
							.object({
								field_name: zod
									.string()
									.regex(
										createExperimentResponseDesignSpecMetricsItemFieldNameRegExp,
									),
								metric_pct_change: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
									),
								metric_target: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
									),
							})
							.describe(
								"Defines a request to look up baseline stats for a metric to measure in an experiment.",
							),
					)
					.min(1)
					.max(createExperimentResponseDesignSpecMetricsMax)
					.describe("Primary and optional secondary metrics to target."),
				filters: zod
					.array(
						zod
							.object({
								field_name: zod
									.string()
									.regex(
										createExperimentResponseDesignSpecFiltersItemFieldNameRegExp,
									),
								relation: zod
									.enum(["includes", "excludes", "between"])
									.describe(
										"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
									),
								value: zod
									.array(zod.number().or(zod.null()))
									.or(zod.array(zod.number().or(zod.null())))
									.or(zod.array(zod.string().or(zod.null())))
									.or(zod.array(zod.boolean().or(zod.null()))),
							})
							.describe(
								'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value             | logical Result                                    |\n|----------|-------------------|---------------------------------------------------|\n| INCLUDES | [None]            | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]             | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None]       | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]        | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]            | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None]       | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]        | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]        | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", "z", None]  | Match `"a" <= x <= "z"` or `x IS NULL`            |\n| BETWEEN  | [None, "z"]       | Match `x <= "z"`                                  |\n| BETWEEN  | ["a", None]       | Match `x >= "a"`                                  |\n| BETWEEN  | [None, "a", None] | Match `x <= "a"` or `x IS NULL`                   |\n\nString comparisons are case-sensitive.\n\n## Special Handling for BETWEEN support of including NULL\n\nWhen the relation is BETWEEN, we allow for up to 3 values to support the special case of\nincluding null in addition to the values in the between range via an OR IS NULL clause, as\nindicated by a 3rd value of None. Any other 3rd value is invalid.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of DATE, DATETIME and TIMESTAMP values\n\nDATE, DATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
							),
					)
					.max(createExperimentResponseDesignSpecFiltersMax)
					.describe(
						"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
					),
				power: zod
					.number()
					.min(createExperimentResponseDesignSpecPowerMin)
					.max(createExperimentResponseDesignSpecPowerMax)
					.default(createExperimentResponseDesignSpecPowerDefault)
					.describe(
						"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
					),
				alpha: zod
					.number()
					.min(createExperimentResponseDesignSpecAlphaMin)
					.max(createExperimentResponseDesignSpecAlphaMax)
					.default(createExperimentResponseDesignSpecAlphaDefault)
					.describe(
						"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
					),
				fstat_thresh: zod
					.number()
					.min(createExperimentResponseDesignSpecFstatThreshMin)
					.max(createExperimentResponseDesignSpecFstatThreshMax)
					.default(createExperimentResponseDesignSpecFstatThreshDefault)
					.describe(
						'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
					),
			})
			.describe(
				"Use this type to randomly select and assign from existing participants at design time with\nfrequentist A/B experiments.",
			)
			.or(
				zod
					.object({
						participant_type: zod
							.string()
							.max(createExperimentResponseDesignSpecParticipantTypeMaxOne),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
							),
						experiment_type: zod.enum(["freq_online"]),
						experiment_name: zod
							.string()
							.max(createExperimentResponseDesignSpecExperimentNameMaxOne),
						description: zod
							.string()
							.max(createExperimentResponseDesignSpecDescriptionMaxOne),
						design_url: zod
							.string()
							.url()
							.min(1)
							.max(createExperimentResponseDesignSpecDesignUrlMaxFour)
							.or(zod.null())
							.optional()
							.describe(
								"Optional URL to a more detailed experiment design doc.",
							),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmNameMaxOne,
											),
										arm_description: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmDescriptionMaxFour,
											)
											.or(zod.null())
											.optional(),
									})
									.describe("Describes an experiment treatment arm."),
							)
							.min(createExperimentResponseDesignSpecArmsMinOne)
							.max(createExperimentResponseDesignSpecArmsMaxOne),
						strata: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												createExperimentResponseDesignSpecStrataItemFieldNameRegExpOne,
											),
									})
									.describe("Describes a variable used for stratification."),
							)
							.max(createExperimentResponseDesignSpecStrataMaxOne)
							.describe(
								"Optional participant_type fields to use for stratified assignment.",
							),
						metrics: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												createExperimentResponseDesignSpecMetricsItemFieldNameRegExpOne,
											),
										metric_pct_change: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
											),
										metric_target: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
											),
									})
									.describe(
										"Defines a request to look up baseline stats for a metric to measure in an experiment.",
									),
							)
							.min(1)
							.max(createExperimentResponseDesignSpecMetricsMaxOne)
							.describe("Primary and optional secondary metrics to target."),
						filters: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												createExperimentResponseDesignSpecFiltersItemFieldNameRegExpOne,
											),
										relation: zod
											.enum(["includes", "excludes", "between"])
											.describe(
												"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
											),
										value: zod
											.array(zod.number().or(zod.null()))
											.or(zod.array(zod.number().or(zod.null())))
											.or(zod.array(zod.string().or(zod.null())))
											.or(zod.array(zod.boolean().or(zod.null()))),
									})
									.describe(
										'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value             | logical Result                                    |\n|----------|-------------------|---------------------------------------------------|\n| INCLUDES | [None]            | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]             | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None]       | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]        | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]            | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None]       | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]        | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]        | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", "z", None]  | Match `"a" <= x <= "z"` or `x IS NULL`            |\n| BETWEEN  | [None, "z"]       | Match `x <= "z"`                                  |\n| BETWEEN  | ["a", None]       | Match `x >= "a"`                                  |\n| BETWEEN  | [None, "a", None] | Match `x <= "a"` or `x IS NULL`                   |\n\nString comparisons are case-sensitive.\n\n## Special Handling for BETWEEN support of including NULL\n\nWhen the relation is BETWEEN, we allow for up to 3 values to support the special case of\nincluding null in addition to the values in the between range via an OR IS NULL clause, as\nindicated by a 3rd value of None. Any other 3rd value is invalid.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of DATE, DATETIME and TIMESTAMP values\n\nDATE, DATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
									),
							)
							.max(createExperimentResponseDesignSpecFiltersMaxOne)
							.describe(
								"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
							),
						power: zod
							.number()
							.min(createExperimentResponseDesignSpecPowerMinOne)
							.max(createExperimentResponseDesignSpecPowerMaxOne)
							.default(createExperimentResponseDesignSpecPowerDefaultOne)
							.describe(
								"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
							),
						alpha: zod
							.number()
							.min(createExperimentResponseDesignSpecAlphaMinOne)
							.max(createExperimentResponseDesignSpecAlphaMaxOne)
							.default(createExperimentResponseDesignSpecAlphaDefaultOne)
							.describe(
								"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
							),
						fstat_thresh: zod
							.number()
							.min(createExperimentResponseDesignSpecFstatThreshMinOne)
							.max(createExperimentResponseDesignSpecFstatThreshMaxOne)
							.default(createExperimentResponseDesignSpecFstatThreshDefaultOne)
							.describe(
								'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
							),
					})
					.describe(
						"Use this type to randomly assign participants into arms during live experiment execution with\nfrequentist A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
					),
			)
			.or(
				zod
					.object({
						participant_type: zod
							.string()
							.max(createExperimentResponseDesignSpecParticipantTypeMaxTwo),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
							),
						experiment_type: zod.enum(["mab_online"]),
						experiment_name: zod
							.string()
							.max(createExperimentResponseDesignSpecExperimentNameMaxTwo),
						description: zod
							.string()
							.max(createExperimentResponseDesignSpecDescriptionMaxTwo),
						design_url: zod
							.string()
							.url()
							.min(1)
							.max(createExperimentResponseDesignSpecDesignUrlMaxSeven)
							.or(zod.null())
							.optional()
							.describe(
								"Optional URL to a more detailed experiment design doc.",
							),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmNameMaxTwo,
											),
										arm_description: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmDescriptionMaxSeven,
											)
											.or(zod.null())
											.optional(),
										alpha_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial alpha parameter for Beta prior"),
										beta_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial beta parameter for Beta prior"),
										mu_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial mean parameter for Normal prior"),
										sigma_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Initial standard deviation parameter for Normal prior",
											),
										alpha: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated alpha parameter for Beta prior"),
										beta: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated beta parameter for Beta prior"),
										mu: zod
											.array(zod.number())
											.or(zod.null())
											.optional()
											.describe("Updated mean vector for Normal prior"),
										covariance: zod
											.array(zod.array(zod.number()))
											.or(zod.null())
											.optional()
											.describe("Updated covariance matrix for Normal prior"),
									})
									.describe(
										"Describes an experiment arm for bandit experiments.",
									),
							)
							.min(createExperimentResponseDesignSpecArmsMinTwo)
							.max(createExperimentResponseDesignSpecArmsMaxTwo),
						contexts: zod
							.array(
								zod
									.object({
										context_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"Unique identifier for the context, you should NOT set this when creating a new context.",
											),
										context_name: zod
											.string()
											.max(
												createExperimentResponseDesignSpecContextsItemContextNameMax,
											),
										context_description: zod
											.string()
											.max(
												createExperimentResponseDesignSpecContextsItemContextDescriptionMaxOne,
											)
											.or(zod.null())
											.optional(),
										value_type: zod
											.enum(["binary", "real-valued"])
											.optional()
											.describe("Enum for the type of context."),
									})
									.describe("Pydantic model for context of the experiment."),
							)
							.max(createExperimentResponseDesignSpecContextsMaxOne)
							.or(zod.null())
							.optional()
							.describe(
								"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
							),
						prior_type: zod
							.enum(["beta", "normal"])
							.optional()
							.describe("Enum for the prior distribution of the arm."),
						reward_type: zod
							.enum(["binary", "real-valued"])
							.optional()
							.describe("Enum for the likelihood distribution of the reward."),
					})
					.describe(
						"Use this type to randomly assign participants into arms during live experiment execution with MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
					),
			)
			.or(
				zod
					.object({
						participant_type: zod
							.string()
							.max(createExperimentResponseDesignSpecParticipantTypeMaxThree),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
							),
						experiment_type: zod.enum(["cmab_online"]),
						experiment_name: zod
							.string()
							.max(createExperimentResponseDesignSpecExperimentNameMaxThree),
						description: zod
							.string()
							.max(createExperimentResponseDesignSpecDescriptionMaxThree),
						design_url: zod
							.string()
							.url()
							.min(1)
							.max(createExperimentResponseDesignSpecDesignUrlMaxOnezero)
							.or(zod.null())
							.optional()
							.describe(
								"Optional URL to a more detailed experiment design doc.",
							),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmNameMaxThree,
											),
										arm_description: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmDescriptionMaxOnezero,
											)
											.or(zod.null())
											.optional(),
										alpha_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial alpha parameter for Beta prior"),
										beta_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial beta parameter for Beta prior"),
										mu_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial mean parameter for Normal prior"),
										sigma_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Initial standard deviation parameter for Normal prior",
											),
										alpha: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated alpha parameter for Beta prior"),
										beta: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated beta parameter for Beta prior"),
										mu: zod
											.array(zod.number())
											.or(zod.null())
											.optional()
											.describe("Updated mean vector for Normal prior"),
										covariance: zod
											.array(zod.array(zod.number()))
											.or(zod.null())
											.optional()
											.describe("Updated covariance matrix for Normal prior"),
									})
									.describe(
										"Describes an experiment arm for bandit experiments.",
									),
							)
							.min(createExperimentResponseDesignSpecArmsMinThree)
							.max(createExperimentResponseDesignSpecArmsMaxThree),
						contexts: zod
							.array(
								zod
									.object({
										context_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"Unique identifier for the context, you should NOT set this when creating a new context.",
											),
										context_name: zod
											.string()
											.max(
												createExperimentResponseDesignSpecContextsItemContextNameMaxOne,
											),
										context_description: zod
											.string()
											.max(
												createExperimentResponseDesignSpecContextsItemContextDescriptionMaxFour,
											)
											.or(zod.null())
											.optional(),
										value_type: zod
											.enum(["binary", "real-valued"])
											.optional()
											.describe("Enum for the type of context."),
									})
									.describe("Pydantic model for context of the experiment."),
							)
							.max(createExperimentResponseDesignSpecContextsMaxFour)
							.or(zod.null())
							.optional()
							.describe(
								"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
							),
						prior_type: zod
							.enum(["beta", "normal"])
							.optional()
							.describe("Enum for the prior distribution of the arm."),
						reward_type: zod
							.enum(["binary", "real-valued"])
							.optional()
							.describe("Enum for the likelihood distribution of the reward."),
					})
					.describe(
						"Use this type to randomly assign participants into arms during live experiment execution with\ncontextual MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
					),
			)
			.or(
				zod
					.object({
						participant_type: zod
							.string()
							.max(createExperimentResponseDesignSpecParticipantTypeMaxFour),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
							),
						experiment_type: zod.enum(["bayes_ab_online"]),
						experiment_name: zod
							.string()
							.max(createExperimentResponseDesignSpecExperimentNameMaxFour),
						description: zod
							.string()
							.max(createExperimentResponseDesignSpecDescriptionMaxFour),
						design_url: zod
							.string()
							.url()
							.min(1)
							.max(createExperimentResponseDesignSpecDesignUrlMaxOnethree)
							.or(zod.null())
							.optional()
							.describe(
								"Optional URL to a more detailed experiment design doc.",
							),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmNameMaxFour,
											),
										arm_description: zod
											.string()
											.max(
												createExperimentResponseDesignSpecArmsItemArmDescriptionMaxOnethree,
											)
											.or(zod.null())
											.optional(),
										alpha_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial alpha parameter for Beta prior"),
										beta_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial beta parameter for Beta prior"),
										mu_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial mean parameter for Normal prior"),
										sigma_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Initial standard deviation parameter for Normal prior",
											),
										alpha: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated alpha parameter for Beta prior"),
										beta: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated beta parameter for Beta prior"),
										mu: zod
											.array(zod.number())
											.or(zod.null())
											.optional()
											.describe("Updated mean vector for Normal prior"),
										covariance: zod
											.array(zod.array(zod.number()))
											.or(zod.null())
											.optional()
											.describe("Updated covariance matrix for Normal prior"),
									})
									.describe(
										"Describes an experiment arm for bandit experiments.",
									),
							)
							.min(createExperimentResponseDesignSpecArmsMinFour)
							.max(createExperimentResponseDesignSpecArmsMaxFour),
						contexts: zod
							.array(
								zod
									.object({
										context_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"Unique identifier for the context, you should NOT set this when creating a new context.",
											),
										context_name: zod
											.string()
											.max(
												createExperimentResponseDesignSpecContextsItemContextNameMaxTwo,
											),
										context_description: zod
											.string()
											.max(
												createExperimentResponseDesignSpecContextsItemContextDescriptionMaxSeven,
											)
											.or(zod.null())
											.optional(),
										value_type: zod
											.enum(["binary", "real-valued"])
											.optional()
											.describe("Enum for the type of context."),
									})
									.describe("Pydantic model for context of the experiment."),
							)
							.max(createExperimentResponseDesignSpecContextsMaxSeven)
							.or(zod.null())
							.optional()
							.describe(
								"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
							),
						prior_type: zod
							.enum(["beta", "normal"])
							.optional()
							.describe("Enum for the prior distribution of the arm."),
						reward_type: zod
							.enum(["binary", "real-valued"])
							.optional()
							.describe("Enum for the likelihood distribution of the reward."),
					})
					.describe(
						"Use this type to randomly assign participants into arms during live experiment execution with\nBayesian A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
					),
			)
			.describe("The type of assignment and experiment design."),
		power_analyses: zod
			.object({
				analyses: zod
					.array(
						zod
							.object({
								metric_spec: zod
									.object({
										field_name: zod
											.string()
											.regex(
												createExperimentResponsePowerAnalysesAnalysesItemMetricSpecFieldNameRegExp,
											),
										metric_pct_change: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Percent change target relative to the metric_baseline.",
											),
										metric_target: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Absolute target value = metric_baseline*(1 + metric_pct_change)",
											),
										metric_type: zod
											.enum(["binary", "numeric"])
											.describe("Classifies metrics by their value type.")
											.or(zod.null())
											.optional()
											.describe("Inferred from dwh type."),
										metric_baseline: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Mean of the tracked metric."),
										metric_stddev: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Standard deviation is set only for metric_type.NUMERIC metrics. Must be set for numeric metrics when available_n > 0.",
											),
										available_nonnull_n: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"The number of participants meeting the filtering criteria with a *non-null* value for this metric.",
											),
										available_n: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n.",
											),
									})
									.describe(
										"Defines a metric to measure in an experiment with its baseline stats.",
									),
								target_n: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Minimum sample size needed to meet the design specs.",
									),
								sufficient_n: zod
									.boolean()
									.or(zod.null())
									.optional()
									.describe(
										"Whether or not there are enough available units to sample from to meet target_n.",
									),
								target_possible: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.",
									),
								pct_change_possible: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.",
									),
								msg: zod
									.object({
										type: zod
											.enum([
												"sufficient",
												"insufficient",
												"no baseline",
												"no available n",
												"zero effect size",
												"zero variation",
											])
											.describe("Classifies metric power analysis results."),
										msg: zod
											.string()
											.describe(
												"Main power analysis result stated in human-friendly English.",
											),
										source_msg: zod
											.string()
											.describe(
												"Power analysis result formatted as a template string with curly-braced {} named placeholders. Use with the dictionary of values to support localization of messages.",
											),
										values: zod
											.record(zod.string(), zod.number().or(zod.number()))
											.or(zod.null())
											.optional(),
									})
									.describe(
										"Describes interpretation of power analysis results.",
									)
									.or(zod.null())
									.optional()
									.describe("Human friendly message about the above results."),
							})
							.describe("Describes analysis results of a single metric."),
					)
					.max(createExperimentResponsePowerAnalysesAnalysesMax),
			})
			.or(zod.null()),
		assign_summary: zod
			.object({
				balance_check: zod
					.object({
						f_statistic: zod
							.number()
							.describe(
								"F-statistic testing the overall significance of the model predicting treatment assignment.",
							),
						numerator_df: zod
							.number()
							.describe(
								"The numerator degrees of freedom for the f-statistic related to number of dependent variables.",
							),
						denominator_df: zod
							.number()
							.describe(
								"Denominator degrees of freedom related to the number of observations.",
							),
						p_value: zod
							.number()
							.describe(
								"Probability of observing these data if strata do not predict treatment assignment, i.e. our randomization is balanced.",
							),
						balance_ok: zod
							.boolean()
							.describe(
								"Whether the p-value for our observed f_statistic is greater than the f-stat threshold specified in our design specification. (See DesignSpec.fstat_thresh)",
							),
					})
					.describe("Describes balance test results for treatment assignment.")
					.or(zod.null())
					.optional()
					.describe(
						"Balance test results if available. 'online' experiments do not have balance checks.",
					),
				sample_size: zod
					.number()
					.describe("The number of participants across all arms in total."),
				arm_sizes: zod
					.array(
						zod
							.object({
								arm: zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												createExperimentResponseAssignSummaryArmSizesItemArmArmNameMax,
											),
										arm_description: zod
											.string()
											.max(
												createExperimentResponseAssignSummaryArmSizesItemArmArmDescriptionMaxOne,
											)
											.or(zod.null())
											.optional(),
									})
									.describe("Describes an experiment treatment arm."),
								size: zod.number().optional(),
							})
							.describe(
								"Describes the number of participants assigned to each arm.",
							),
					)
					.max(createExperimentResponseAssignSummaryArmSizesMaxOne)
					.or(zod.null())
					.optional()
					.describe("For each arm, the number of participants assigned."),
			})
			.describe("Key pieces of an AssignResponse without the assignments.")
			.or(zod.null()),
		webhooks: zod
			.array(zod.string())
			.default(createExperimentResponseWebhooksDefault)
			.describe(
				"List of webhook IDs associated with this experiment. These webhooks are triggered when the experiment is committed.",
			),
	})
	.describe(
		"Same as the request but with ids filled for the experiment and arms, and summary info on the assignment.",
	);

/**
 * For preassigned experiments, and online experiments (except contextual bandits),
    returns an analysis of the experiment's performance, given datasource and experiment ID.
 * @summary Analyze Experiment
 */
export const analyzeExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const analyzeExperimentQueryParams = zod.object({
	baseline_arm_id: zod
		.string()
		.or(zod.null())
		.optional()
		.describe(
			"UUID of the baseline arm. If None, the first design spec arm is used.",
		),
});

export const analyzeExperimentResponseMetricAnalysesItemMetricFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const analyzeExperimentResponseMetricAnalysesItemArmAnalysesItemArmNameMax = 100;
export const analyzeExperimentResponseMetricAnalysesItemArmAnalysesItemArmDescriptionMaxOne = 2000;
export const analyzeExperimentResponseMetricAnalysesItemArmAnalysesItemNumMissingValuesMin =
	-1;
export const analyzeExperimentResponseArmAnalysesItemArmNameMax = 100;
export const analyzeExperimentResponseArmAnalysesItemArmDescriptionMaxOne = 2000;

export const analyzeExperimentResponse = zod
	.object({
		type: zod.enum(["freq"]),
		experiment_id: zod.string().describe("ID of the experiment."),
		metric_analyses: zod
			.array(
				zod
					.object({
						metric_name: zod.string(),
						metric: zod
							.object({
								field_name: zod
									.string()
									.regex(
										analyzeExperimentResponseMetricAnalysesItemMetricFieldNameRegExp,
									),
								metric_pct_change: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
									),
								metric_target: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
									),
							})
							.describe(
								"Defines a request to look up baseline stats for a metric to measure in an experiment.",
							),
						arm_analyses: zod
							.array(
								zod.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(
											analyzeExperimentResponseMetricAnalysesItemArmAnalysesItemArmNameMax,
										),
									arm_description: zod
										.string()
										.max(
											analyzeExperimentResponseMetricAnalysesItemArmAnalysesItemArmDescriptionMaxOne,
										)
										.or(zod.null())
										.optional(),
									estimate: zod
										.number()
										.describe(
											"The estimated treatment effect relative to the baseline arm.",
										),
									p_value: zod
										.number()
										.or(zod.null())
										.describe(
											"The p-value indicating statistical significance of the treatment effect. Value may be None if the t-stat is not available, e.g. due to inability to calculate the standard error.",
										),
									t_stat: zod
										.number()
										.or(zod.null())
										.describe(
											"The t-statistic from the statistical test. If the value is actually NaN, e.g. due to inability to calculate the standard error, we return None.",
										),
									std_error: zod
										.number()
										.or(zod.null())
										.describe(
											"The standard error of the treatment effect estimate.",
										),
									num_missing_values: zod
										.number()
										.min(
											analyzeExperimentResponseMetricAnalysesItemArmAnalysesItemNumMissingValuesMin,
										)
										.describe(
											"The number of participants assigned to this arm with missing values (NaNs) for this metric. These rows are excluded from the analysis. -1 indicates arm analysis not available due to all assignments missing outcomes for this metric.",
										),
									is_baseline: zod
										.boolean()
										.describe(
											"Whether this arm is the baseline/control arm for comparison.",
										),
								}),
							)
							.describe(
								"The results of the analysis for each arm (coefficient) for this specific metric.",
							),
					})
					.describe(
						"Describes the change in a single metric for each arm of an experiment.",
					),
			)
			.describe("Contains one analysis per metric targeted by the experiment."),
		num_participants: zod
			.number()
			.describe(
				"The number of participants assigned to the experiment pulled from the dwh across all arms. Metric outcomes are not guaranteed to be present for all participants.",
			),
		num_missing_participants: zod
			.number()
			.or(zod.null())
			.optional()
			.describe(
				"The number of participants assigned to the experiment across all arms that are not found in the data warehouse when pulling metrics.",
			),
		created_at: zod
			.string()
			.datetime({})
			.describe("The date and time the experiment analysis was created."),
	})
	.describe("Describes the change if any in metrics targeted by an experiment.")
	.or(
		zod
			.object({
				type: zod.enum(["bandit"]),
				experiment_id: zod.string().describe("ID of the experiment."),
				arm_analyses: zod
					.array(
						zod
							.object({
								arm_id: zod
									.string()
									.or(zod.null())
									.optional()
									.describe(
										"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
									),
								arm_name: zod
									.string()
									.max(analyzeExperimentResponseArmAnalysesItemArmNameMax),
								arm_description: zod
									.string()
									.max(
										analyzeExperimentResponseArmAnalysesItemArmDescriptionMaxOne,
									)
									.or(zod.null())
									.optional(),
								alpha_init: zod
									.number()
									.or(zod.null())
									.optional()
									.describe("Initial alpha parameter for Beta prior"),
								beta_init: zod
									.number()
									.or(zod.null())
									.optional()
									.describe("Initial beta parameter for Beta prior"),
								mu_init: zod
									.number()
									.or(zod.null())
									.optional()
									.describe("Initial mean parameter for Normal prior"),
								sigma_init: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Initial standard deviation parameter for Normal prior",
									),
								alpha: zod
									.number()
									.or(zod.null())
									.optional()
									.describe("Updated alpha parameter for Beta prior"),
								beta: zod
									.number()
									.or(zod.null())
									.optional()
									.describe("Updated beta parameter for Beta prior"),
								mu: zod
									.array(zod.number())
									.or(zod.null())
									.optional()
									.describe("Updated mean vector for Normal prior"),
								covariance: zod
									.array(zod.array(zod.number()))
									.or(zod.null())
									.optional()
									.describe("Updated covariance matrix for Normal prior"),
								prior_pred_mean: zod
									.number()
									.describe("Posterior predictive mean for this arm."),
								prior_pred_stdev: zod
									.number()
									.describe(
										"Posterior predictive standard deviation for this arm.",
									),
								post_pred_mean: zod
									.number()
									.describe("Posterior predictive mean for this arm."),
								post_pred_stdev: zod
									.number()
									.describe(
										"Posterior predictive standard deviation for this arm.",
									),
							})
							.describe(
								"Describes an experiment arm analysis for bandit experiments.",
							),
					)
					.describe(
						"Contains one analysis per metric targeted by the experiment.",
					),
				n_outcomes: zod
					.number()
					.describe("The number of outcomes observed for this experiment."),
				created_at: zod
					.string()
					.datetime({})
					.describe("The date and time the experiment analysis was created."),
				contexts: zod
					.array(zod.number())
					.or(zod.null())
					.optional()
					.describe("The context values used for the analysis, if applicable."),
			})
			.describe("Describes changes in arms for a bandit experiment"),
	)
	.describe("The type of experiment analysis response.");

/**
 * For contextual bandit experiments, returns an analysis of the experiment's performance,
    given datasource and experiment ID and context values as input.
 * @summary Analyze Cmab Experiment
 */
export const analyzeCmabExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const analyzeCmabExperimentBodyTypeDefault = "cmab_assignment";

export const analyzeCmabExperimentBody = zod
	.object({
		type: zod.string().default(analyzeCmabExperimentBodyTypeDefault),
		context_inputs: zod
			.array(
				zod
					.object({
						context_id: zod
							.string()
							.describe("Unique identifier for the context."),
						context_value: zod.number().describe("Value of the context"),
					})
					.describe("Pydantic model for a context input"),
			)
			.describe(
				"\n            List of context values for the assignment.\n            Must include exactly the same number contexts defined in the experiment.\n            The values are matched to the experiment's contexts by context_id, not by position in the list.\n            Each context_id must correspond to one of the IDs of the contexts defined in the experiment.\n            Can be None, when simply retrieving pre-existing assignments; must have valid inputs otherwise.\n            ",
			),
	})
	.describe(
		'Request model for creating a new CMAB assignment or a CMAB experiment analysis.\n\nWhen submitting context values for a CMAB experiment, the following rules apply:\n1. Each context_input must reference a valid context_id from the experiment\'s defined contexts\n2. The order of context_inputs does not need to match the order of contexts in the experiment\n3. You must provide values for all contexts defined in the experiment\n4. Number of input context values must match the number of contexts defined in the experiment\n5. The context value input can be None, but only in the case of retrieving a pre-existing assignment.\n\nExample:\n    If an experiment defines contexts with IDs ["ctx_1", "ctx_2"], your request must include\n    both of these context_ids in the context_inputs list, but they can be in any order.',
	);

export const analyzeCmabExperimentResponseMetricAnalysesItemMetricFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const analyzeCmabExperimentResponseMetricAnalysesItemArmAnalysesItemArmNameMax = 100;
export const analyzeCmabExperimentResponseMetricAnalysesItemArmAnalysesItemArmDescriptionMaxOne = 2000;
export const analyzeCmabExperimentResponseMetricAnalysesItemArmAnalysesItemNumMissingValuesMin =
	-1;
export const analyzeCmabExperimentResponseArmAnalysesItemArmNameMax = 100;
export const analyzeCmabExperimentResponseArmAnalysesItemArmDescriptionMaxOne = 2000;

export const analyzeCmabExperimentResponse = zod
	.object({
		type: zod.enum(["freq"]),
		experiment_id: zod.string().describe("ID of the experiment."),
		metric_analyses: zod
			.array(
				zod
					.object({
						metric_name: zod.string(),
						metric: zod
							.object({
								field_name: zod
									.string()
									.regex(
										analyzeCmabExperimentResponseMetricAnalysesItemMetricFieldNameRegExp,
									),
								metric_pct_change: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
									),
								metric_target: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
									),
							})
							.describe(
								"Defines a request to look up baseline stats for a metric to measure in an experiment.",
							),
						arm_analyses: zod
							.array(
								zod.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(
											analyzeCmabExperimentResponseMetricAnalysesItemArmAnalysesItemArmNameMax,
										),
									arm_description: zod
										.string()
										.max(
											analyzeCmabExperimentResponseMetricAnalysesItemArmAnalysesItemArmDescriptionMaxOne,
										)
										.or(zod.null())
										.optional(),
									estimate: zod
										.number()
										.describe(
											"The estimated treatment effect relative to the baseline arm.",
										),
									p_value: zod
										.number()
										.or(zod.null())
										.describe(
											"The p-value indicating statistical significance of the treatment effect. Value may be None if the t-stat is not available, e.g. due to inability to calculate the standard error.",
										),
									t_stat: zod
										.number()
										.or(zod.null())
										.describe(
											"The t-statistic from the statistical test. If the value is actually NaN, e.g. due to inability to calculate the standard error, we return None.",
										),
									std_error: zod
										.number()
										.or(zod.null())
										.describe(
											"The standard error of the treatment effect estimate.",
										),
									num_missing_values: zod
										.number()
										.min(
											analyzeCmabExperimentResponseMetricAnalysesItemArmAnalysesItemNumMissingValuesMin,
										)
										.describe(
											"The number of participants assigned to this arm with missing values (NaNs) for this metric. These rows are excluded from the analysis. -1 indicates arm analysis not available due to all assignments missing outcomes for this metric.",
										),
									is_baseline: zod
										.boolean()
										.describe(
											"Whether this arm is the baseline/control arm for comparison.",
										),
								}),
							)
							.describe(
								"The results of the analysis for each arm (coefficient) for this specific metric.",
							),
					})
					.describe(
						"Describes the change in a single metric for each arm of an experiment.",
					),
			)
			.describe("Contains one analysis per metric targeted by the experiment."),
		num_participants: zod
			.number()
			.describe(
				"The number of participants assigned to the experiment pulled from the dwh across all arms. Metric outcomes are not guaranteed to be present for all participants.",
			),
		num_missing_participants: zod
			.number()
			.or(zod.null())
			.optional()
			.describe(
				"The number of participants assigned to the experiment across all arms that are not found in the data warehouse when pulling metrics.",
			),
		created_at: zod
			.string()
			.datetime({})
			.describe("The date and time the experiment analysis was created."),
	})
	.describe("Describes the change if any in metrics targeted by an experiment.")
	.or(
		zod
			.object({
				type: zod.enum(["bandit"]),
				experiment_id: zod.string().describe("ID of the experiment."),
				arm_analyses: zod
					.array(
						zod
							.object({
								arm_id: zod
									.string()
									.or(zod.null())
									.optional()
									.describe(
										"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
									),
								arm_name: zod
									.string()
									.max(analyzeCmabExperimentResponseArmAnalysesItemArmNameMax),
								arm_description: zod
									.string()
									.max(
										analyzeCmabExperimentResponseArmAnalysesItemArmDescriptionMaxOne,
									)
									.or(zod.null())
									.optional(),
								alpha_init: zod
									.number()
									.or(zod.null())
									.optional()
									.describe("Initial alpha parameter for Beta prior"),
								beta_init: zod
									.number()
									.or(zod.null())
									.optional()
									.describe("Initial beta parameter for Beta prior"),
								mu_init: zod
									.number()
									.or(zod.null())
									.optional()
									.describe("Initial mean parameter for Normal prior"),
								sigma_init: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Initial standard deviation parameter for Normal prior",
									),
								alpha: zod
									.number()
									.or(zod.null())
									.optional()
									.describe("Updated alpha parameter for Beta prior"),
								beta: zod
									.number()
									.or(zod.null())
									.optional()
									.describe("Updated beta parameter for Beta prior"),
								mu: zod
									.array(zod.number())
									.or(zod.null())
									.optional()
									.describe("Updated mean vector for Normal prior"),
								covariance: zod
									.array(zod.array(zod.number()))
									.or(zod.null())
									.optional()
									.describe("Updated covariance matrix for Normal prior"),
								prior_pred_mean: zod
									.number()
									.describe("Posterior predictive mean for this arm."),
								prior_pred_stdev: zod
									.number()
									.describe(
										"Posterior predictive standard deviation for this arm.",
									),
								post_pred_mean: zod
									.number()
									.describe("Posterior predictive mean for this arm."),
								post_pred_stdev: zod
									.number()
									.describe(
										"Posterior predictive standard deviation for this arm.",
									),
							})
							.describe(
								"Describes an experiment arm analysis for bandit experiments.",
							),
					)
					.describe(
						"Contains one analysis per metric targeted by the experiment.",
					),
				n_outcomes: zod
					.number()
					.describe("The number of outcomes observed for this experiment."),
				created_at: zod
					.string()
					.datetime({})
					.describe("The date and time the experiment analysis was created."),
				contexts: zod
					.array(zod.number())
					.or(zod.null())
					.optional()
					.describe("The context values used for the analysis, if applicable."),
			})
			.describe("Describes changes in arms for a bandit experiment"),
	)
	.describe("The type of experiment analysis response.");

/**
 * @summary Commit Experiment
 */
export const commitExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

/**
 * @summary Abandon Experiment
 */
export const abandonExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

/**
 * Returns a list of experiments in the organization.
 * @summary List Organization Experiments
 */
export const listOrganizationExperimentsParams = zod.object({
	organization_id: zod.string(),
});

export const listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMax = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMax = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMax = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecDesignUrlMaxOne = 500;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMax = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxOne = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMin = 2;

export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMax = 10;
export const listOrganizationExperimentsResponseItemsItemDesignSpecStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listOrganizationExperimentsResponseItemsItemDesignSpecStrataMax = 150;
export const listOrganizationExperimentsResponseItemsItemDesignSpecMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listOrganizationExperimentsResponseItemsItemDesignSpecMetricsMax = 150;
export const listOrganizationExperimentsResponseItemsItemDesignSpecFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listOrganizationExperimentsResponseItemsItemDesignSpecFiltersMax = 20;
export const listOrganizationExperimentsResponseItemsItemDesignSpecPowerDefault = 0.8;
export const listOrganizationExperimentsResponseItemsItemDesignSpecPowerMin = 0;

export const listOrganizationExperimentsResponseItemsItemDesignSpecPowerMax = 1;
export const listOrganizationExperimentsResponseItemsItemDesignSpecAlphaDefault = 0.05;
export const listOrganizationExperimentsResponseItemsItemDesignSpecAlphaMin = 0;

export const listOrganizationExperimentsResponseItemsItemDesignSpecAlphaMax = 1;
export const listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshDefault = 0.6;
export const listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshMin = 0;

export const listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshMax = 1;
export const listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMaxOne = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMaxOne = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMaxOne = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecDesignUrlMaxFour = 500;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxOne = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxFour = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMinOne = 2;

export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMaxOne = 10;
export const listOrganizationExperimentsResponseItemsItemDesignSpecStrataItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listOrganizationExperimentsResponseItemsItemDesignSpecStrataMaxOne = 150;
export const listOrganizationExperimentsResponseItemsItemDesignSpecMetricsItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listOrganizationExperimentsResponseItemsItemDesignSpecMetricsMaxOne = 150;
export const listOrganizationExperimentsResponseItemsItemDesignSpecFiltersItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listOrganizationExperimentsResponseItemsItemDesignSpecFiltersMaxOne = 20;
export const listOrganizationExperimentsResponseItemsItemDesignSpecPowerDefaultOne = 0.8;
export const listOrganizationExperimentsResponseItemsItemDesignSpecPowerMinOne = 0;

export const listOrganizationExperimentsResponseItemsItemDesignSpecPowerMaxOne = 1;
export const listOrganizationExperimentsResponseItemsItemDesignSpecAlphaDefaultOne = 0.05;
export const listOrganizationExperimentsResponseItemsItemDesignSpecAlphaMinOne = 0;

export const listOrganizationExperimentsResponseItemsItemDesignSpecAlphaMaxOne = 1;
export const listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshDefaultOne = 0.6;
export const listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshMinOne = 0;

export const listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshMaxOne = 1;
export const listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMaxTwo = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMaxTwo = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMaxTwo = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecDesignUrlMaxSeven = 500;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxTwo = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxSeven = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMinTwo = 2;

export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMaxTwo = 10;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextNameMax = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextDescriptionMaxOne = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsMaxOne = 150;
export const listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMaxThree = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMaxThree = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMaxThree = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecDesignUrlMaxOnezero = 500;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxThree = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxOnezero = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMinThree = 2;

export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMaxThree = 10;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextNameMaxOne = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextDescriptionMaxFour = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsMaxFour = 150;
export const listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMaxFour = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMaxFour = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMaxFour = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecDesignUrlMaxOnethree = 500;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxFour = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxOnethree = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMinFour = 2;

export const listOrganizationExperimentsResponseItemsItemDesignSpecArmsMaxFour = 10;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextNameMaxTwo = 100;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextDescriptionMaxSeven = 2000;
export const listOrganizationExperimentsResponseItemsItemDesignSpecContextsMaxSeven = 150;
export const listOrganizationExperimentsResponseItemsItemPowerAnalysesAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const listOrganizationExperimentsResponseItemsItemPowerAnalysesAnalysesMax = 150;
export const listOrganizationExperimentsResponseItemsItemAssignSummaryArmSizesItemArmArmNameMax = 100;
export const listOrganizationExperimentsResponseItemsItemAssignSummaryArmSizesItemArmArmDescriptionMaxOne = 2000;
export const listOrganizationExperimentsResponseItemsItemAssignSummaryArmSizesItemSizeDefault = 0;
export const listOrganizationExperimentsResponseItemsItemAssignSummaryArmSizesMaxOne = 10;
export const listOrganizationExperimentsResponseItemsItemWebhooksDefault = [];

export const listOrganizationExperimentsResponse = zod.object({
	items: zod.array(
		zod
			.object({
				experiment_id: zod
					.string()
					.describe("Server-generated ID of the experiment."),
				datasource_id: zod.string(),
				state: zod
					.enum(["designing", "assigned", "abandoned", "committed", "aborted"])
					.describe(
						"Experiment lifecycle states.\n\nnote: [starting state], [[terminal state]]\n[DESIGNING]->[ASSIGNED]->{[[ABANDONED]], COMMITTED}->[[ABORTED]]",
					),
				stopped_assignments_at: zod
					.string()
					.datetime({})
					.or(zod.null())
					.describe(
						"The date and time assignments were stopped. Null if assignments are still allowed to be made.",
					),
				stopped_assignments_reason: zod
					.enum(["preassigned", "end_date", "manual", "target_n"])
					.describe("The reason assignments were stopped.")
					.or(zod.null())
					.describe(
						"The reason assignments were stopped. Null if assignments are still allowed to be made.",
					),
				design_spec: zod
					.object({
						participant_type: zod
							.string()
							.max(
								listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMax,
							),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
							),
						experiment_type: zod.enum(["freq_preassigned"]),
						experiment_name: zod
							.string()
							.max(
								listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMax,
							),
						description: zod
							.string()
							.max(
								listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMax,
							),
						design_url: zod
							.string()
							.url()
							.min(1)
							.max(
								listOrganizationExperimentsResponseItemsItemDesignSpecDesignUrlMaxOne,
							)
							.or(zod.null())
							.optional()
							.describe(
								"Optional URL to a more detailed experiment design doc.",
							),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMax,
											),
										arm_description: zod
											.string()
											.max(
												listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxOne,
											)
											.or(zod.null())
											.optional(),
									})
									.describe("Describes an experiment treatment arm."),
							)
							.min(
								listOrganizationExperimentsResponseItemsItemDesignSpecArmsMin,
							)
							.max(
								listOrganizationExperimentsResponseItemsItemDesignSpecArmsMax,
							),
						strata: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												listOrganizationExperimentsResponseItemsItemDesignSpecStrataItemFieldNameRegExp,
											),
									})
									.describe("Describes a variable used for stratification."),
							)
							.max(
								listOrganizationExperimentsResponseItemsItemDesignSpecStrataMax,
							)
							.describe(
								"Optional participant_type fields to use for stratified assignment.",
							),
						metrics: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												listOrganizationExperimentsResponseItemsItemDesignSpecMetricsItemFieldNameRegExp,
											),
										metric_pct_change: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
											),
										metric_target: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
											),
									})
									.describe(
										"Defines a request to look up baseline stats for a metric to measure in an experiment.",
									),
							)
							.min(1)
							.max(
								listOrganizationExperimentsResponseItemsItemDesignSpecMetricsMax,
							)
							.describe("Primary and optional secondary metrics to target."),
						filters: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												listOrganizationExperimentsResponseItemsItemDesignSpecFiltersItemFieldNameRegExp,
											),
										relation: zod
											.enum(["includes", "excludes", "between"])
											.describe(
												"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
											),
										value: zod
											.array(zod.number().or(zod.null()))
											.or(zod.array(zod.number().or(zod.null())))
											.or(zod.array(zod.string().or(zod.null())))
											.or(zod.array(zod.boolean().or(zod.null()))),
									})
									.describe(
										'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value             | logical Result                                    |\n|----------|-------------------|---------------------------------------------------|\n| INCLUDES | [None]            | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]             | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None]       | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]        | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]            | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None]       | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]        | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]        | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", "z", None]  | Match `"a" <= x <= "z"` or `x IS NULL`            |\n| BETWEEN  | [None, "z"]       | Match `x <= "z"`                                  |\n| BETWEEN  | ["a", None]       | Match `x >= "a"`                                  |\n| BETWEEN  | [None, "a", None] | Match `x <= "a"` or `x IS NULL`                   |\n\nString comparisons are case-sensitive.\n\n## Special Handling for BETWEEN support of including NULL\n\nWhen the relation is BETWEEN, we allow for up to 3 values to support the special case of\nincluding null in addition to the values in the between range via an OR IS NULL clause, as\nindicated by a 3rd value of None. Any other 3rd value is invalid.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of DATE, DATETIME and TIMESTAMP values\n\nDATE, DATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
									),
							)
							.max(
								listOrganizationExperimentsResponseItemsItemDesignSpecFiltersMax,
							)
							.describe(
								"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
							),
						power: zod
							.number()
							.min(
								listOrganizationExperimentsResponseItemsItemDesignSpecPowerMin,
							)
							.max(
								listOrganizationExperimentsResponseItemsItemDesignSpecPowerMax,
							)
							.default(
								listOrganizationExperimentsResponseItemsItemDesignSpecPowerDefault,
							)
							.describe(
								"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
							),
						alpha: zod
							.number()
							.min(
								listOrganizationExperimentsResponseItemsItemDesignSpecAlphaMin,
							)
							.max(
								listOrganizationExperimentsResponseItemsItemDesignSpecAlphaMax,
							)
							.default(
								listOrganizationExperimentsResponseItemsItemDesignSpecAlphaDefault,
							)
							.describe(
								"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
							),
						fstat_thresh: zod
							.number()
							.min(
								listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshMin,
							)
							.max(
								listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshMax,
							)
							.default(
								listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshDefault,
							)
							.describe(
								'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
							),
					})
					.describe(
						"Use this type to randomly select and assign from existing participants at design time with\nfrequentist A/B experiments.",
					)
					.or(
						zod
							.object({
								participant_type: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMaxOne,
									),
								experiment_id: zod
									.string()
									.or(zod.null())
									.optional()
									.describe(
										"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
									),
								experiment_type: zod.enum(["freq_online"]),
								experiment_name: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMaxOne,
									),
								description: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMaxOne,
									),
								design_url: zod
									.string()
									.url()
									.min(1)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecDesignUrlMaxFour,
									)
									.or(zod.null())
									.optional()
									.describe(
										"Optional URL to a more detailed experiment design doc.",
									),
								start_date: zod.string().datetime({}),
								end_date: zod.string().datetime({}),
								arms: zod
									.array(
										zod
											.object({
												arm_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
													),
												arm_name: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxOne,
													),
												arm_description: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxFour,
													)
													.or(zod.null())
													.optional(),
											})
											.describe("Describes an experiment treatment arm."),
									)
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMinOne,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMaxOne,
									),
								strata: zod
									.array(
										zod
											.object({
												field_name: zod
													.string()
													.regex(
														listOrganizationExperimentsResponseItemsItemDesignSpecStrataItemFieldNameRegExpOne,
													),
											})
											.describe(
												"Describes a variable used for stratification.",
											),
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecStrataMaxOne,
									)
									.describe(
										"Optional participant_type fields to use for stratified assignment.",
									),
								metrics: zod
									.array(
										zod
											.object({
												field_name: zod
													.string()
													.regex(
														listOrganizationExperimentsResponseItemsItemDesignSpecMetricsItemFieldNameRegExpOne,
													),
												metric_pct_change: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
													),
												metric_target: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
													),
											})
											.describe(
												"Defines a request to look up baseline stats for a metric to measure in an experiment.",
											),
									)
									.min(1)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecMetricsMaxOne,
									)
									.describe(
										"Primary and optional secondary metrics to target.",
									),
								filters: zod
									.array(
										zod
											.object({
												field_name: zod
													.string()
													.regex(
														listOrganizationExperimentsResponseItemsItemDesignSpecFiltersItemFieldNameRegExpOne,
													),
												relation: zod
													.enum(["includes", "excludes", "between"])
													.describe(
														"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
													),
												value: zod
													.array(zod.number().or(zod.null()))
													.or(zod.array(zod.number().or(zod.null())))
													.or(zod.array(zod.string().or(zod.null())))
													.or(zod.array(zod.boolean().or(zod.null()))),
											})
											.describe(
												'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value             | logical Result                                    |\n|----------|-------------------|---------------------------------------------------|\n| INCLUDES | [None]            | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]             | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None]       | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]        | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]            | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None]       | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]        | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]        | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", "z", None]  | Match `"a" <= x <= "z"` or `x IS NULL`            |\n| BETWEEN  | [None, "z"]       | Match `x <= "z"`                                  |\n| BETWEEN  | ["a", None]       | Match `x >= "a"`                                  |\n| BETWEEN  | [None, "a", None] | Match `x <= "a"` or `x IS NULL`                   |\n\nString comparisons are case-sensitive.\n\n## Special Handling for BETWEEN support of including NULL\n\nWhen the relation is BETWEEN, we allow for up to 3 values to support the special case of\nincluding null in addition to the values in the between range via an OR IS NULL clause, as\nindicated by a 3rd value of None. Any other 3rd value is invalid.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of DATE, DATETIME and TIMESTAMP values\n\nDATE, DATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
											),
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecFiltersMaxOne,
									)
									.describe(
										"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
									),
								power: zod
									.number()
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecPowerMinOne,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecPowerMaxOne,
									)
									.default(
										listOrganizationExperimentsResponseItemsItemDesignSpecPowerDefaultOne,
									)
									.describe(
										"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
									),
								alpha: zod
									.number()
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecAlphaMinOne,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecAlphaMaxOne,
									)
									.default(
										listOrganizationExperimentsResponseItemsItemDesignSpecAlphaDefaultOne,
									)
									.describe(
										"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
									),
								fstat_thresh: zod
									.number()
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshMinOne,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshMaxOne,
									)
									.default(
										listOrganizationExperimentsResponseItemsItemDesignSpecFstatThreshDefaultOne,
									)
									.describe(
										'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
									),
							})
							.describe(
								"Use this type to randomly assign participants into arms during live experiment execution with\nfrequentist A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
							),
					)
					.or(
						zod
							.object({
								participant_type: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMaxTwo,
									),
								experiment_id: zod
									.string()
									.or(zod.null())
									.optional()
									.describe(
										"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
									),
								experiment_type: zod.enum(["mab_online"]),
								experiment_name: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMaxTwo,
									),
								description: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMaxTwo,
									),
								design_url: zod
									.string()
									.url()
									.min(1)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecDesignUrlMaxSeven,
									)
									.or(zod.null())
									.optional()
									.describe(
										"Optional URL to a more detailed experiment design doc.",
									),
								start_date: zod.string().datetime({}),
								end_date: zod.string().datetime({}),
								arms: zod
									.array(
										zod
											.object({
												arm_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
													),
												arm_name: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxTwo,
													),
												arm_description: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxSeven,
													)
													.or(zod.null())
													.optional(),
												alpha_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial alpha parameter for Beta prior"),
												beta_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial beta parameter for Beta prior"),
												mu_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial mean parameter for Normal prior"),
												sigma_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Initial standard deviation parameter for Normal prior",
													),
												alpha: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Updated alpha parameter for Beta prior"),
												beta: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Updated beta parameter for Beta prior"),
												mu: zod
													.array(zod.number())
													.or(zod.null())
													.optional()
													.describe("Updated mean vector for Normal prior"),
												covariance: zod
													.array(zod.array(zod.number()))
													.or(zod.null())
													.optional()
													.describe(
														"Updated covariance matrix for Normal prior",
													),
											})
											.describe(
												"Describes an experiment arm for bandit experiments.",
											),
									)
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMinTwo,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMaxTwo,
									),
								contexts: zod
									.array(
										zod
											.object({
												context_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"Unique identifier for the context, you should NOT set this when creating a new context.",
													),
												context_name: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextNameMax,
													),
												context_description: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextDescriptionMaxOne,
													)
													.or(zod.null())
													.optional(),
												value_type: zod
													.enum(["binary", "real-valued"])
													.optional()
													.describe("Enum for the type of context."),
											})
											.describe(
												"Pydantic model for context of the experiment.",
											),
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecContextsMaxOne,
									)
									.or(zod.null())
									.optional()
									.describe(
										"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
									),
								prior_type: zod
									.enum(["beta", "normal"])
									.optional()
									.describe("Enum for the prior distribution of the arm."),
								reward_type: zod
									.enum(["binary", "real-valued"])
									.optional()
									.describe(
										"Enum for the likelihood distribution of the reward.",
									),
							})
							.describe(
								"Use this type to randomly assign participants into arms during live experiment execution with MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
							),
					)
					.or(
						zod
							.object({
								participant_type: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMaxThree,
									),
								experiment_id: zod
									.string()
									.or(zod.null())
									.optional()
									.describe(
										"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
									),
								experiment_type: zod.enum(["cmab_online"]),
								experiment_name: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMaxThree,
									),
								description: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMaxThree,
									),
								design_url: zod
									.string()
									.url()
									.min(1)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecDesignUrlMaxOnezero,
									)
									.or(zod.null())
									.optional()
									.describe(
										"Optional URL to a more detailed experiment design doc.",
									),
								start_date: zod.string().datetime({}),
								end_date: zod.string().datetime({}),
								arms: zod
									.array(
										zod
											.object({
												arm_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
													),
												arm_name: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxThree,
													),
												arm_description: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxOnezero,
													)
													.or(zod.null())
													.optional(),
												alpha_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial alpha parameter for Beta prior"),
												beta_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial beta parameter for Beta prior"),
												mu_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial mean parameter for Normal prior"),
												sigma_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Initial standard deviation parameter for Normal prior",
													),
												alpha: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Updated alpha parameter for Beta prior"),
												beta: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Updated beta parameter for Beta prior"),
												mu: zod
													.array(zod.number())
													.or(zod.null())
													.optional()
													.describe("Updated mean vector for Normal prior"),
												covariance: zod
													.array(zod.array(zod.number()))
													.or(zod.null())
													.optional()
													.describe(
														"Updated covariance matrix for Normal prior",
													),
											})
											.describe(
												"Describes an experiment arm for bandit experiments.",
											),
									)
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMinThree,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMaxThree,
									),
								contexts: zod
									.array(
										zod
											.object({
												context_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"Unique identifier for the context, you should NOT set this when creating a new context.",
													),
												context_name: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextNameMaxOne,
													),
												context_description: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextDescriptionMaxFour,
													)
													.or(zod.null())
													.optional(),
												value_type: zod
													.enum(["binary", "real-valued"])
													.optional()
													.describe("Enum for the type of context."),
											})
											.describe(
												"Pydantic model for context of the experiment.",
											),
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecContextsMaxFour,
									)
									.or(zod.null())
									.optional()
									.describe(
										"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
									),
								prior_type: zod
									.enum(["beta", "normal"])
									.optional()
									.describe("Enum for the prior distribution of the arm."),
								reward_type: zod
									.enum(["binary", "real-valued"])
									.optional()
									.describe(
										"Enum for the likelihood distribution of the reward.",
									),
							})
							.describe(
								"Use this type to randomly assign participants into arms during live experiment execution with\ncontextual MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
							),
					)
					.or(
						zod
							.object({
								participant_type: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecParticipantTypeMaxFour,
									),
								experiment_id: zod
									.string()
									.or(zod.null())
									.optional()
									.describe(
										"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
									),
								experiment_type: zod.enum(["bayes_ab_online"]),
								experiment_name: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecExperimentNameMaxFour,
									),
								description: zod
									.string()
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecDescriptionMaxFour,
									),
								design_url: zod
									.string()
									.url()
									.min(1)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecDesignUrlMaxOnethree,
									)
									.or(zod.null())
									.optional()
									.describe(
										"Optional URL to a more detailed experiment design doc.",
									),
								start_date: zod.string().datetime({}),
								end_date: zod.string().datetime({}),
								arms: zod
									.array(
										zod
											.object({
												arm_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
													),
												arm_name: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmNameMaxFour,
													),
												arm_description: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecArmsItemArmDescriptionMaxOnethree,
													)
													.or(zod.null())
													.optional(),
												alpha_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial alpha parameter for Beta prior"),
												beta_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial beta parameter for Beta prior"),
												mu_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Initial mean parameter for Normal prior"),
												sigma_init: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Initial standard deviation parameter for Normal prior",
													),
												alpha: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Updated alpha parameter for Beta prior"),
												beta: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Updated beta parameter for Beta prior"),
												mu: zod
													.array(zod.number())
													.or(zod.null())
													.optional()
													.describe("Updated mean vector for Normal prior"),
												covariance: zod
													.array(zod.array(zod.number()))
													.or(zod.null())
													.optional()
													.describe(
														"Updated covariance matrix for Normal prior",
													),
											})
											.describe(
												"Describes an experiment arm for bandit experiments.",
											),
									)
									.min(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMinFour,
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecArmsMaxFour,
									),
								contexts: zod
									.array(
										zod
											.object({
												context_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"Unique identifier for the context, you should NOT set this when creating a new context.",
													),
												context_name: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextNameMaxTwo,
													),
												context_description: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemDesignSpecContextsItemContextDescriptionMaxSeven,
													)
													.or(zod.null())
													.optional(),
												value_type: zod
													.enum(["binary", "real-valued"])
													.optional()
													.describe("Enum for the type of context."),
											})
											.describe(
												"Pydantic model for context of the experiment.",
											),
									)
									.max(
										listOrganizationExperimentsResponseItemsItemDesignSpecContextsMaxSeven,
									)
									.or(zod.null())
									.optional()
									.describe(
										"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
									),
								prior_type: zod
									.enum(["beta", "normal"])
									.optional()
									.describe("Enum for the prior distribution of the arm."),
								reward_type: zod
									.enum(["binary", "real-valued"])
									.optional()
									.describe(
										"Enum for the likelihood distribution of the reward.",
									),
							})
							.describe(
								"Use this type to randomly assign participants into arms during live experiment execution with\nBayesian A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
							),
					)
					.describe("The type of assignment and experiment design."),
				power_analyses: zod
					.object({
						analyses: zod
							.array(
								zod
									.object({
										metric_spec: zod
											.object({
												field_name: zod
													.string()
													.regex(
														listOrganizationExperimentsResponseItemsItemPowerAnalysesAnalysesItemMetricSpecFieldNameRegExp,
													),
												metric_pct_change: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Percent change target relative to the metric_baseline.",
													),
												metric_target: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Absolute target value = metric_baseline*(1 + metric_pct_change)",
													),
												metric_type: zod
													.enum(["binary", "numeric"])
													.describe("Classifies metrics by their value type.")
													.or(zod.null())
													.optional()
													.describe("Inferred from dwh type."),
												metric_baseline: zod
													.number()
													.or(zod.null())
													.optional()
													.describe("Mean of the tracked metric."),
												metric_stddev: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"Standard deviation is set only for metric_type.NUMERIC metrics. Must be set for numeric metrics when available_n > 0.",
													),
												available_nonnull_n: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"The number of participants meeting the filtering criteria with a *non-null* value for this metric.",
													),
												available_n: zod
													.number()
													.or(zod.null())
													.optional()
													.describe(
														"The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n.",
													),
											})
											.describe(
												"Defines a metric to measure in an experiment with its baseline stats.",
											),
										target_n: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Minimum sample size needed to meet the design specs.",
											),
										sufficient_n: zod
											.boolean()
											.or(zod.null())
											.optional()
											.describe(
												"Whether or not there are enough available units to sample from to meet target_n.",
											),
										target_possible: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.",
											),
										pct_change_possible: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.",
											),
										msg: zod
											.object({
												type: zod
													.enum([
														"sufficient",
														"insufficient",
														"no baseline",
														"no available n",
														"zero effect size",
														"zero variation",
													])
													.describe(
														"Classifies metric power analysis results.",
													),
												msg: zod
													.string()
													.describe(
														"Main power analysis result stated in human-friendly English.",
													),
												source_msg: zod
													.string()
													.describe(
														"Power analysis result formatted as a template string with curly-braced {} named placeholders. Use with the dictionary of values to support localization of messages.",
													),
												values: zod
													.record(zod.string(), zod.number().or(zod.number()))
													.or(zod.null())
													.optional(),
											})
											.describe(
												"Describes interpretation of power analysis results.",
											)
											.or(zod.null())
											.optional()
											.describe(
												"Human friendly message about the above results.",
											),
									})
									.describe("Describes analysis results of a single metric."),
							)
							.max(
								listOrganizationExperimentsResponseItemsItemPowerAnalysesAnalysesMax,
							),
					})
					.or(zod.null()),
				assign_summary: zod
					.object({
						balance_check: zod
							.object({
								f_statistic: zod
									.number()
									.describe(
										"F-statistic testing the overall significance of the model predicting treatment assignment.",
									),
								numerator_df: zod
									.number()
									.describe(
										"The numerator degrees of freedom for the f-statistic related to number of dependent variables.",
									),
								denominator_df: zod
									.number()
									.describe(
										"Denominator degrees of freedom related to the number of observations.",
									),
								p_value: zod
									.number()
									.describe(
										"Probability of observing these data if strata do not predict treatment assignment, i.e. our randomization is balanced.",
									),
								balance_ok: zod
									.boolean()
									.describe(
										"Whether the p-value for our observed f_statistic is greater than the f-stat threshold specified in our design specification. (See DesignSpec.fstat_thresh)",
									),
							})
							.describe(
								"Describes balance test results for treatment assignment.",
							)
							.or(zod.null())
							.optional()
							.describe(
								"Balance test results if available. 'online' experiments do not have balance checks.",
							),
						sample_size: zod
							.number()
							.describe("The number of participants across all arms in total."),
						arm_sizes: zod
							.array(
								zod
									.object({
										arm: zod
											.object({
												arm_id: zod
													.string()
													.or(zod.null())
													.optional()
													.describe(
														"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
													),
												arm_name: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemAssignSummaryArmSizesItemArmArmNameMax,
													),
												arm_description: zod
													.string()
													.max(
														listOrganizationExperimentsResponseItemsItemAssignSummaryArmSizesItemArmArmDescriptionMaxOne,
													)
													.or(zod.null())
													.optional(),
											})
											.describe("Describes an experiment treatment arm."),
										size: zod.number().optional(),
									})
									.describe(
										"Describes the number of participants assigned to each arm.",
									),
							)
							.max(
								listOrganizationExperimentsResponseItemsItemAssignSummaryArmSizesMaxOne,
							)
							.or(zod.null())
							.optional()
							.describe("For each arm, the number of participants assigned."),
					})
					.describe("Key pieces of an AssignResponse without the assignments.")
					.or(zod.null()),
				webhooks: zod
					.array(zod.string())
					.default(listOrganizationExperimentsResponseItemsItemWebhooksDefault)
					.describe(
						"List of webhook IDs associated with this experiment. These webhooks are triggered when the experiment is committed.",
					),
			})
			.describe("Representation of our stored Experiment information."),
	),
});

/**
 * Returns the experiment with the specified ID.
 * @summary Get Experiment For Ui
 */
export const getExperimentForUiParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const getExperimentForUiResponseDesignSpecParticipantTypeMax = 100;
export const getExperimentForUiResponseDesignSpecExperimentNameMax = 100;
export const getExperimentForUiResponseDesignSpecDescriptionMax = 2000;
export const getExperimentForUiResponseDesignSpecDesignUrlMaxOne = 500;
export const getExperimentForUiResponseDesignSpecArmsItemArmNameMax = 100;
export const getExperimentForUiResponseDesignSpecArmsItemArmDescriptionMaxOne = 2000;
export const getExperimentForUiResponseDesignSpecArmsMin = 2;

export const getExperimentForUiResponseDesignSpecArmsMax = 10;
export const getExperimentForUiResponseDesignSpecStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentForUiResponseDesignSpecStrataMax = 150;
export const getExperimentForUiResponseDesignSpecMetricsItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentForUiResponseDesignSpecMetricsMax = 150;
export const getExperimentForUiResponseDesignSpecFiltersItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentForUiResponseDesignSpecFiltersMax = 20;
export const getExperimentForUiResponseDesignSpecPowerDefault = 0.8;
export const getExperimentForUiResponseDesignSpecPowerMin = 0;

export const getExperimentForUiResponseDesignSpecPowerMax = 1;
export const getExperimentForUiResponseDesignSpecAlphaDefault = 0.05;
export const getExperimentForUiResponseDesignSpecAlphaMin = 0;

export const getExperimentForUiResponseDesignSpecAlphaMax = 1;
export const getExperimentForUiResponseDesignSpecFstatThreshDefault = 0.6;
export const getExperimentForUiResponseDesignSpecFstatThreshMin = 0;

export const getExperimentForUiResponseDesignSpecFstatThreshMax = 1;
export const getExperimentForUiResponseDesignSpecParticipantTypeMaxOne = 100;
export const getExperimentForUiResponseDesignSpecExperimentNameMaxOne = 100;
export const getExperimentForUiResponseDesignSpecDescriptionMaxOne = 2000;
export const getExperimentForUiResponseDesignSpecDesignUrlMaxFour = 500;
export const getExperimentForUiResponseDesignSpecArmsItemArmNameMaxOne = 100;
export const getExperimentForUiResponseDesignSpecArmsItemArmDescriptionMaxFour = 2000;
export const getExperimentForUiResponseDesignSpecArmsMinOne = 2;

export const getExperimentForUiResponseDesignSpecArmsMaxOne = 10;
export const getExperimentForUiResponseDesignSpecStrataItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentForUiResponseDesignSpecStrataMaxOne = 150;
export const getExperimentForUiResponseDesignSpecMetricsItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentForUiResponseDesignSpecMetricsMaxOne = 150;
export const getExperimentForUiResponseDesignSpecFiltersItemFieldNameRegExpOne =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentForUiResponseDesignSpecFiltersMaxOne = 20;
export const getExperimentForUiResponseDesignSpecPowerDefaultOne = 0.8;
export const getExperimentForUiResponseDesignSpecPowerMinOne = 0;

export const getExperimentForUiResponseDesignSpecPowerMaxOne = 1;
export const getExperimentForUiResponseDesignSpecAlphaDefaultOne = 0.05;
export const getExperimentForUiResponseDesignSpecAlphaMinOne = 0;

export const getExperimentForUiResponseDesignSpecAlphaMaxOne = 1;
export const getExperimentForUiResponseDesignSpecFstatThreshDefaultOne = 0.6;
export const getExperimentForUiResponseDesignSpecFstatThreshMinOne = 0;

export const getExperimentForUiResponseDesignSpecFstatThreshMaxOne = 1;
export const getExperimentForUiResponseDesignSpecParticipantTypeMaxTwo = 100;
export const getExperimentForUiResponseDesignSpecExperimentNameMaxTwo = 100;
export const getExperimentForUiResponseDesignSpecDescriptionMaxTwo = 2000;
export const getExperimentForUiResponseDesignSpecDesignUrlMaxSeven = 500;
export const getExperimentForUiResponseDesignSpecArmsItemArmNameMaxTwo = 100;
export const getExperimentForUiResponseDesignSpecArmsItemArmDescriptionMaxSeven = 2000;
export const getExperimentForUiResponseDesignSpecArmsMinTwo = 2;

export const getExperimentForUiResponseDesignSpecArmsMaxTwo = 10;
export const getExperimentForUiResponseDesignSpecContextsItemContextNameMax = 100;
export const getExperimentForUiResponseDesignSpecContextsItemContextDescriptionMaxOne = 2000;
export const getExperimentForUiResponseDesignSpecContextsMaxOne = 150;
export const getExperimentForUiResponseDesignSpecParticipantTypeMaxThree = 100;
export const getExperimentForUiResponseDesignSpecExperimentNameMaxThree = 100;
export const getExperimentForUiResponseDesignSpecDescriptionMaxThree = 2000;
export const getExperimentForUiResponseDesignSpecDesignUrlMaxOnezero = 500;
export const getExperimentForUiResponseDesignSpecArmsItemArmNameMaxThree = 100;
export const getExperimentForUiResponseDesignSpecArmsItemArmDescriptionMaxOnezero = 2000;
export const getExperimentForUiResponseDesignSpecArmsMinThree = 2;

export const getExperimentForUiResponseDesignSpecArmsMaxThree = 10;
export const getExperimentForUiResponseDesignSpecContextsItemContextNameMaxOne = 100;
export const getExperimentForUiResponseDesignSpecContextsItemContextDescriptionMaxFour = 2000;
export const getExperimentForUiResponseDesignSpecContextsMaxFour = 150;
export const getExperimentForUiResponseDesignSpecParticipantTypeMaxFour = 100;
export const getExperimentForUiResponseDesignSpecExperimentNameMaxFour = 100;
export const getExperimentForUiResponseDesignSpecDescriptionMaxFour = 2000;
export const getExperimentForUiResponseDesignSpecDesignUrlMaxOnethree = 500;
export const getExperimentForUiResponseDesignSpecArmsItemArmNameMaxFour = 100;
export const getExperimentForUiResponseDesignSpecArmsItemArmDescriptionMaxOnethree = 2000;
export const getExperimentForUiResponseDesignSpecArmsMinFour = 2;

export const getExperimentForUiResponseDesignSpecArmsMaxFour = 10;
export const getExperimentForUiResponseDesignSpecContextsItemContextNameMaxTwo = 100;
export const getExperimentForUiResponseDesignSpecContextsItemContextDescriptionMaxSeven = 2000;
export const getExperimentForUiResponseDesignSpecContextsMaxSeven = 150;
export const getExperimentForUiResponsePowerAnalysesAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentForUiResponsePowerAnalysesAnalysesMax = 150;
export const getExperimentForUiResponseAssignSummaryArmSizesItemArmArmNameMax = 100;
export const getExperimentForUiResponseAssignSummaryArmSizesItemArmArmDescriptionMaxOne = 2000;
export const getExperimentForUiResponseAssignSummaryArmSizesItemSizeDefault = 0;
export const getExperimentForUiResponseAssignSummaryArmSizesMaxOne = 10;
export const getExperimentForUiResponseWebhooksDefault = [];

export const getExperimentForUiResponse = zod
	.object({
		experiment_id: zod
			.string()
			.describe("Server-generated ID of the experiment."),
		datasource_id: zod.string(),
		state: zod
			.enum(["designing", "assigned", "abandoned", "committed", "aborted"])
			.describe(
				"Experiment lifecycle states.\n\nnote: [starting state], [[terminal state]]\n[DESIGNING]->[ASSIGNED]->{[[ABANDONED]], COMMITTED}->[[ABORTED]]",
			),
		stopped_assignments_at: zod
			.string()
			.datetime({})
			.or(zod.null())
			.describe(
				"The date and time assignments were stopped. Null if assignments are still allowed to be made.",
			),
		stopped_assignments_reason: zod
			.enum(["preassigned", "end_date", "manual", "target_n"])
			.describe("The reason assignments were stopped.")
			.or(zod.null())
			.describe(
				"The reason assignments were stopped. Null if assignments are still allowed to be made.",
			),
		design_spec: zod
			.object({
				participant_type: zod
					.string()
					.max(getExperimentForUiResponseDesignSpecParticipantTypeMax),
				experiment_id: zod
					.string()
					.or(zod.null())
					.optional()
					.describe(
						"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
					),
				experiment_type: zod.enum(["freq_preassigned"]),
				experiment_name: zod
					.string()
					.max(getExperimentForUiResponseDesignSpecExperimentNameMax),
				description: zod
					.string()
					.max(getExperimentForUiResponseDesignSpecDescriptionMax),
				design_url: zod
					.string()
					.url()
					.min(1)
					.max(getExperimentForUiResponseDesignSpecDesignUrlMaxOne)
					.or(zod.null())
					.optional()
					.describe("Optional URL to a more detailed experiment design doc."),
				start_date: zod.string().datetime({}),
				end_date: zod.string().datetime({}),
				arms: zod
					.array(
						zod
							.object({
								arm_id: zod
									.string()
									.or(zod.null())
									.optional()
									.describe(
										"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
									),
								arm_name: zod
									.string()
									.max(getExperimentForUiResponseDesignSpecArmsItemArmNameMax),
								arm_description: zod
									.string()
									.max(
										getExperimentForUiResponseDesignSpecArmsItemArmDescriptionMaxOne,
									)
									.or(zod.null())
									.optional(),
							})
							.describe("Describes an experiment treatment arm."),
					)
					.min(getExperimentForUiResponseDesignSpecArmsMin)
					.max(getExperimentForUiResponseDesignSpecArmsMax),
				strata: zod
					.array(
						zod
							.object({
								field_name: zod
									.string()
									.regex(
										getExperimentForUiResponseDesignSpecStrataItemFieldNameRegExp,
									),
							})
							.describe("Describes a variable used for stratification."),
					)
					.max(getExperimentForUiResponseDesignSpecStrataMax)
					.describe(
						"Optional participant_type fields to use for stratified assignment.",
					),
				metrics: zod
					.array(
						zod
							.object({
								field_name: zod
									.string()
									.regex(
										getExperimentForUiResponseDesignSpecMetricsItemFieldNameRegExp,
									),
								metric_pct_change: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
									),
								metric_target: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
									),
							})
							.describe(
								"Defines a request to look up baseline stats for a metric to measure in an experiment.",
							),
					)
					.min(1)
					.max(getExperimentForUiResponseDesignSpecMetricsMax)
					.describe("Primary and optional secondary metrics to target."),
				filters: zod
					.array(
						zod
							.object({
								field_name: zod
									.string()
									.regex(
										getExperimentForUiResponseDesignSpecFiltersItemFieldNameRegExp,
									),
								relation: zod
									.enum(["includes", "excludes", "between"])
									.describe(
										"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
									),
								value: zod
									.array(zod.number().or(zod.null()))
									.or(zod.array(zod.number().or(zod.null())))
									.or(zod.array(zod.string().or(zod.null())))
									.or(zod.array(zod.boolean().or(zod.null()))),
							})
							.describe(
								'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value             | logical Result                                    |\n|----------|-------------------|---------------------------------------------------|\n| INCLUDES | [None]            | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]             | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None]       | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]        | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]            | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None]       | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]        | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]        | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", "z", None]  | Match `"a" <= x <= "z"` or `x IS NULL`            |\n| BETWEEN  | [None, "z"]       | Match `x <= "z"`                                  |\n| BETWEEN  | ["a", None]       | Match `x >= "a"`                                  |\n| BETWEEN  | [None, "a", None] | Match `x <= "a"` or `x IS NULL`                   |\n\nString comparisons are case-sensitive.\n\n## Special Handling for BETWEEN support of including NULL\n\nWhen the relation is BETWEEN, we allow for up to 3 values to support the special case of\nincluding null in addition to the values in the between range via an OR IS NULL clause, as\nindicated by a 3rd value of None. Any other 3rd value is invalid.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of DATE, DATETIME and TIMESTAMP values\n\nDATE, DATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
							),
					)
					.max(getExperimentForUiResponseDesignSpecFiltersMax)
					.describe(
						"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
					),
				power: zod
					.number()
					.min(getExperimentForUiResponseDesignSpecPowerMin)
					.max(getExperimentForUiResponseDesignSpecPowerMax)
					.default(getExperimentForUiResponseDesignSpecPowerDefault)
					.describe(
						"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
					),
				alpha: zod
					.number()
					.min(getExperimentForUiResponseDesignSpecAlphaMin)
					.max(getExperimentForUiResponseDesignSpecAlphaMax)
					.default(getExperimentForUiResponseDesignSpecAlphaDefault)
					.describe(
						"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
					),
				fstat_thresh: zod
					.number()
					.min(getExperimentForUiResponseDesignSpecFstatThreshMin)
					.max(getExperimentForUiResponseDesignSpecFstatThreshMax)
					.default(getExperimentForUiResponseDesignSpecFstatThreshDefault)
					.describe(
						'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
					),
			})
			.describe(
				"Use this type to randomly select and assign from existing participants at design time with\nfrequentist A/B experiments.",
			)
			.or(
				zod
					.object({
						participant_type: zod
							.string()
							.max(getExperimentForUiResponseDesignSpecParticipantTypeMaxOne),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
							),
						experiment_type: zod.enum(["freq_online"]),
						experiment_name: zod
							.string()
							.max(getExperimentForUiResponseDesignSpecExperimentNameMaxOne),
						description: zod
							.string()
							.max(getExperimentForUiResponseDesignSpecDescriptionMaxOne),
						design_url: zod
							.string()
							.url()
							.min(1)
							.max(getExperimentForUiResponseDesignSpecDesignUrlMaxFour)
							.or(zod.null())
							.optional()
							.describe(
								"Optional URL to a more detailed experiment design doc.",
							),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												getExperimentForUiResponseDesignSpecArmsItemArmNameMaxOne,
											),
										arm_description: zod
											.string()
											.max(
												getExperimentForUiResponseDesignSpecArmsItemArmDescriptionMaxFour,
											)
											.or(zod.null())
											.optional(),
									})
									.describe("Describes an experiment treatment arm."),
							)
							.min(getExperimentForUiResponseDesignSpecArmsMinOne)
							.max(getExperimentForUiResponseDesignSpecArmsMaxOne),
						strata: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												getExperimentForUiResponseDesignSpecStrataItemFieldNameRegExpOne,
											),
									})
									.describe("Describes a variable used for stratification."),
							)
							.max(getExperimentForUiResponseDesignSpecStrataMaxOne)
							.describe(
								"Optional participant_type fields to use for stratified assignment.",
							),
						metrics: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												getExperimentForUiResponseDesignSpecMetricsItemFieldNameRegExpOne,
											),
										metric_pct_change: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
											),
										metric_target: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
											),
									})
									.describe(
										"Defines a request to look up baseline stats for a metric to measure in an experiment.",
									),
							)
							.min(1)
							.max(getExperimentForUiResponseDesignSpecMetricsMaxOne)
							.describe("Primary and optional secondary metrics to target."),
						filters: zod
							.array(
								zod
									.object({
										field_name: zod
											.string()
											.regex(
												getExperimentForUiResponseDesignSpecFiltersItemFieldNameRegExpOne,
											),
										relation: zod
											.enum(["includes", "excludes", "between"])
											.describe(
												"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
											),
										value: zod
											.array(zod.number().or(zod.null()))
											.or(zod.array(zod.number().or(zod.null())))
											.or(zod.array(zod.string().or(zod.null())))
											.or(zod.array(zod.boolean().or(zod.null()))),
									})
									.describe(
										'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value             | logical Result                                    |\n|----------|-------------------|---------------------------------------------------|\n| INCLUDES | [None]            | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]             | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None]       | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]        | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]            | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None]       | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]        | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]        | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", "z", None]  | Match `"a" <= x <= "z"` or `x IS NULL`            |\n| BETWEEN  | [None, "z"]       | Match `x <= "z"`                                  |\n| BETWEEN  | ["a", None]       | Match `x >= "a"`                                  |\n| BETWEEN  | [None, "a", None] | Match `x <= "a"` or `x IS NULL`                   |\n\nString comparisons are case-sensitive.\n\n## Special Handling for BETWEEN support of including NULL\n\nWhen the relation is BETWEEN, we allow for up to 3 values to support the special case of\nincluding null in addition to the values in the between range via an OR IS NULL clause, as\nindicated by a 3rd value of None. Any other 3rd value is invalid.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of DATE, DATETIME and TIMESTAMP values\n\nDATE, DATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
									),
							)
							.max(getExperimentForUiResponseDesignSpecFiltersMaxOne)
							.describe(
								"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
							),
						power: zod
							.number()
							.min(getExperimentForUiResponseDesignSpecPowerMinOne)
							.max(getExperimentForUiResponseDesignSpecPowerMaxOne)
							.default(getExperimentForUiResponseDesignSpecPowerDefaultOne)
							.describe(
								"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
							),
						alpha: zod
							.number()
							.min(getExperimentForUiResponseDesignSpecAlphaMinOne)
							.max(getExperimentForUiResponseDesignSpecAlphaMaxOne)
							.default(getExperimentForUiResponseDesignSpecAlphaDefaultOne)
							.describe(
								"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
							),
						fstat_thresh: zod
							.number()
							.min(getExperimentForUiResponseDesignSpecFstatThreshMinOne)
							.max(getExperimentForUiResponseDesignSpecFstatThreshMaxOne)
							.default(
								getExperimentForUiResponseDesignSpecFstatThreshDefaultOne,
							)
							.describe(
								'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
							),
					})
					.describe(
						"Use this type to randomly assign participants into arms during live experiment execution with\nfrequentist A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
					),
			)
			.or(
				zod
					.object({
						participant_type: zod
							.string()
							.max(getExperimentForUiResponseDesignSpecParticipantTypeMaxTwo),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
							),
						experiment_type: zod.enum(["mab_online"]),
						experiment_name: zod
							.string()
							.max(getExperimentForUiResponseDesignSpecExperimentNameMaxTwo),
						description: zod
							.string()
							.max(getExperimentForUiResponseDesignSpecDescriptionMaxTwo),
						design_url: zod
							.string()
							.url()
							.min(1)
							.max(getExperimentForUiResponseDesignSpecDesignUrlMaxSeven)
							.or(zod.null())
							.optional()
							.describe(
								"Optional URL to a more detailed experiment design doc.",
							),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												getExperimentForUiResponseDesignSpecArmsItemArmNameMaxTwo,
											),
										arm_description: zod
											.string()
											.max(
												getExperimentForUiResponseDesignSpecArmsItemArmDescriptionMaxSeven,
											)
											.or(zod.null())
											.optional(),
										alpha_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial alpha parameter for Beta prior"),
										beta_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial beta parameter for Beta prior"),
										mu_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial mean parameter for Normal prior"),
										sigma_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Initial standard deviation parameter for Normal prior",
											),
										alpha: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated alpha parameter for Beta prior"),
										beta: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated beta parameter for Beta prior"),
										mu: zod
											.array(zod.number())
											.or(zod.null())
											.optional()
											.describe("Updated mean vector for Normal prior"),
										covariance: zod
											.array(zod.array(zod.number()))
											.or(zod.null())
											.optional()
											.describe("Updated covariance matrix for Normal prior"),
									})
									.describe(
										"Describes an experiment arm for bandit experiments.",
									),
							)
							.min(getExperimentForUiResponseDesignSpecArmsMinTwo)
							.max(getExperimentForUiResponseDesignSpecArmsMaxTwo),
						contexts: zod
							.array(
								zod
									.object({
										context_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"Unique identifier for the context, you should NOT set this when creating a new context.",
											),
										context_name: zod
											.string()
											.max(
												getExperimentForUiResponseDesignSpecContextsItemContextNameMax,
											),
										context_description: zod
											.string()
											.max(
												getExperimentForUiResponseDesignSpecContextsItemContextDescriptionMaxOne,
											)
											.or(zod.null())
											.optional(),
										value_type: zod
											.enum(["binary", "real-valued"])
											.optional()
											.describe("Enum for the type of context."),
									})
									.describe("Pydantic model for context of the experiment."),
							)
							.max(getExperimentForUiResponseDesignSpecContextsMaxOne)
							.or(zod.null())
							.optional()
							.describe(
								"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
							),
						prior_type: zod
							.enum(["beta", "normal"])
							.optional()
							.describe("Enum for the prior distribution of the arm."),
						reward_type: zod
							.enum(["binary", "real-valued"])
							.optional()
							.describe("Enum for the likelihood distribution of the reward."),
					})
					.describe(
						"Use this type to randomly assign participants into arms during live experiment execution with MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
					),
			)
			.or(
				zod
					.object({
						participant_type: zod
							.string()
							.max(getExperimentForUiResponseDesignSpecParticipantTypeMaxThree),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
							),
						experiment_type: zod.enum(["cmab_online"]),
						experiment_name: zod
							.string()
							.max(getExperimentForUiResponseDesignSpecExperimentNameMaxThree),
						description: zod
							.string()
							.max(getExperimentForUiResponseDesignSpecDescriptionMaxThree),
						design_url: zod
							.string()
							.url()
							.min(1)
							.max(getExperimentForUiResponseDesignSpecDesignUrlMaxOnezero)
							.or(zod.null())
							.optional()
							.describe(
								"Optional URL to a more detailed experiment design doc.",
							),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												getExperimentForUiResponseDesignSpecArmsItemArmNameMaxThree,
											),
										arm_description: zod
											.string()
											.max(
												getExperimentForUiResponseDesignSpecArmsItemArmDescriptionMaxOnezero,
											)
											.or(zod.null())
											.optional(),
										alpha_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial alpha parameter for Beta prior"),
										beta_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial beta parameter for Beta prior"),
										mu_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial mean parameter for Normal prior"),
										sigma_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Initial standard deviation parameter for Normal prior",
											),
										alpha: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated alpha parameter for Beta prior"),
										beta: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated beta parameter for Beta prior"),
										mu: zod
											.array(zod.number())
											.or(zod.null())
											.optional()
											.describe("Updated mean vector for Normal prior"),
										covariance: zod
											.array(zod.array(zod.number()))
											.or(zod.null())
											.optional()
											.describe("Updated covariance matrix for Normal prior"),
									})
									.describe(
										"Describes an experiment arm for bandit experiments.",
									),
							)
							.min(getExperimentForUiResponseDesignSpecArmsMinThree)
							.max(getExperimentForUiResponseDesignSpecArmsMaxThree),
						contexts: zod
							.array(
								zod
									.object({
										context_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"Unique identifier for the context, you should NOT set this when creating a new context.",
											),
										context_name: zod
											.string()
											.max(
												getExperimentForUiResponseDesignSpecContextsItemContextNameMaxOne,
											),
										context_description: zod
											.string()
											.max(
												getExperimentForUiResponseDesignSpecContextsItemContextDescriptionMaxFour,
											)
											.or(zod.null())
											.optional(),
										value_type: zod
											.enum(["binary", "real-valued"])
											.optional()
											.describe("Enum for the type of context."),
									})
									.describe("Pydantic model for context of the experiment."),
							)
							.max(getExperimentForUiResponseDesignSpecContextsMaxFour)
							.or(zod.null())
							.optional()
							.describe(
								"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
							),
						prior_type: zod
							.enum(["beta", "normal"])
							.optional()
							.describe("Enum for the prior distribution of the arm."),
						reward_type: zod
							.enum(["binary", "real-valued"])
							.optional()
							.describe("Enum for the likelihood distribution of the reward."),
					})
					.describe(
						"Use this type to randomly assign participants into arms during live experiment execution with\ncontextual MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
					),
			)
			.or(
				zod
					.object({
						participant_type: zod
							.string()
							.max(getExperimentForUiResponseDesignSpecParticipantTypeMaxFour),
						experiment_id: zod
							.string()
							.or(zod.null())
							.optional()
							.describe(
								"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
							),
						experiment_type: zod.enum(["bayes_ab_online"]),
						experiment_name: zod
							.string()
							.max(getExperimentForUiResponseDesignSpecExperimentNameMaxFour),
						description: zod
							.string()
							.max(getExperimentForUiResponseDesignSpecDescriptionMaxFour),
						design_url: zod
							.string()
							.url()
							.min(1)
							.max(getExperimentForUiResponseDesignSpecDesignUrlMaxOnethree)
							.or(zod.null())
							.optional()
							.describe(
								"Optional URL to a more detailed experiment design doc.",
							),
						start_date: zod.string().datetime({}),
						end_date: zod.string().datetime({}),
						arms: zod
							.array(
								zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												getExperimentForUiResponseDesignSpecArmsItemArmNameMaxFour,
											),
										arm_description: zod
											.string()
											.max(
												getExperimentForUiResponseDesignSpecArmsItemArmDescriptionMaxOnethree,
											)
											.or(zod.null())
											.optional(),
										alpha_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial alpha parameter for Beta prior"),
										beta_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial beta parameter for Beta prior"),
										mu_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Initial mean parameter for Normal prior"),
										sigma_init: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Initial standard deviation parameter for Normal prior",
											),
										alpha: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated alpha parameter for Beta prior"),
										beta: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Updated beta parameter for Beta prior"),
										mu: zod
											.array(zod.number())
											.or(zod.null())
											.optional()
											.describe("Updated mean vector for Normal prior"),
										covariance: zod
											.array(zod.array(zod.number()))
											.or(zod.null())
											.optional()
											.describe("Updated covariance matrix for Normal prior"),
									})
									.describe(
										"Describes an experiment arm for bandit experiments.",
									),
							)
							.min(getExperimentForUiResponseDesignSpecArmsMinFour)
							.max(getExperimentForUiResponseDesignSpecArmsMaxFour),
						contexts: zod
							.array(
								zod
									.object({
										context_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"Unique identifier for the context, you should NOT set this when creating a new context.",
											),
										context_name: zod
											.string()
											.max(
												getExperimentForUiResponseDesignSpecContextsItemContextNameMaxTwo,
											),
										context_description: zod
											.string()
											.max(
												getExperimentForUiResponseDesignSpecContextsItemContextDescriptionMaxSeven,
											)
											.or(zod.null())
											.optional(),
										value_type: zod
											.enum(["binary", "real-valued"])
											.optional()
											.describe("Enum for the type of context."),
									})
									.describe("Pydantic model for context of the experiment."),
							)
							.max(getExperimentForUiResponseDesignSpecContextsMaxSeven)
							.or(zod.null())
							.optional()
							.describe(
								"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
							),
						prior_type: zod
							.enum(["beta", "normal"])
							.optional()
							.describe("Enum for the prior distribution of the arm."),
						reward_type: zod
							.enum(["binary", "real-valued"])
							.optional()
							.describe("Enum for the likelihood distribution of the reward."),
					})
					.describe(
						"Use this type to randomly assign participants into arms during live experiment execution with\nBayesian A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
					),
			)
			.describe("The type of assignment and experiment design."),
		power_analyses: zod
			.object({
				analyses: zod
					.array(
						zod
							.object({
								metric_spec: zod
									.object({
										field_name: zod
											.string()
											.regex(
												getExperimentForUiResponsePowerAnalysesAnalysesItemMetricSpecFieldNameRegExp,
											),
										metric_pct_change: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Percent change target relative to the metric_baseline.",
											),
										metric_target: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Absolute target value = metric_baseline*(1 + metric_pct_change)",
											),
										metric_type: zod
											.enum(["binary", "numeric"])
											.describe("Classifies metrics by their value type.")
											.or(zod.null())
											.optional()
											.describe("Inferred from dwh type."),
										metric_baseline: zod
											.number()
											.or(zod.null())
											.optional()
											.describe("Mean of the tracked metric."),
										metric_stddev: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"Standard deviation is set only for metric_type.NUMERIC metrics. Must be set for numeric metrics when available_n > 0.",
											),
										available_nonnull_n: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"The number of participants meeting the filtering criteria with a *non-null* value for this metric.",
											),
										available_n: zod
											.number()
											.or(zod.null())
											.optional()
											.describe(
												"The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n.",
											),
									})
									.describe(
										"Defines a metric to measure in an experiment with its baseline stats.",
									),
								target_n: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"Minimum sample size needed to meet the design specs.",
									),
								sufficient_n: zod
									.boolean()
									.or(zod.null())
									.optional()
									.describe(
										"Whether or not there are enough available units to sample from to meet target_n.",
									),
								target_possible: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.",
									),
								pct_change_possible: zod
									.number()
									.or(zod.null())
									.optional()
									.describe(
										"If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.",
									),
								msg: zod
									.object({
										type: zod
											.enum([
												"sufficient",
												"insufficient",
												"no baseline",
												"no available n",
												"zero effect size",
												"zero variation",
											])
											.describe("Classifies metric power analysis results."),
										msg: zod
											.string()
											.describe(
												"Main power analysis result stated in human-friendly English.",
											),
										source_msg: zod
											.string()
											.describe(
												"Power analysis result formatted as a template string with curly-braced {} named placeholders. Use with the dictionary of values to support localization of messages.",
											),
										values: zod
											.record(zod.string(), zod.number().or(zod.number()))
											.or(zod.null())
											.optional(),
									})
									.describe(
										"Describes interpretation of power analysis results.",
									)
									.or(zod.null())
									.optional()
									.describe("Human friendly message about the above results."),
							})
							.describe("Describes analysis results of a single metric."),
					)
					.max(getExperimentForUiResponsePowerAnalysesAnalysesMax),
			})
			.or(zod.null()),
		assign_summary: zod
			.object({
				balance_check: zod
					.object({
						f_statistic: zod
							.number()
							.describe(
								"F-statistic testing the overall significance of the model predicting treatment assignment.",
							),
						numerator_df: zod
							.number()
							.describe(
								"The numerator degrees of freedom for the f-statistic related to number of dependent variables.",
							),
						denominator_df: zod
							.number()
							.describe(
								"Denominator degrees of freedom related to the number of observations.",
							),
						p_value: zod
							.number()
							.describe(
								"Probability of observing these data if strata do not predict treatment assignment, i.e. our randomization is balanced.",
							),
						balance_ok: zod
							.boolean()
							.describe(
								"Whether the p-value for our observed f_statistic is greater than the f-stat threshold specified in our design specification. (See DesignSpec.fstat_thresh)",
							),
					})
					.describe("Describes balance test results for treatment assignment.")
					.or(zod.null())
					.optional()
					.describe(
						"Balance test results if available. 'online' experiments do not have balance checks.",
					),
				sample_size: zod
					.number()
					.describe("The number of participants across all arms in total."),
				arm_sizes: zod
					.array(
						zod
							.object({
								arm: zod
									.object({
										arm_id: zod
											.string()
											.or(zod.null())
											.optional()
											.describe(
												"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
											),
										arm_name: zod
											.string()
											.max(
												getExperimentForUiResponseAssignSummaryArmSizesItemArmArmNameMax,
											),
										arm_description: zod
											.string()
											.max(
												getExperimentForUiResponseAssignSummaryArmSizesItemArmArmDescriptionMaxOne,
											)
											.or(zod.null())
											.optional(),
									})
									.describe("Describes an experiment treatment arm."),
								size: zod.number().optional(),
							})
							.describe(
								"Describes the number of participants assigned to each arm.",
							),
					)
					.max(getExperimentForUiResponseAssignSummaryArmSizesMaxOne)
					.or(zod.null())
					.optional()
					.describe("For each arm, the number of participants assigned."),
			})
			.describe("Key pieces of an AssignResponse without the assignments.")
			.or(zod.null()),
		webhooks: zod
			.array(zod.string())
			.default(getExperimentForUiResponseWebhooksDefault)
			.describe(
				"List of webhook IDs associated with this experiment. These webhooks are triggered when the experiment is committed.",
			),
	})
	.describe(
		"An experiment configuration capturing all info at design time when assignment was made.",
	);

/**
 * @summary Update Experiment
 */
export const updateExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const updateExperimentBodyNameMaxOne = 100;
export const updateExperimentBodyDescriptionMaxOne = 2000;
export const updateExperimentBodyDesignUrlMaxOne = 500;

export const updateExperimentBody = zod
	.object({
		name: zod
			.string()
			.max(updateExperimentBodyNameMaxOne)
			.or(zod.null())
			.optional(),
		description: zod
			.string()
			.max(updateExperimentBodyDescriptionMaxOne)
			.or(zod.null())
			.optional(),
		design_url: zod
			.string()
			.max(updateExperimentBodyDesignUrlMaxOne)
			.or(zod.null())
			.optional(),
		start_date: zod.string().datetime({}).or(zod.null()).optional(),
		end_date: zod.string().datetime({}).or(zod.null()).optional(),
	})
	.describe(
		"Defines the subset of fields that can be updated for an experiment after creation.",
	);

/**
 * Deletes the experiment with the specified ID.
 * @summary Delete Experiment
 */
export const deleteExperimentParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const deleteExperimentQueryAllowMissingDefault = false;

export const deleteExperimentQueryParams = zod.object({
	allow_missing: zod
		.boolean()
		.optional()
		.describe("If true, return a 204 even if the resource does not exist."),
});

/**
 * @summary Get Experiment Assignments For Ui
 */
export const getExperimentAssignmentsForUiParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const getExperimentAssignmentsForUiResponseAssignmentsItemParticipantIdMax = 64;
export const getExperimentAssignmentsForUiResponseAssignmentsItemArmNameMax = 100;
export const getExperimentAssignmentsForUiResponseAssignmentsItemStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentAssignmentsForUiResponseAssignmentsItemStrataMaxOne = 150;
export const getExperimentAssignmentsForUiResponseAssignmentsItemContextValuesMaxOne = 10;

export const getExperimentAssignmentsForUiResponse = zod
	.object({
		balance_check: zod
			.object({
				f_statistic: zod
					.number()
					.describe(
						"F-statistic testing the overall significance of the model predicting treatment assignment.",
					),
				numerator_df: zod
					.number()
					.describe(
						"The numerator degrees of freedom for the f-statistic related to number of dependent variables.",
					),
				denominator_df: zod
					.number()
					.describe(
						"Denominator degrees of freedom related to the number of observations.",
					),
				p_value: zod
					.number()
					.describe(
						"Probability of observing these data if strata do not predict treatment assignment, i.e. our randomization is balanced.",
					),
				balance_ok: zod
					.boolean()
					.describe(
						"Whether the p-value for our observed f_statistic is greater than the f-stat threshold specified in our design specification. (See DesignSpec.fstat_thresh)",
					),
			})
			.describe("Describes balance test results for treatment assignment.")
			.or(zod.null())
			.optional()
			.describe(
				"Balance test results if available. 'online' experiments do not have balance checks.",
			),
		experiment_id: zod.string(),
		sample_size: zod.number(),
		assignments: zod.array(
			zod
				.object({
					arm_id: zod
						.string()
						.describe(
							"ID of the arm this participant was assigned to. Same as Arm.arm_id.",
						),
					participant_id: zod
						.string()
						.max(
							getExperimentAssignmentsForUiResponseAssignmentsItemParticipantIdMax,
						)
						.describe(
							"Unique identifier for the participant. This is the primary key for the participant in the data warehouse.",
						),
					arm_name: zod
						.string()
						.max(getExperimentAssignmentsForUiResponseAssignmentsItemArmNameMax)
						.describe(
							"The arm this participant was assigned to. Same as Arm.arm_name.",
						),
					created_at: zod
						.string()
						.datetime({})
						.or(zod.null())
						.optional()
						.describe("The date and time the assignment was created."),
					strata: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											getExperimentAssignmentsForUiResponseAssignmentsItemStrataItemFieldNameRegExp,
										),
									strata_value: zod.string().or(zod.null()).optional(),
								})
								.describe(
									"Describes stratification for an experiment participant.",
								),
						)
						.max(
							getExperimentAssignmentsForUiResponseAssignmentsItemStrataMaxOne,
						)
						.or(zod.null())
						.optional()
						.describe(
							"List of properties and their values for this participant used for stratification or tracking metrics. If stratification is not used, this will be None.",
						),
					observed_at: zod
						.string()
						.datetime({})
						.or(zod.null())
						.optional()
						.describe("The date and time the outcome was recorded."),
					outcome: zod
						.number()
						.or(zod.null())
						.optional()
						.describe("The observed outcome for this assignment."),
					context_values: zod
						.array(zod.number())
						.max(
							getExperimentAssignmentsForUiResponseAssignmentsItemContextValuesMaxOne,
						)
						.or(zod.null())
						.optional()
						.describe(
							"List of context values for this assignment. If no contexts are used, this will be None.",
						),
				})
				.describe("Base class for treatment assignment in experiments."),
		),
	})
	.describe(
		"Describes assignments for all participants and balance test results if available.",
	);

/**
 * @summary Export experiment assignments as CSV file; BalanceCheck not included. csv header form: participant_id,arm_id,arm_name,strata_name1,strata_name2,...
 */
export const getExperimentAssignmentsAsCsvForUiParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
});

export const getExperimentAssignmentsAsCsvForUiResponse = zod.any();

/**
 * Get the assignment for a specific participant, excluding strata if any.
    For 'preassigned' experiments, the participant's Assignment is returned if it exists.
    For 'online', returns the assignment if it exists, else generates an assignment.
 * @summary Get Experiment Assignment For Participant
 */
export const getExperimentAssignmentForParticipantParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
	participant_id: zod.string(),
});

export const getExperimentAssignmentForParticipantQueryCreateIfNoneDefault = true;

export const getExperimentAssignmentForParticipantQueryParams = zod.object({
	create_if_none: zod
		.boolean()
		.default(getExperimentAssignmentForParticipantQueryCreateIfNoneDefault)
		.describe(
			"Create an assignment if none exists. Does nothing for preassigned experiments. Override if you just want to check if an assignment exists.",
		),
});

export const getExperimentAssignmentForParticipantResponseAssignmentParticipantIdMax = 64;
export const getExperimentAssignmentForParticipantResponseAssignmentArmNameMax = 100;
export const getExperimentAssignmentForParticipantResponseAssignmentStrataItemFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const getExperimentAssignmentForParticipantResponseAssignmentStrataMaxOne = 150;
export const getExperimentAssignmentForParticipantResponseAssignmentContextValuesMaxOne = 10;

export const getExperimentAssignmentForParticipantResponse = zod
	.object({
		experiment_id: zod.string(),
		participant_id: zod.string(),
		assignment: zod
			.object({
				arm_id: zod
					.string()
					.describe(
						"ID of the arm this participant was assigned to. Same as Arm.arm_id.",
					),
				participant_id: zod
					.string()
					.max(
						getExperimentAssignmentForParticipantResponseAssignmentParticipantIdMax,
					)
					.describe(
						"Unique identifier for the participant. This is the primary key for the participant in the data warehouse.",
					),
				arm_name: zod
					.string()
					.max(
						getExperimentAssignmentForParticipantResponseAssignmentArmNameMax,
					)
					.describe(
						"The arm this participant was assigned to. Same as Arm.arm_name.",
					),
				created_at: zod
					.string()
					.datetime({})
					.or(zod.null())
					.optional()
					.describe("The date and time the assignment was created."),
				strata: zod
					.array(
						zod
							.object({
								field_name: zod
									.string()
									.regex(
										getExperimentAssignmentForParticipantResponseAssignmentStrataItemFieldNameRegExp,
									),
								strata_value: zod.string().or(zod.null()).optional(),
							})
							.describe(
								"Describes stratification for an experiment participant.",
							),
					)
					.max(
						getExperimentAssignmentForParticipantResponseAssignmentStrataMaxOne,
					)
					.or(zod.null())
					.optional()
					.describe(
						"List of properties and their values for this participant used for stratification or tracking metrics. If stratification is not used, this will be None.",
					),
				observed_at: zod
					.string()
					.datetime({})
					.or(zod.null())
					.optional()
					.describe("The date and time the outcome was recorded."),
				outcome: zod
					.number()
					.or(zod.null())
					.optional()
					.describe("The observed outcome for this assignment."),
				context_values: zod
					.array(zod.number())
					.max(
						getExperimentAssignmentForParticipantResponseAssignmentContextValuesMaxOne,
					)
					.or(zod.null())
					.optional()
					.describe(
						"List of context values for this assignment. If no contexts are used, this will be None.",
					),
			})
			.describe("Base class for treatment assignment in experiments.")
			.or(zod.null())
			.describe("Null if no assignment. assignment.strata are not included."),
	})
	.describe(
		"Describes assignment for a single <experiment, participant> pair.",
	);

/**
 * @summary Update Arm
 */
export const updateArmParams = zod.object({
	datasource_id: zod.string(),
	experiment_id: zod.string(),
	arm_id: zod.string(),
});

export const updateArmBodyNameMaxOne = 100;
export const updateArmBodyDescriptionMaxOne = 2000;

export const updateArmBody = zod
	.object({
		name: zod.string().max(updateArmBodyNameMaxOne).or(zod.null()).optional(),
		description: zod
			.string()
			.max(updateArmBodyDescriptionMaxOne)
			.or(zod.null())
			.optional(),
	})
	.describe(
		"Defines the subset of fields that can be updated for an Arm after creation.",
	);

/**
 * Performs a power check for the specified datasource.
 * @summary Power Check
 */
export const powerCheckParams = zod.object({
	datasource_id: zod.string(),
});

export const powerCheckBodyDesignSpecParticipantTypeMax = 100;
export const powerCheckBodyDesignSpecExperimentNameMax = 100;
export const powerCheckBodyDesignSpecDescriptionMax = 2000;
export const powerCheckBodyDesignSpecDesignUrlMaxOne = 500;
export const powerCheckBodyDesignSpecArmsItemArmNameMax = 100;
export const powerCheckBodyDesignSpecArmsItemArmDescriptionMaxOne = 2000;
export const powerCheckBodyDesignSpecArmsMin = 2;

export const powerCheckBodyDesignSpecArmsMax = 10;
export const powerCheckBodyDesignSpecStrataItemFieldNameRegExp = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecStrataMax = 150;
export const powerCheckBodyDesignSpecMetricsItemFieldNameRegExp = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecMetricsMax = 150;
export const powerCheckBodyDesignSpecFiltersItemFieldNameRegExp = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecFiltersMax = 20;
export const powerCheckBodyDesignSpecPowerDefault = 0.8;
export const powerCheckBodyDesignSpecPowerMin = 0;

export const powerCheckBodyDesignSpecPowerMax = 1;
export const powerCheckBodyDesignSpecAlphaDefault = 0.05;
export const powerCheckBodyDesignSpecAlphaMin = 0;

export const powerCheckBodyDesignSpecAlphaMax = 1;
export const powerCheckBodyDesignSpecFstatThreshDefault = 0.6;
export const powerCheckBodyDesignSpecFstatThreshMin = 0;

export const powerCheckBodyDesignSpecFstatThreshMax = 1;
export const powerCheckBodyDesignSpecParticipantTypeMaxOne = 100;
export const powerCheckBodyDesignSpecExperimentNameMaxOne = 100;
export const powerCheckBodyDesignSpecDescriptionMaxOne = 2000;
export const powerCheckBodyDesignSpecDesignUrlMaxFour = 500;
export const powerCheckBodyDesignSpecArmsItemArmNameMaxOne = 100;
export const powerCheckBodyDesignSpecArmsItemArmDescriptionMaxFour = 2000;
export const powerCheckBodyDesignSpecArmsMinOne = 2;

export const powerCheckBodyDesignSpecArmsMaxOne = 10;
export const powerCheckBodyDesignSpecStrataItemFieldNameRegExpOne = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecStrataMaxOne = 150;
export const powerCheckBodyDesignSpecMetricsItemFieldNameRegExpOne = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecMetricsMaxOne = 150;
export const powerCheckBodyDesignSpecFiltersItemFieldNameRegExpOne = new RegExp(
	"^[a-zA-Z_][a-zA-Z0-9_]*$",
);
export const powerCheckBodyDesignSpecFiltersMaxOne = 20;
export const powerCheckBodyDesignSpecPowerDefaultOne = 0.8;
export const powerCheckBodyDesignSpecPowerMinOne = 0;

export const powerCheckBodyDesignSpecPowerMaxOne = 1;
export const powerCheckBodyDesignSpecAlphaDefaultOne = 0.05;
export const powerCheckBodyDesignSpecAlphaMinOne = 0;

export const powerCheckBodyDesignSpecAlphaMaxOne = 1;
export const powerCheckBodyDesignSpecFstatThreshDefaultOne = 0.6;
export const powerCheckBodyDesignSpecFstatThreshMinOne = 0;

export const powerCheckBodyDesignSpecFstatThreshMaxOne = 1;
export const powerCheckBodyDesignSpecParticipantTypeMaxTwo = 100;
export const powerCheckBodyDesignSpecExperimentNameMaxTwo = 100;
export const powerCheckBodyDesignSpecDescriptionMaxTwo = 2000;
export const powerCheckBodyDesignSpecDesignUrlMaxSeven = 500;
export const powerCheckBodyDesignSpecArmsItemArmNameMaxTwo = 100;
export const powerCheckBodyDesignSpecArmsItemArmDescriptionMaxSeven = 2000;
export const powerCheckBodyDesignSpecArmsMinTwo = 2;

export const powerCheckBodyDesignSpecArmsMaxTwo = 10;
export const powerCheckBodyDesignSpecContextsItemContextNameMax = 100;
export const powerCheckBodyDesignSpecContextsItemContextDescriptionMaxOne = 2000;
export const powerCheckBodyDesignSpecContextsMaxOne = 150;
export const powerCheckBodyDesignSpecParticipantTypeMaxThree = 100;
export const powerCheckBodyDesignSpecExperimentNameMaxThree = 100;
export const powerCheckBodyDesignSpecDescriptionMaxThree = 2000;
export const powerCheckBodyDesignSpecDesignUrlMaxOnezero = 500;
export const powerCheckBodyDesignSpecArmsItemArmNameMaxThree = 100;
export const powerCheckBodyDesignSpecArmsItemArmDescriptionMaxOnezero = 2000;
export const powerCheckBodyDesignSpecArmsMinThree = 2;

export const powerCheckBodyDesignSpecArmsMaxThree = 10;
export const powerCheckBodyDesignSpecContextsItemContextNameMaxOne = 100;
export const powerCheckBodyDesignSpecContextsItemContextDescriptionMaxFour = 2000;
export const powerCheckBodyDesignSpecContextsMaxFour = 150;
export const powerCheckBodyDesignSpecParticipantTypeMaxFour = 100;
export const powerCheckBodyDesignSpecExperimentNameMaxFour = 100;
export const powerCheckBodyDesignSpecDescriptionMaxFour = 2000;
export const powerCheckBodyDesignSpecDesignUrlMaxOnethree = 500;
export const powerCheckBodyDesignSpecArmsItemArmNameMaxFour = 100;
export const powerCheckBodyDesignSpecArmsItemArmDescriptionMaxOnethree = 2000;
export const powerCheckBodyDesignSpecArmsMinFour = 2;

export const powerCheckBodyDesignSpecArmsMaxFour = 10;
export const powerCheckBodyDesignSpecContextsItemContextNameMaxTwo = 100;
export const powerCheckBodyDesignSpecContextsItemContextDescriptionMaxSeven = 2000;
export const powerCheckBodyDesignSpecContextsMaxSeven = 150;

export const powerCheckBody = zod.object({
	design_spec: zod
		.object({
			participant_type: zod
				.string()
				.max(powerCheckBodyDesignSpecParticipantTypeMax),
			experiment_id: zod
				.string()
				.or(zod.null())
				.optional()
				.describe(
					"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
				),
			experiment_type: zod.enum(["freq_preassigned"]),
			experiment_name: zod
				.string()
				.max(powerCheckBodyDesignSpecExperimentNameMax),
			description: zod.string().max(powerCheckBodyDesignSpecDescriptionMax),
			design_url: zod
				.string()
				.url()
				.min(1)
				.max(powerCheckBodyDesignSpecDesignUrlMaxOne)
				.or(zod.null())
				.optional()
				.describe("Optional URL to a more detailed experiment design doc."),
			start_date: zod.string().datetime({}),
			end_date: zod.string().datetime({}),
			arms: zod
				.array(
					zod
						.object({
							arm_id: zod
								.string()
								.or(zod.null())
								.optional()
								.describe(
									"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
								),
							arm_name: zod
								.string()
								.max(powerCheckBodyDesignSpecArmsItemArmNameMax),
							arm_description: zod
								.string()
								.max(powerCheckBodyDesignSpecArmsItemArmDescriptionMaxOne)
								.or(zod.null())
								.optional(),
						})
						.describe("Describes an experiment treatment arm."),
				)
				.min(powerCheckBodyDesignSpecArmsMin)
				.max(powerCheckBodyDesignSpecArmsMax),
			strata: zod
				.array(
					zod
						.object({
							field_name: zod
								.string()
								.regex(powerCheckBodyDesignSpecStrataItemFieldNameRegExp),
						})
						.describe("Describes a variable used for stratification."),
				)
				.max(powerCheckBodyDesignSpecStrataMax)
				.describe(
					"Optional participant_type fields to use for stratified assignment.",
				),
			metrics: zod
				.array(
					zod
						.object({
							field_name: zod
								.string()
								.regex(powerCheckBodyDesignSpecMetricsItemFieldNameRegExp),
							metric_pct_change: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
								),
							metric_target: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
								),
						})
						.describe(
							"Defines a request to look up baseline stats for a metric to measure in an experiment.",
						),
				)
				.min(1)
				.max(powerCheckBodyDesignSpecMetricsMax)
				.describe("Primary and optional secondary metrics to target."),
			filters: zod
				.array(
					zod
						.object({
							field_name: zod
								.string()
								.regex(powerCheckBodyDesignSpecFiltersItemFieldNameRegExp),
							relation: zod
								.enum(["includes", "excludes", "between"])
								.describe(
									"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
								),
							value: zod
								.array(zod.number().or(zod.null()))
								.or(zod.array(zod.number().or(zod.null())))
								.or(zod.array(zod.string().or(zod.null())))
								.or(zod.array(zod.boolean().or(zod.null()))),
						})
						.describe(
							'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value             | logical Result                                    |\n|----------|-------------------|---------------------------------------------------|\n| INCLUDES | [None]            | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]             | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None]       | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]        | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]            | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None]       | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]        | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]        | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", "z", None]  | Match `"a" <= x <= "z"` or `x IS NULL`            |\n| BETWEEN  | [None, "z"]       | Match `x <= "z"`                                  |\n| BETWEEN  | ["a", None]       | Match `x >= "a"`                                  |\n| BETWEEN  | [None, "a", None] | Match `x <= "a"` or `x IS NULL`                   |\n\nString comparisons are case-sensitive.\n\n## Special Handling for BETWEEN support of including NULL\n\nWhen the relation is BETWEEN, we allow for up to 3 values to support the special case of\nincluding null in addition to the values in the between range via an OR IS NULL clause, as\nindicated by a 3rd value of None. Any other 3rd value is invalid.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of DATE, DATETIME and TIMESTAMP values\n\nDATE, DATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
						),
				)
				.max(powerCheckBodyDesignSpecFiltersMax)
				.describe(
					"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
				),
			power: zod
				.number()
				.min(powerCheckBodyDesignSpecPowerMin)
				.max(powerCheckBodyDesignSpecPowerMax)
				.default(powerCheckBodyDesignSpecPowerDefault)
				.describe(
					"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
				),
			alpha: zod
				.number()
				.min(powerCheckBodyDesignSpecAlphaMin)
				.max(powerCheckBodyDesignSpecAlphaMax)
				.default(powerCheckBodyDesignSpecAlphaDefault)
				.describe(
					"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
				),
			fstat_thresh: zod
				.number()
				.min(powerCheckBodyDesignSpecFstatThreshMin)
				.max(powerCheckBodyDesignSpecFstatThreshMax)
				.default(powerCheckBodyDesignSpecFstatThreshDefault)
				.describe(
					'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
				),
		})
		.describe(
			"Use this type to randomly select and assign from existing participants at design time with\nfrequentist A/B experiments.",
		)
		.or(
			zod
				.object({
					participant_type: zod
						.string()
						.max(powerCheckBodyDesignSpecParticipantTypeMaxOne),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
						),
					experiment_type: zod.enum(["freq_online"]),
					experiment_name: zod
						.string()
						.max(powerCheckBodyDesignSpecExperimentNameMaxOne),
					description: zod
						.string()
						.max(powerCheckBodyDesignSpecDescriptionMaxOne),
					design_url: zod
						.string()
						.url()
						.min(1)
						.max(powerCheckBodyDesignSpecDesignUrlMaxFour)
						.or(zod.null())
						.optional()
						.describe("Optional URL to a more detailed experiment design doc."),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(powerCheckBodyDesignSpecArmsItemArmNameMaxOne),
									arm_description: zod
										.string()
										.max(powerCheckBodyDesignSpecArmsItemArmDescriptionMaxFour)
										.or(zod.null())
										.optional(),
								})
								.describe("Describes an experiment treatment arm."),
						)
						.min(powerCheckBodyDesignSpecArmsMinOne)
						.max(powerCheckBodyDesignSpecArmsMaxOne),
					strata: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											powerCheckBodyDesignSpecStrataItemFieldNameRegExpOne,
										),
								})
								.describe("Describes a variable used for stratification."),
						)
						.max(powerCheckBodyDesignSpecStrataMaxOne)
						.describe(
							"Optional participant_type fields to use for stratified assignment.",
						),
					metrics: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											powerCheckBodyDesignSpecMetricsItemFieldNameRegExpOne,
										),
									metric_pct_change: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.",
										),
									metric_target: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.",
										),
								})
								.describe(
									"Defines a request to look up baseline stats for a metric to measure in an experiment.",
								),
						)
						.min(1)
						.max(powerCheckBodyDesignSpecMetricsMaxOne)
						.describe("Primary and optional secondary metrics to target."),
					filters: zod
						.array(
							zod
								.object({
									field_name: zod
										.string()
										.regex(
											powerCheckBodyDesignSpecFiltersItemFieldNameRegExpOne,
										),
									relation: zod
										.enum(["includes", "excludes", "between"])
										.describe(
											"Defines operators for filtering values.\n\nINCLUDES matches when the value matches any of the provided values, including null if explicitly\nspecified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided\nvalues will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).\n\nEXCLUDES matches when the value does not match any of the provided values, including null if\nexplicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV\nfields (i.e. experiment_ids), the match will fail if any of the provided values are present\nin the value, but nulls are unsupported.\n\nBETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.",
										),
									value: zod
										.array(zod.number().or(zod.null()))
										.or(zod.array(zod.number().or(zod.null())))
										.or(zod.array(zod.string().or(zod.null())))
										.or(zod.array(zod.boolean().or(zod.null()))),
								})
								.describe(
									'Defines criteria for filtering rows by value.\n\n## Examples\n\n| Relation | Value             | logical Result                                    |\n|----------|-------------------|---------------------------------------------------|\n| INCLUDES | [None]            | Match when `x IS NULL`                            |\n| INCLUDES | ["a"]             | Match when `x IN ("a")`                           |\n| INCLUDES | ["a", None]       | Match when `x IS NULL OR x IN ("a")`              |\n| INCLUDES | ["a", "b"]        | Match when `x IN ("a", "b")`                      |\n| EXCLUDES | [None]            | Match `x IS NOT NULL`                             |\n| EXCLUDES | ["a", None]       | Match `x IS NOT NULL AND x NOT IN ("a")`          |\n| EXCLUDES | ["a", "b"]        | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |\n| BETWEEN  | ["a", "z"]        | Match `"a" <= x <= "z"`                           |\n| BETWEEN  | ["a", "z", None]  | Match `"a" <= x <= "z"` or `x IS NULL`            |\n| BETWEEN  | [None, "z"]       | Match `x <= "z"`                                  |\n| BETWEEN  | ["a", None]       | Match `x >= "a"`                                  |\n| BETWEEN  | [None, "a", None] | Match `x <= "a"` or `x IS NULL`                   |\n\nString comparisons are case-sensitive.\n\n## Special Handling for BETWEEN support of including NULL\n\nWhen the relation is BETWEEN, we allow for up to 3 values to support the special case of\nincluding null in addition to the values in the between range via an OR IS NULL clause, as\nindicated by a 3rd value of None. Any other 3rd value is invalid.\n\n## Special Handling for Comma-Separated Fields\n\nWhen the filter name ends in "experiment_ids", the filter is interpreted as follows:\n\n| Value | Filter         | Result   |\n|-------|----------------|----------|\n| "a,b" | INCLUDES ["a"] | Match    |\n| "a,b" | INCLUDES ["d"] | No match |\n| "a,b" | EXCLUDES ["d"] | Match    |\n| "a,b" | EXCLUDES ["b"] | No match |\n\nNote: The BETWEEN relation is not supported for comma-separated values.\n\nNote: CSV field comparisons are case-insensitive.\n\n## Handling of DATE, DATETIME and TIMESTAMP values\n\nDATE, DATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.\n\nValues must be expressed as ISO8601 datetime strings compatible with Python\'s datetime.fromisoformat()\n(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).\n\nIf a timezone is provided, it must be UTC.',
								),
						)
						.max(powerCheckBodyDesignSpecFiltersMaxOne)
						.describe(
							"Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.",
						),
					power: zod
						.number()
						.min(powerCheckBodyDesignSpecPowerMinOne)
						.max(powerCheckBodyDesignSpecPowerMaxOne)
						.default(powerCheckBodyDesignSpecPowerDefaultOne)
						.describe(
							"The chance of detecting a real non-null effect, i.e. 1 - false negative rate.",
						),
					alpha: zod
						.number()
						.min(powerCheckBodyDesignSpecAlphaMinOne)
						.max(powerCheckBodyDesignSpecAlphaMaxOne)
						.default(powerCheckBodyDesignSpecAlphaDefaultOne)
						.describe(
							"The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.",
						),
					fstat_thresh: zod
						.number()
						.min(powerCheckBodyDesignSpecFstatThreshMinOne)
						.max(powerCheckBodyDesignSpecFstatThreshMaxOne)
						.default(powerCheckBodyDesignSpecFstatThreshDefaultOne)
						.describe(
							'Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".',
						),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution with\nfrequentist A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
		)
		.or(
			zod
				.object({
					participant_type: zod
						.string()
						.max(powerCheckBodyDesignSpecParticipantTypeMaxTwo),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
						),
					experiment_type: zod.enum(["mab_online"]),
					experiment_name: zod
						.string()
						.max(powerCheckBodyDesignSpecExperimentNameMaxTwo),
					description: zod
						.string()
						.max(powerCheckBodyDesignSpecDescriptionMaxTwo),
					design_url: zod
						.string()
						.url()
						.min(1)
						.max(powerCheckBodyDesignSpecDesignUrlMaxSeven)
						.or(zod.null())
						.optional()
						.describe("Optional URL to a more detailed experiment design doc."),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(powerCheckBodyDesignSpecArmsItemArmNameMaxTwo),
									arm_description: zod
										.string()
										.max(powerCheckBodyDesignSpecArmsItemArmDescriptionMaxSeven)
										.or(zod.null())
										.optional(),
									alpha_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial alpha parameter for Beta prior"),
									beta_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial beta parameter for Beta prior"),
									mu_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial mean parameter for Normal prior"),
									sigma_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Initial standard deviation parameter for Normal prior",
										),
									alpha: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated alpha parameter for Beta prior"),
									beta: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated beta parameter for Beta prior"),
									mu: zod
										.array(zod.number())
										.or(zod.null())
										.optional()
										.describe("Updated mean vector for Normal prior"),
									covariance: zod
										.array(zod.array(zod.number()))
										.or(zod.null())
										.optional()
										.describe("Updated covariance matrix for Normal prior"),
								})
								.describe(
									"Describes an experiment arm for bandit experiments.",
								),
						)
						.min(powerCheckBodyDesignSpecArmsMinTwo)
						.max(powerCheckBodyDesignSpecArmsMaxTwo),
					contexts: zod
						.array(
							zod
								.object({
									context_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"Unique identifier for the context, you should NOT set this when creating a new context.",
										),
									context_name: zod
										.string()
										.max(powerCheckBodyDesignSpecContextsItemContextNameMax),
									context_description: zod
										.string()
										.max(
											powerCheckBodyDesignSpecContextsItemContextDescriptionMaxOne,
										)
										.or(zod.null())
										.optional(),
									value_type: zod
										.enum(["binary", "real-valued"])
										.optional()
										.describe("Enum for the type of context."),
								})
								.describe("Pydantic model for context of the experiment."),
						)
						.max(powerCheckBodyDesignSpecContextsMaxOne)
						.or(zod.null())
						.optional()
						.describe(
							"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
						),
					prior_type: zod
						.enum(["beta", "normal"])
						.optional()
						.describe("Enum for the prior distribution of the arm."),
					reward_type: zod
						.enum(["binary", "real-valued"])
						.optional()
						.describe("Enum for the likelihood distribution of the reward."),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution with MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
		)
		.or(
			zod
				.object({
					participant_type: zod
						.string()
						.max(powerCheckBodyDesignSpecParticipantTypeMaxThree),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
						),
					experiment_type: zod.enum(["cmab_online"]),
					experiment_name: zod
						.string()
						.max(powerCheckBodyDesignSpecExperimentNameMaxThree),
					description: zod
						.string()
						.max(powerCheckBodyDesignSpecDescriptionMaxThree),
					design_url: zod
						.string()
						.url()
						.min(1)
						.max(powerCheckBodyDesignSpecDesignUrlMaxOnezero)
						.or(zod.null())
						.optional()
						.describe("Optional URL to a more detailed experiment design doc."),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(powerCheckBodyDesignSpecArmsItemArmNameMaxThree),
									arm_description: zod
										.string()
										.max(
											powerCheckBodyDesignSpecArmsItemArmDescriptionMaxOnezero,
										)
										.or(zod.null())
										.optional(),
									alpha_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial alpha parameter for Beta prior"),
									beta_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial beta parameter for Beta prior"),
									mu_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial mean parameter for Normal prior"),
									sigma_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Initial standard deviation parameter for Normal prior",
										),
									alpha: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated alpha parameter for Beta prior"),
									beta: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated beta parameter for Beta prior"),
									mu: zod
										.array(zod.number())
										.or(zod.null())
										.optional()
										.describe("Updated mean vector for Normal prior"),
									covariance: zod
										.array(zod.array(zod.number()))
										.or(zod.null())
										.optional()
										.describe("Updated covariance matrix for Normal prior"),
								})
								.describe(
									"Describes an experiment arm for bandit experiments.",
								),
						)
						.min(powerCheckBodyDesignSpecArmsMinThree)
						.max(powerCheckBodyDesignSpecArmsMaxThree),
					contexts: zod
						.array(
							zod
								.object({
									context_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"Unique identifier for the context, you should NOT set this when creating a new context.",
										),
									context_name: zod
										.string()
										.max(powerCheckBodyDesignSpecContextsItemContextNameMaxOne),
									context_description: zod
										.string()
										.max(
											powerCheckBodyDesignSpecContextsItemContextDescriptionMaxFour,
										)
										.or(zod.null())
										.optional(),
									value_type: zod
										.enum(["binary", "real-valued"])
										.optional()
										.describe("Enum for the type of context."),
								})
								.describe("Pydantic model for context of the experiment."),
						)
						.max(powerCheckBodyDesignSpecContextsMaxFour)
						.or(zod.null())
						.optional()
						.describe(
							"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
						),
					prior_type: zod
						.enum(["beta", "normal"])
						.optional()
						.describe("Enum for the prior distribution of the arm."),
					reward_type: zod
						.enum(["binary", "real-valued"])
						.optional()
						.describe("Enum for the likelihood distribution of the reward."),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution with\ncontextual MAB experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
		)
		.or(
			zod
				.object({
					participant_type: zod
						.string()
						.max(powerCheckBodyDesignSpecParticipantTypeMaxFour),
					experiment_id: zod
						.string()
						.or(zod.null())
						.optional()
						.describe(
							"ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. \nDEPRECATED: This field is no longer used and will be removed in a future release. Use the Create/GetExperimentResponse field directly.",
						),
					experiment_type: zod.enum(["bayes_ab_online"]),
					experiment_name: zod
						.string()
						.max(powerCheckBodyDesignSpecExperimentNameMaxFour),
					description: zod
						.string()
						.max(powerCheckBodyDesignSpecDescriptionMaxFour),
					design_url: zod
						.string()
						.url()
						.min(1)
						.max(powerCheckBodyDesignSpecDesignUrlMaxOnethree)
						.or(zod.null())
						.optional()
						.describe("Optional URL to a more detailed experiment design doc."),
					start_date: zod.string().datetime({}),
					end_date: zod.string().datetime({}),
					arms: zod
						.array(
							zod
								.object({
									arm_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.",
										),
									arm_name: zod
										.string()
										.max(powerCheckBodyDesignSpecArmsItemArmNameMaxFour),
									arm_description: zod
										.string()
										.max(
											powerCheckBodyDesignSpecArmsItemArmDescriptionMaxOnethree,
										)
										.or(zod.null())
										.optional(),
									alpha_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial alpha parameter for Beta prior"),
									beta_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial beta parameter for Beta prior"),
									mu_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Initial mean parameter for Normal prior"),
									sigma_init: zod
										.number()
										.or(zod.null())
										.optional()
										.describe(
											"Initial standard deviation parameter for Normal prior",
										),
									alpha: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated alpha parameter for Beta prior"),
									beta: zod
										.number()
										.or(zod.null())
										.optional()
										.describe("Updated beta parameter for Beta prior"),
									mu: zod
										.array(zod.number())
										.or(zod.null())
										.optional()
										.describe("Updated mean vector for Normal prior"),
									covariance: zod
										.array(zod.array(zod.number()))
										.or(zod.null())
										.optional()
										.describe("Updated covariance matrix for Normal prior"),
								})
								.describe(
									"Describes an experiment arm for bandit experiments.",
								),
						)
						.min(powerCheckBodyDesignSpecArmsMinFour)
						.max(powerCheckBodyDesignSpecArmsMaxFour),
					contexts: zod
						.array(
							zod
								.object({
									context_id: zod
										.string()
										.or(zod.null())
										.optional()
										.describe(
											"Unique identifier for the context, you should NOT set this when creating a new context.",
										),
									context_name: zod
										.string()
										.max(powerCheckBodyDesignSpecContextsItemContextNameMaxTwo),
									context_description: zod
										.string()
										.max(
											powerCheckBodyDesignSpecContextsItemContextDescriptionMaxSeven,
										)
										.or(zod.null())
										.optional(),
									value_type: zod
										.enum(["binary", "real-valued"])
										.optional()
										.describe("Enum for the type of context."),
								})
								.describe("Pydantic model for context of the experiment."),
						)
						.max(powerCheckBodyDesignSpecContextsMaxSeven)
						.or(zod.null())
						.optional()
						.describe(
							"Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.",
						),
					prior_type: zod
						.enum(["beta", "normal"])
						.optional()
						.describe("Enum for the prior distribution of the arm."),
					reward_type: zod
						.enum(["binary", "real-valued"])
						.optional()
						.describe("Enum for the likelihood distribution of the reward."),
				})
				.describe(
					"Use this type to randomly assign participants into arms during live experiment execution with\nBayesian A/B experiments.\n\nFor example, you may wish to experiment on new users. Assignments are issued via API request.",
				),
		)
		.describe("The type of assignment and experiment design."),
});

export const powerCheckResponseAnalysesItemMetricSpecFieldNameRegExp =
	new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
export const powerCheckResponseAnalysesMax = 150;

export const powerCheckResponse = zod.object({
	analyses: zod
		.array(
			zod
				.object({
					metric_spec: zod
						.object({
							field_name: zod
								.string()
								.regex(powerCheckResponseAnalysesItemMetricSpecFieldNameRegExp),
							metric_pct_change: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"Percent change target relative to the metric_baseline.",
								),
							metric_target: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"Absolute target value = metric_baseline*(1 + metric_pct_change)",
								),
							metric_type: zod
								.enum(["binary", "numeric"])
								.describe("Classifies metrics by their value type.")
								.or(zod.null())
								.optional()
								.describe("Inferred from dwh type."),
							metric_baseline: zod
								.number()
								.or(zod.null())
								.optional()
								.describe("Mean of the tracked metric."),
							metric_stddev: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"Standard deviation is set only for metric_type.NUMERIC metrics. Must be set for numeric metrics when available_n > 0.",
								),
							available_nonnull_n: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"The number of participants meeting the filtering criteria with a *non-null* value for this metric.",
								),
							available_n: zod
								.number()
								.or(zod.null())
								.optional()
								.describe(
									"The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n.",
								),
						})
						.describe(
							"Defines a metric to measure in an experiment with its baseline stats.",
						),
					target_n: zod
						.number()
						.or(zod.null())
						.optional()
						.describe("Minimum sample size needed to meet the design specs."),
					sufficient_n: zod
						.boolean()
						.or(zod.null())
						.optional()
						.describe(
							"Whether or not there are enough available units to sample from to meet target_n.",
						),
					target_possible: zod
						.number()
						.or(zod.null())
						.optional()
						.describe(
							"If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.",
						),
					pct_change_possible: zod
						.number()
						.or(zod.null())
						.optional()
						.describe(
							"If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.",
						),
					msg: zod
						.object({
							type: zod
								.enum([
									"sufficient",
									"insufficient",
									"no baseline",
									"no available n",
									"zero effect size",
									"zero variation",
								])
								.describe("Classifies metric power analysis results."),
							msg: zod
								.string()
								.describe(
									"Main power analysis result stated in human-friendly English.",
								),
							source_msg: zod
								.string()
								.describe(
									"Power analysis result formatted as a template string with curly-braced {} named placeholders. Use with the dictionary of values to support localization of messages.",
								),
							values: zod
								.record(zod.string(), zod.number().or(zod.number()))
								.or(zod.null())
								.optional(),
						})
						.describe("Describes interpretation of power analysis results.")
						.or(zod.null())
						.optional()
						.describe("Human friendly message about the above results."),
				})
				.describe("Describes analysis results of a single metric."),
		)
		.max(powerCheckResponseAnalysesMax),
});
