/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Evidential Experiments API
 * OpenAPI spec version: 0.9.0
 */
export interface AddMemberToOrganizationRequest {
	email: string;
}

export interface AddWebhookToOrganizationRequest {
	type: "experiment.created";
	/**
	 * User-friendly name for the webhook. This name is displayed in the UI and helps identify the webhook's purpose.
	 * @maxLength 100
	 */
	name: string;
	/**
	 * The HTTP or HTTPS URL that will receive webhook notifications when events occur.
	 * @maxLength 500
	 */
	url: string;
}

/**
 * The value of the Webhook-Token: header that will be sent with the request to the configured URL.
 */
export type AddWebhookToOrganizationResponseAuthToken = string | null;

/**
 * Information on the successfully created webhook.
 */
export interface AddWebhookToOrganizationResponse {
	/** The ID of the newly created webhook. */
	id: string;
	/** The type of webhook; e.g. experiment.created */
	type: string;
	/** User-friendly name for the webhook. */
	name: string;
	/** The URL to notify. */
	url: string;
	/** The value of the Webhook-Token: header that will be sent with the request to the configured URL. */
	auth_token: AddWebhookToOrganizationResponseAuthToken;
}

export interface ApiKeySummary {
	/** @maxLength 64 */
	id: string;
	/** @maxLength 64 */
	datasource_id: string;
	/** @maxLength 64 */
	organization_id: string;
	/** @maxLength 100 */
	organization_name: string;
}

/**
 * ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.
 */
export type ArmArmId = string | null;

export type ArmArmDescription = string | null;

/**
 * Describes an experiment treatment arm.
 */
export interface Arm {
	/** ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. */
	arm_id?: ArmArmId;
	/** @maxLength 100 */
	arm_name: string;
	arm_description?: ArmArmDescription;
}

/**
 * ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.
 */
export type ArmAnalysisArmId = string | null;

export type ArmAnalysisArmDescription = string | null;

/**
 * The p-value indicating statistical significance of the treatment effect. Value may be None if the t-stat is not available, e.g. due to inability to calculate the standard error.
 */
export type ArmAnalysisPValue = number | null;

/**
 * The t-statistic from the statistical test. If the value is actually NaN, e.g. due to inability to calculate the standard error, we return None.
 */
export type ArmAnalysisTStat = number | null;

export interface ArmAnalysis {
	/** ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. */
	arm_id?: ArmAnalysisArmId;
	/** @maxLength 100 */
	arm_name: string;
	arm_description?: ArmAnalysisArmDescription;
	/** The estimated treatment effect relative to the baseline arm. */
	estimate: number;
	/** The p-value indicating statistical significance of the treatment effect. Value may be None if the t-stat is not available, e.g. due to inability to calculate the standard error. */
	p_value: ArmAnalysisPValue;
	/** The t-statistic from the statistical test. If the value is actually NaN, e.g. due to inability to calculate the standard error, we return None. */
	t_stat: ArmAnalysisTStat;
	/** The standard error of the treatment effect estimate. */
	std_error: number;
	/** The number of participants assigned to this arm with missing values (NaNs) for this metric. These rows are excluded from the analysis. */
	num_missing_values: number;
	/** Whether this arm is the baseline/control arm for comparison. */
	is_baseline: boolean;
}

/**
 * ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.
 */
export type ArmBanditArmId = string | null;

export type ArmBanditArmDescription = string | null;

/**
 * Initial alpha parameter for Beta prior
 */
export type ArmBanditAlphaInit = number | null;

/**
 * Initial beta parameter for Beta prior
 */
export type ArmBanditBetaInit = number | null;

/**
 * Initial mean parameter for Normal prior
 */
export type ArmBanditMuInit = number | null;

/**
 * Initial standard deviation parameter for Normal prior
 */
export type ArmBanditSigmaInit = number | null;

/**
 * Updated alpha parameter for Beta prior
 */
export type ArmBanditAlpha = number | null;

/**
 * Updated beta parameter for Beta prior
 */
export type ArmBanditBeta = number | null;

/**
 * Updated mean vector for Normal prior
 */
export type ArmBanditMu = number[] | null;

/**
 * Updated covariance matrix for Normal prior
 */
export type ArmBanditCovariance = number[][] | null;

/**
 * Describes an experiment arm for bandit experiments.
 */
export interface ArmBandit {
	/** ID of the arm. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. */
	arm_id?: ArmBanditArmId;
	/** @maxLength 100 */
	arm_name: string;
	arm_description?: ArmBanditArmDescription;
	/** Initial alpha parameter for Beta prior */
	alpha_init?: ArmBanditAlphaInit;
	/** Initial beta parameter for Beta prior */
	beta_init?: ArmBanditBetaInit;
	/** Initial mean parameter for Normal prior */
	mu_init?: ArmBanditMuInit;
	/** Initial standard deviation parameter for Normal prior */
	sigma_init?: ArmBanditSigmaInit;
	/** Updated alpha parameter for Beta prior */
	alpha?: ArmBanditAlpha;
	/** Updated beta parameter for Beta prior */
	beta?: ArmBanditBeta;
	/** Updated mean vector for Normal prior */
	mu?: ArmBanditMu;
	/** Updated covariance matrix for Normal prior */
	covariance?: ArmBanditCovariance;
}

/**
 * Describes the number of participants assigned to each arm.
 */
export interface ArmSize {
	arm: Arm;
	size?: number;
}

/**
 * Balance test results if available. 'online' experiments do not have balance checks.
 */
export type AssignSummaryBalanceCheck = BalanceCheck | null;

/**
 * For each arm, the number of participants assigned.
 */
export type AssignSummaryArmSizes = ArmSize[] | null;

/**
 * Key pieces of an AssignResponse without the assignments.
 */
export interface AssignSummary {
	/** Balance test results if available. 'online' experiments do not have balance checks. */
	balance_check?: AssignSummaryBalanceCheck;
	/** The number of participants across all arms in total. */
	sample_size: number;
	/** For each arm, the number of participants assigned. */
	arm_sizes?: AssignSummaryArmSizes;
}

/**
 * The date and time the assignment was created.
 */
export type AssignmentCreatedAt = string | null;

/**
 * List of properties and their values for this participant used for stratification or tracking metrics. If stratification is not used, this will be None.
 */
export type AssignmentStrata = Strata[] | null;

/**
 * The date and time the outcome was recorded.
 */
export type AssignmentObservedAt = string | null;

/**
 * The observed outcome for this assignment.
 */
export type AssignmentOutcome = number | null;

/**
 * List of context values for this assignment. If no contexts are used, this will be None.
 */
export type AssignmentContextValues = number[] | null;

/**
 * Base class for treatment assignment in experiments.
 */
export interface Assignment {
	/** ID of the arm this participant was assigned to. Same as Arm.arm_id. */
	arm_id: string;
	/**
	 * Unique identifier for the participant. This is the primary key for the participant in the data warehouse.
	 * @maxLength 64
	 */
	participant_id: string;
	/**
	 * The arm this participant was assigned to. Same as Arm.arm_name.
	 * @maxLength 100
	 */
	arm_name: string;
	/** The date and time the assignment was created. */
	created_at?: AssignmentCreatedAt;
	/** List of properties and their values for this participant used for stratification or tracking metrics. If stratification is not used, this will be None. */
	strata?: AssignmentStrata;
	/** The date and time the outcome was recorded. */
	observed_at?: AssignmentObservedAt;
	/** The observed outcome for this assignment. */
	outcome?: AssignmentOutcome;
	/** List of context values for this assignment. If no contexts are used, this will be None. */
	context_values?: AssignmentContextValues;
}

/**
 * Describes balance test results for treatment assignment.
 */
export interface BalanceCheck {
	/** F-statistic testing the overall significance of the model predicting treatment assignment. */
	f_statistic: number;
	/** The numerator degrees of freedom for the f-statistic related to number of dependent variables. */
	numerator_df: number;
	/** Denominator degrees of freedom related to the number of observations. */
	denominator_df: number;
	/** Probability of observing these data if strata do not predict treatment assignment, i.e. our randomization is balanced. */
	p_value: number;
	/** Whether the p-value for our observed f_statistic is greater than the f-stat threshold specified in our design specification. (See DesignSpec.fstat_thresh) */
	balance_ok: boolean;
}

/**
 * Describes changes in arms for a bandit experiment
 */
export interface BanditExperimentAnalysisResponse {
	/** ID of the experiment. */
	experiment_id: string;
	/** The number of trials conducted for this experiment. */
	n_trials: number;
	/** The number of outcomes observed for this experiment. */
	n_outcomes: number;
	/** Posterior means for each arm in the experiment. */
	posterior_means: number[];
	/** Posterior standard deviations for each arm in the experiment. */
	posterior_stds: number[];
	/** Volume of participants for each arm in the experiment. */
	volumes: number[];
}

/**
 * ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.
 */
export type BayesABExperimentSpecInputExperimentId = string | null;

export type BayesABExperimentSpecInputExperimentType =
	(typeof BayesABExperimentSpecInputExperimentType)[keyof typeof BayesABExperimentSpecInputExperimentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BayesABExperimentSpecInputExperimentType = {
	bayes_ab_online: "bayes_ab_online",
} as const;

/**
 * Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.
 */
export type BayesABExperimentSpecInputContexts = Context[] | null;

/**
 * Use this type to randomly assign participants into arms during live experiment execution with Bayesian A/B experiments.

For example, you may wish to experiment on new users. Assignments are issued via API request.
 */
export interface BayesABExperimentSpecInput {
	/** @maxLength 100 */
	participant_type: string;
	/** ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. */
	experiment_id?: BayesABExperimentSpecInputExperimentId;
	experiment_type: BayesABExperimentSpecInputExperimentType;
	/** @maxLength 100 */
	experiment_name: string;
	/** @maxLength 2000 */
	description: string;
	start_date: string;
	end_date: string;
	/**
	 * @minItems 2
	 * @maxItems 10
	 */
	arms: ArmBandit[];
	/** Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments. */
	contexts?: BayesABExperimentSpecInputContexts;
	/** The type of prior distribution for the arms. */
	prior_type?: PriorTypes;
	/** The type of reward we observe from the experiment. */
	reward_type?: LikelihoodTypes;
}

/**
 * ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.
 */
export type BayesABExperimentSpecOutputExperimentId = string | null;

export type BayesABExperimentSpecOutputExperimentType =
	(typeof BayesABExperimentSpecOutputExperimentType)[keyof typeof BayesABExperimentSpecOutputExperimentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BayesABExperimentSpecOutputExperimentType = {
	bayes_ab_online: "bayes_ab_online",
} as const;

/**
 * Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.
 */
export type BayesABExperimentSpecOutputContexts = Context[] | null;

/**
 * Use this type to randomly assign participants into arms during live experiment execution with Bayesian A/B experiments.

For example, you may wish to experiment on new users. Assignments are issued via API request.
 */
export interface BayesABExperimentSpecOutput {
	/** @maxLength 100 */
	participant_type: string;
	/** ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. */
	experiment_id?: BayesABExperimentSpecOutputExperimentId;
	experiment_type: BayesABExperimentSpecOutputExperimentType;
	/** @maxLength 100 */
	experiment_name: string;
	/** @maxLength 2000 */
	description: string;
	start_date: string;
	end_date: string;
	/**
	 * @minItems 2
	 * @maxItems 10
	 */
	arms: ArmBandit[];
	/** Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments. */
	contexts?: BayesABExperimentSpecOutputContexts;
	/** The type of prior distribution for the arms. */
	prior_type?: PriorTypes;
	/** The type of reward we observe from the experiment. */
	reward_type?: LikelihoodTypes;
}

export type BqDsnInputDriver =
	(typeof BqDsnInputDriver)[keyof typeof BqDsnInputDriver];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BqDsnInputDriver = {
	bigquery: "bigquery",
} as const;

/**
 * Describes a BigQuery connection.
 */
export interface BqDsnInput {
	driver: BqDsnInputDriver;
	/**
	 * The Google Cloud Project ID containing the dataset.
	 * @minLength 6
	 * @maxLength 30
	 * @pattern ^[a-z0-9-]+$
	 */
	project_id: string;
	/**
	 * The dataset name.
	 * @minLength 1
	 * @maxLength 1024
	 * @pattern ^[a-zA-Z0-9_]+$
	 */
	dataset_id: string;
	credentials: GcpCredentials;
}

export type BqDsnOutputDriver =
	(typeof BqDsnOutputDriver)[keyof typeof BqDsnOutputDriver];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BqDsnOutputDriver = {
	bigquery: "bigquery",
} as const;

/**
 * Describes a BigQuery connection.
 */
export interface BqDsnOutput {
	driver: BqDsnOutputDriver;
	/**
	 * The Google Cloud Project ID containing the dataset.
	 * @minLength 6
	 * @maxLength 30
	 * @pattern ^[a-z0-9-]+$
	 */
	project_id: string;
	/**
	 * The dataset name.
	 * @minLength 1
	 * @maxLength 1024
	 * @pattern ^[a-zA-Z0-9_]+$
	 */
	dataset_id: string;
	credentials: GcpCredentials;
}

/**
 * ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.
 */
export type CMABExperimentSpecInputExperimentId = string | null;

export type CMABExperimentSpecInputExperimentType =
	(typeof CMABExperimentSpecInputExperimentType)[keyof typeof CMABExperimentSpecInputExperimentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CMABExperimentSpecInputExperimentType = {
	cmab_online: "cmab_online",
} as const;

/**
 * Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.
 */
export type CMABExperimentSpecInputContexts = Context[] | null;

/**
 * Use this type to randomly assign participants into arms during live experiment execution with contextual MAB experiments.

For example, you may wish to experiment on new users. Assignments are issued via API request.
 */
export interface CMABExperimentSpecInput {
	/** @maxLength 100 */
	participant_type: string;
	/** ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. */
	experiment_id?: CMABExperimentSpecInputExperimentId;
	experiment_type: CMABExperimentSpecInputExperimentType;
	/** @maxLength 100 */
	experiment_name: string;
	/** @maxLength 2000 */
	description: string;
	start_date: string;
	end_date: string;
	/**
	 * @minItems 2
	 * @maxItems 10
	 */
	arms: ArmBandit[];
	/** Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments. */
	contexts?: CMABExperimentSpecInputContexts;
	/** The type of prior distribution for the arms. */
	prior_type?: PriorTypes;
	/** The type of reward we observe from the experiment. */
	reward_type?: LikelihoodTypes;
}

/**
 * ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.
 */
export type CMABExperimentSpecOutputExperimentId = string | null;

export type CMABExperimentSpecOutputExperimentType =
	(typeof CMABExperimentSpecOutputExperimentType)[keyof typeof CMABExperimentSpecOutputExperimentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CMABExperimentSpecOutputExperimentType = {
	cmab_online: "cmab_online",
} as const;

/**
 * Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.
 */
export type CMABExperimentSpecOutputContexts = Context[] | null;

/**
 * Use this type to randomly assign participants into arms during live experiment execution with contextual MAB experiments.

For example, you may wish to experiment on new users. Assignments are issued via API request.
 */
export interface CMABExperimentSpecOutput {
	/** @maxLength 100 */
	participant_type: string;
	/** ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. */
	experiment_id?: CMABExperimentSpecOutputExperimentId;
	experiment_type: CMABExperimentSpecOutputExperimentType;
	/** @maxLength 100 */
	experiment_name: string;
	/** @maxLength 2000 */
	description: string;
	start_date: string;
	end_date: string;
	/**
	 * @minItems 2
	 * @maxItems 10
	 */
	arms: ArmBandit[];
	/** Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments. */
	contexts?: CMABExperimentSpecOutputContexts;
	/** The type of prior distribution for the arms. */
	prior_type?: PriorTypes;
	/** The type of reward we observe from the experiment. */
	reward_type?: LikelihoodTypes;
}

/**
 * The credentials returned to the SPA in exchange for a successful OIDC PKCE exchange.

TODO: This is a placeholder for a longer-lived IDP-versatile session token.
 */
export interface CallbackResponse {
	/** The ID token as generated by Google. Represents a successful authentication. */
	id_token: string;
}

/**
 * Describes the user's identity in a format suitable for use in the frontend.
 */
export interface CallerIdentity {
	email: string;
	iss: string;
	sub: string;
	hd: string;
	is_privileged: boolean;
}

/**
 * Unique identifier for the context, you should NOT set this when creating a new context.
 */
export type ContextContextId = string | null;

export type ContextContextDescription = string | null;

/**
 * Pydantic model for context of the experiment.
 */
export interface Context {
	/** Unique identifier for the context, you should NOT set this when creating a new context. */
	context_id?: ContextContextId;
	/** @maxLength 100 */
	context_name: string;
	context_description?: ContextContextDescription;
	/** Type of value the context can take */
	value_type?: ContextType;
}

/**
 * Pydantic model for a context input
 */
export interface ContextInputRequest {
	/** Unique identifier for the context. */
	context_id: string;
	/** Value of the context */
	context_value: number;
}

/**
 * Enum for the type of context.
 */
export type ContextType = (typeof ContextType)[keyof typeof ContextType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ContextType = {
	binary: "binary",
	"real-valued": "real-valued",
} as const;

export interface CreateApiKeyResponse {
	/** @maxLength 64 */
	id: string;
	datasource_id: string;
	key: string;
}

export interface CreateDatasourceRequest {
	/** @maxLength 64 */
	organization_id: string;
	name: string;
	dwh: DwhInput;
}

export interface CreateDatasourceResponse {
	/** @maxLength 64 */
	id: string;
}

export type CreateExperimentRequestPowerAnalyses = PowerResponseInput | null;

export interface CreateExperimentRequest {
	design_spec: DesignSpecInput;
	power_analyses?: CreateExperimentRequestPowerAnalyses;
	/** List of webhook IDs to associate with this experiment. When the experiment is committed, these webhooks will be triggered with experiment details. Must contain unique values. */
	webhooks?: string[];
}

/**
 * The date and time assignments were stopped. Null if assignments are still allowed to be made.
 */
export type CreateExperimentResponseStoppedAssignmentsAt = string | null;

/**
 * The reason assignments were stopped. Null if assignments are still allowed to be made.
 */
export type CreateExperimentResponseStoppedAssignmentsReason =
	StopAssignmentReason | null;

export type CreateExperimentResponsePowerAnalyses = PowerResponseOutput | null;

export type CreateExperimentResponseAssignSummary = AssignSummary | null;

/**
 * Same as the request but with ids filled for the experiment and arms, and summary info on the assignment.
 */
export interface CreateExperimentResponse {
	datasource_id: string;
	/** Current state of this experiment. */
	state: ExperimentState;
	/** The date and time assignments were stopped. Null if assignments are still allowed to be made. */
	stopped_assignments_at: CreateExperimentResponseStoppedAssignmentsAt;
	/** The reason assignments were stopped. Null if assignments are still allowed to be made. */
	stopped_assignments_reason: CreateExperimentResponseStoppedAssignmentsReason;
	design_spec: DesignSpecOutput;
	power_analyses: CreateExperimentResponsePowerAnalyses;
	assign_summary: CreateExperimentResponseAssignSummary;
	/** List of webhook IDs associated with this experiment. These webhooks are triggered when the experiment is committed. */
	webhooks?: string[];
}

export interface CreateOrganizationRequest {
	/** @maxLength 100 */
	name: string;
}

export interface CreateOrganizationResponse {
	/** @maxLength 64 */
	id: string;
}

export interface CreateParticipantsTypeRequest {
	/** @maxLength 100 */
	participant_type: string;
	schema_def: ParticipantsSchemaInput;
}

export interface CreateParticipantsTypeResponse {
	/** @maxLength 100 */
	participant_type: string;
	schema_def: ParticipantsSchemaOutput;
}

/**
 * Defines the supported data types for fields in the data source.
 */
export type DataType = (typeof DataType)[keyof typeof DataType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DataType = {
	boolean: "boolean",
	character_varying: "character varying",
	uuid: "uuid",
	date: "date",
	integer: "integer",
	double_precision: "double precision",
	numeric: "numeric",
	timestamp_without_time_zone: "timestamp without time zone",
	timestamp_with_time_zone: "timestamp with time zone",
	bigint: "bigint",
	"jsonb_(unsupported)": "jsonb (unsupported)",
	"json_(unsupported)": "json (unsupported)",
	unsupported: "unsupported",
} as const;

export type DatasourceConfigWebhookConfig = WebhookConfig | null;

/**
 * RemoteDatabaseConfig defines a configuration for a remote data warehouse.
 */
export interface DatasourceConfig {
	participants: ParticipantsConfig[];
	webhook_config?: DatasourceConfigWebhookConfig;
	type: "remote";
	dwh: DwhOutput;
}

export interface DatasourceSummary {
	/** @maxLength 64 */
	id: string;
	/** @maxLength 100 */
	name: string;
	driver: string;
	type: string;
	/** @maxLength 64 */
	organization_id: string;
	/** @maxLength 100 */
	organization_name: string;
}

/**
 * The type of assignment and experiment design.
 */
export type DesignSpecInput =
	| PreassignedFrequentistExperimentSpecInput
	| OnlineFrequentistExperimentSpecInput
	| MABExperimentSpecInput
	| CMABExperimentSpecInput
	| BayesABExperimentSpecInput;

/**
 * The type of assignment and experiment design.
 */
export type DesignSpecOutput =
	| PreassignedFrequentistExperimentSpecOutput
	| OnlineFrequentistExperimentSpecOutput
	| MABExperimentSpecOutput
	| CMABExperimentSpecOutput
	| BayesABExperimentSpecOutput;

/**
 * Percent change target relative to the metric_baseline.
 */
export type DesignSpecMetricMetricPctChange = number | null;

/**
 * Absolute target value = metric_baseline*(1 + metric_pct_change)
 */
export type DesignSpecMetricMetricTarget = number | null;

/**
 * Inferred from dwh type.
 */
export type DesignSpecMetricMetricType = MetricType | null;

/**
 * Mean of the tracked metric.
 */
export type DesignSpecMetricMetricBaseline = number | null;

/**
 * Standard deviation is set only for metric_type.NUMERIC metrics. Must be set for numeric metrics when available_n > 0.
 */
export type DesignSpecMetricMetricStddev = number | null;

/**
 * The number of participants meeting the filtering criteria with a *non-null* value for this metric.
 */
export type DesignSpecMetricAvailableNonnullN = number | null;

/**
 * The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n.
 */
export type DesignSpecMetricAvailableN = number | null;

/**
 * Defines a metric to measure in an experiment with its baseline stats.
 */
export interface DesignSpecMetric {
	/** @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$ */
	field_name: string;
	/** Percent change target relative to the metric_baseline. */
	metric_pct_change?: DesignSpecMetricMetricPctChange;
	/** Absolute target value = metric_baseline*(1 + metric_pct_change) */
	metric_target?: DesignSpecMetricMetricTarget;
	/** Inferred from dwh type. */
	metric_type?: DesignSpecMetricMetricType;
	/** Mean of the tracked metric. */
	metric_baseline?: DesignSpecMetricMetricBaseline;
	/** Standard deviation is set only for metric_type.NUMERIC metrics. Must be set for numeric metrics when available_n > 0. */
	metric_stddev?: DesignSpecMetricMetricStddev;
	/** The number of participants meeting the filtering criteria with a *non-null* value for this metric. */
	available_nonnull_n?: DesignSpecMetricAvailableNonnullN;
	/** The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n. */
	available_n?: DesignSpecMetricAvailableN;
}

/**
 * Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.
 */
export type DesignSpecMetricRequestMetricPctChange = number | null;

/**
 * Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.
 */
export type DesignSpecMetricRequestMetricTarget = number | null;

/**
 * Defines a request to look up baseline stats for a metric to measure in an experiment.
 */
export interface DesignSpecMetricRequest {
	/** @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$ */
	field_name: string;
	/** Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target. */
	metric_pct_change?: DesignSpecMetricRequestMetricPctChange;
	/** Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change. */
	metric_target?: DesignSpecMetricRequestMetricTarget;
}

export type DsnDriver = (typeof DsnDriver)[keyof typeof DsnDriver];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DsnDriver = {
	"postgresql+psycopg": "postgresql+psycopg",
	"postgresql+psycopg2": "postgresql+psycopg2",
} as const;

export type DsnSslmode = (typeof DsnSslmode)[keyof typeof DsnSslmode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DsnSslmode = {
	disable: "disable",
	require: "require",
	"verify-ca": "verify-ca",
	"verify-full": "verify-full",
} as const;

export type DsnSearchPath = string | null;

/**
 * Describes a set of parameters suitable for connecting to most types of remote databases.
 */
export interface Dsn {
	driver: DsnDriver;
	host: string;
	/**
	 * @minimum 1024
	 * @maximum 65535
	 */
	port?: number;
	user: string;
	password: string;
	dbname: string;
	sslmode: DsnSslmode;
	search_path?: DsnSearchPath;
}

export type DwhInput = Dsn | BqDsnInput | NoDwh;

export type DwhOutput = Dsn | BqDsnOutput | NoDwh;

/**
 * A navigable link to related information.
 */
export type EventSummaryLink = string | null;

export type EventSummaryDetailsAnyOf = { [key: string]: unknown };

/**
 * Details
 */
export type EventSummaryDetails = EventSummaryDetailsAnyOf | null;

/**
 * Describes an event.
 */
export interface EventSummary {
	/** The ID of the event. */
	id: string;
	/** The time the event was created. */
	created_at: string;
	/** The type of event. */
	type: string;
	/** Human-readable summary of the event. */
	summary: string;
	/** A navigable link to related information. */
	link?: EventSummaryLink;
	/** Details */
	details: EventSummaryDetails;
}

/**
 * The date and time assignments were stopped. Null if assignments are still allowed to be made.
 */
export type ExperimentConfigStoppedAssignmentsAt = string | null;

/**
 * The reason assignments were stopped. Null if assignments are still allowed to be made.
 */
export type ExperimentConfigStoppedAssignmentsReason =
	StopAssignmentReason | null;

export type ExperimentConfigPowerAnalyses = PowerResponseOutput | null;

export type ExperimentConfigAssignSummary = AssignSummary | null;

/**
 * Representation of our stored Experiment information.
 */
export interface ExperimentConfig {
	datasource_id: string;
	/** Current state of this experiment. */
	state: ExperimentState;
	/** The date and time assignments were stopped. Null if assignments are still allowed to be made. */
	stopped_assignments_at: ExperimentConfigStoppedAssignmentsAt;
	/** The reason assignments were stopped. Null if assignments are still allowed to be made. */
	stopped_assignments_reason: ExperimentConfigStoppedAssignmentsReason;
	design_spec: DesignSpecOutput;
	power_analyses: ExperimentConfigPowerAnalyses;
	assign_summary: ExperimentConfigAssignSummary;
	/** List of webhook IDs associated with this experiment. These webhooks are triggered when the experiment is committed. */
	webhooks?: string[];
}

/**
 * Experiment lifecycle states.

note: [starting state], [[terminal state]]
[DESIGNING]->[ASSIGNED]->{[[ABANDONED]], COMMITTED}->[[ABORTED]]
 */
export type ExperimentState =
	(typeof ExperimentState)[keyof typeof ExperimentState];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ExperimentState = {
	designing: "designing",
	assigned: "assigned",
	abandoned: "abandoned",
	committed: "committed",
	aborted: "aborted",
} as const;

export type FieldDescriptorExtraAnyOf = { [key: string]: string };

/**
 * Additional field metadata
 */
export type FieldDescriptorExtra = FieldDescriptorExtraAnyOf | null;

export interface FieldDescriptor {
	/** Name of the field in the data source */
	field_name: string;
	/** The data type of this field */
	data_type: DataType;
	/** Human-readable description of the field */
	description?: string;
	/** Whether this field uniquely identifies records */
	is_unique_id?: boolean;
	/** Whether this field should be used for stratification */
	is_strata?: boolean;
	/** Whether this field can be used as a filter */
	is_filter?: boolean;
	/** Whether this field can be used as a metric */
	is_metric?: boolean;
	/** Additional field metadata */
	extra?: FieldDescriptorExtra;
}

/**
 * Concise summary of fields in the table.
 */
export interface FieldMetadata {
	/** @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$ */
	field_name: string;
	data_type: DataType;
	/** @maxLength 2000 */
	description: string;
}

/**
 * Defines criteria for filtering rows by value.

## Examples

| Relation | Value       | logical Result                                    |
|----------|-------------|---------------------------------------------------|
| INCLUDES | [None]      | Match when `x IS NULL`                            |
| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |
| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |
| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |
| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |
| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |
| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |
| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |
| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |

String comparisons are case-sensitive.

## Special Handling for Comma-Separated Fields

When the filter name ends in "experiment_ids", the filter is interpreted as follows:

| Value | Filter         | Result   |
|-------|----------------|----------|
| "a,b" | INCLUDES ["a"] | Match    |
| "a,b" | INCLUDES ["d"] | No match |
| "a,b" | EXCLUDES ["d"] | Match    |
| "a,b" | EXCLUDES ["b"] | No match |

Note: The BETWEEN relation is not supported for comma-separated values.

Note: CSV field comparisons are case-insensitive.

## Handling of datetime and timestamp values

DATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.

Values must be expressed as ISO8601 datetime strings compatible with Python's datetime.fromisoformat()
(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).

If a timezone is provided, it must be UTC.
 */
export interface FilterInput {
	/** @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$ */
	field_name: string;
	relation: Relation;
	value: FilterValueTypes;
}

/**
 * Defines criteria for filtering rows by value.

## Examples

| Relation | Value       | logical Result                                    |
|----------|-------------|---------------------------------------------------|
| INCLUDES | [None]      | Match when `x IS NULL`                            |
| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |
| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |
| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |
| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |
| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |
| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |
| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |
| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |

String comparisons are case-sensitive.

## Special Handling for Comma-Separated Fields

When the filter name ends in "experiment_ids", the filter is interpreted as follows:

| Value | Filter         | Result   |
|-------|----------------|----------|
| "a,b" | INCLUDES ["a"] | Match    |
| "a,b" | INCLUDES ["d"] | No match |
| "a,b" | EXCLUDES ["d"] | Match    |
| "a,b" | EXCLUDES ["b"] | No match |

Note: The BETWEEN relation is not supported for comma-separated values.

Note: CSV field comparisons are case-insensitive.

## Handling of datetime and timestamp values

DATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.

Values must be expressed as ISO8601 datetime strings compatible with Python's datetime.fromisoformat()
(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).

If a timezone is provided, it must be UTC.
 */
export interface FilterOutput {
	/** @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$ */
	field_name: string;
	relation: Relation;
	value: FilterValueTypes;
}

export type FilterValueTypesAnyOfItem = string | null;

export type FilterValueTypesAnyOfTwoItem = boolean | null;

export type FilterValueTypes =
	| StrictInt[]
	| StrictFloat[]
	| FilterValueTypesAnyOfItem[]
	| FilterValueTypesAnyOfTwoItem[];

/**
 * The number of participants assigned to the experiment across all arms that are not found in the data warehouse when pulling metrics.
 */
export type FreqExperimentAnalysisResponseNumMissingParticipants =
	| number
	| null;

/**
 * Describes the change if any in metrics targeted by an experiment.
 */
export interface FreqExperimentAnalysisResponse {
	/** ID of the experiment. */
	experiment_id: string;
	/** Contains one analysis per metric targeted by the experiment. */
	metric_analyses: MetricAnalysis[];
	/** The number of participants assigned to the experiment pulled from the dwh across all arms. Metric outcomes are not guaranteed to be present for all participants. */
	num_participants: number;
	/** The number of participants assigned to the experiment across all arms that are not found in the data warehouse when pulling metrics. */
	num_missing_participants?: FreqExperimentAnalysisResponseNumMissingParticipants;
	/** The date and time the experiment analysis was created. */
	created_at: string;
}

/**
 * The Google Cloud Service Account credentials.
 */
export type GcpCredentials = GcpServiceAccountInfo | GcpServiceAccountFile;

export type GcpServiceAccountFileType =
	(typeof GcpServiceAccountFileType)[keyof typeof GcpServiceAccountFileType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GcpServiceAccountFileType = {
	serviceaccountfile: "serviceaccountfile",
} as const;

/**
 * Describes a file path to a Google Cloud Service Account credential file.
 */
export interface GcpServiceAccountFile {
	type: GcpServiceAccountFileType;
	/** The path to the service account credentials file containing the credentials in canonical JSON form. */
	path: string;
}

export type GcpServiceAccountInfoType =
	(typeof GcpServiceAccountInfoType)[keyof typeof GcpServiceAccountInfoType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GcpServiceAccountInfoType = {
	serviceaccountinfo: "serviceaccountinfo",
} as const;

/**
 * Describes a Google Cloud Service Account credential.
 */
export interface GcpServiceAccountInfo {
	type: GcpServiceAccountInfoType;
	/**
	 * The base64-encoded service account info in the canonical JSON form.
	 * @minLength 4
	 * @maxLength 8000
	 */
	content_base64: string;
}

export interface GetDatasourceResponse {
	/** @maxLength 64 */
	id: string;
	/** @maxLength 100 */
	name: string;
	config: DatasourceConfig;
	/** @maxLength 64 */
	organization_id: string;
	/** @maxLength 100 */
	organization_name: string;
}

/**
 * Balance test results if available. 'online' experiments do not have balance checks.
 */
export type GetExperimentAssignmentsResponseBalanceCheck = BalanceCheck | null;

/**
 * Describes assignments for all participants and balance test results if available.
 */
export interface GetExperimentAssignmentsResponse {
	/** Balance test results if available. 'online' experiments do not have balance checks. */
	balance_check?: GetExperimentAssignmentsResponseBalanceCheck;
	experiment_id: string;
	sample_size: number;
	assignments: Assignment[];
}

/**
 * The date and time assignments were stopped. Null if assignments are still allowed to be made.
 */
export type GetExperimentResponseStoppedAssignmentsAt = string | null;

/**
 * The reason assignments were stopped. Null if assignments are still allowed to be made.
 */
export type GetExperimentResponseStoppedAssignmentsReason =
	StopAssignmentReason | null;

export type GetExperimentResponsePowerAnalyses = PowerResponseOutput | null;

export type GetExperimentResponseAssignSummary = AssignSummary | null;

/**
 * An experiment configuration capturing all info at design time when assignment was made.
 */
export interface GetExperimentResponse {
	datasource_id: string;
	/** Current state of this experiment. */
	state: ExperimentState;
	/** The date and time assignments were stopped. Null if assignments are still allowed to be made. */
	stopped_assignments_at: GetExperimentResponseStoppedAssignmentsAt;
	/** The reason assignments were stopped. Null if assignments are still allowed to be made. */
	stopped_assignments_reason: GetExperimentResponseStoppedAssignmentsReason;
	design_spec: DesignSpecOutput;
	power_analyses: GetExperimentResponsePowerAnalyses;
	assign_summary: GetExperimentResponseAssignSummary;
	/** List of webhook IDs associated with this experiment. These webhooks are triggered when the experiment is committed. */
	webhooks?: string[];
}

/**
 * Sorted list of unique values.
 */
export type GetFiltersResponseDiscreteDistinctValues = string[] | null;

/**
 * Describes a discrete filter variable.
 */
export interface GetFiltersResponseDiscrete {
	/**
	 * Name of the field.
	 * @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$
	 */
	field_name: string;
	data_type: DataType;
	/**
	 * @minItems 1
	 * @maxItems 20
	 */
	relations: Relation[];
	/** @maxLength 2000 */
	description: string;
	/** Sorted list of unique values. */
	distinct_values: GetFiltersResponseDiscreteDistinctValues;
}

export type GetFiltersResponseElement =
	| GetFiltersResponseNumericOrDate
	| GetFiltersResponseDiscrete;

/**
 * The minimum observed value.
 */
export type GetFiltersResponseNumericOrDateMin =
	| string
	| string
	| number
	| number
	| null;

/**
 * The maximum observed value.
 */
export type GetFiltersResponseNumericOrDateMax =
	| string
	| string
	| number
	| number
	| null;

/**
 * Describes a numeric or date filter variable.
 */
export interface GetFiltersResponseNumericOrDate {
	/**
	 * Name of the field.
	 * @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$
	 */
	field_name: string;
	data_type: DataType;
	/**
	 * @minItems 1
	 * @maxItems 20
	 */
	relations: Relation[];
	/** @maxLength 2000 */
	description: string;
	/** The minimum observed value. */
	min: GetFiltersResponseNumericOrDateMin;
	/** The maximum observed value. */
	max: GetFiltersResponseNumericOrDateMax;
}

/**
 * Describes a metric.
 */
export interface GetMetricsResponseElement {
	/** @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$ */
	field_name: string;
	data_type: DataType;
	/** @maxLength 2000 */
	description: string;
}

export interface GetOrganizationResponse {
	/** @maxLength 64 */
	id: string;
	/** @maxLength 100 */
	name: string;
	users: UserSummary[];
	datasources: DatasourceSummary[];
}

/**
 * Null if no assignment. assignment.strata are not included.
 */
export type GetParticipantAssignmentResponseAssignment = Assignment | null;

/**
 * Describes assignment for a single <experiment, participant> pair.
 */
export interface GetParticipantAssignmentResponse {
	experiment_id: string;
	participant_id: string;
	/** Null if no assignment. assignment.strata are not included. */
	assignment: GetParticipantAssignmentResponseAssignment;
}

export type GetStrataResponseElementExtraAnyOf = { [key: string]: string };

export type GetStrataResponseElementExtra =
	GetStrataResponseElementExtraAnyOf | null;

/**
 * Describes a stratification variable.
 */
export interface GetStrataResponseElement {
	data_type: DataType;
	/** @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$ */
	field_name: string;
	/** @maxLength 2000 */
	description: string;
	extra?: GetStrataResponseElementExtra;
}

export interface HTTPExceptionError {
	detail: string;
}

export interface HTTPValidationError {
	detail?: ValidationError[];
}

export type HttpMethodTypes =
	(typeof HttpMethodTypes)[keyof typeof HttpMethodTypes];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HttpMethodTypes = {
	GET: "GET",
	POST: "POST",
	PUT: "PUT",
	PATCH: "PATCH",
	DELETE: "DELETE",
} as const;

export interface InspectDatasourceResponse {
	tables: string[];
}

/**
 * Describes a table in the datasource.
 */
export interface InspectDatasourceTableResponse {
	/** Fields that are possibly candidates for unique IDs. */
	detected_unique_id_fields: string[];
	/** Fields in the table. */
	fields: FieldMetadata[];
}

/**
 * Describes a participant type's strata, metrics, and filters (including exemplar values).
 */
export interface InspectParticipantTypesResponse {
	filters: GetFiltersResponseElement[];
	metrics: GetMetricsResponseElement[];
	strata: GetStrataResponseElement[];
}

/**
 * Enum for the likelihood distribution of the reward.
 */
export type LikelihoodTypes =
	(typeof LikelihoodTypes)[keyof typeof LikelihoodTypes];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LikelihoodTypes = {
	binary: "binary",
	"real-valued": "real-valued",
} as const;

export interface ListApiKeysResponse {
	items: ApiKeySummary[];
}

export interface ListDatasourcesResponse {
	items: DatasourceSummary[];
}

export interface ListExperimentsResponse {
	items: ExperimentConfig[];
}

export interface ListOrganizationEventsResponse {
	items: EventSummary[];
}

export interface ListOrganizationsResponse {
	items: OrganizationSummary[];
}

export interface ListParticipantsTypeResponse {
	items: ParticipantsConfig[];
}

export interface ListWebhooksResponse {
	items: WebhookSummary[];
}

/**
 * ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.
 */
export type MABExperimentSpecInputExperimentId = string | null;

export type MABExperimentSpecInputExperimentType =
	(typeof MABExperimentSpecInputExperimentType)[keyof typeof MABExperimentSpecInputExperimentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MABExperimentSpecInputExperimentType = {
	mab_online: "mab_online",
} as const;

/**
 * Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.
 */
export type MABExperimentSpecInputContexts = Context[] | null;

/**
 * Use this type to randomly assign participants into arms during live experiment execution with MAB experiments.

For example, you may wish to experiment on new users. Assignments are issued via API request.
 */
export interface MABExperimentSpecInput {
	/** @maxLength 100 */
	participant_type: string;
	/** ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. */
	experiment_id?: MABExperimentSpecInputExperimentId;
	experiment_type: MABExperimentSpecInputExperimentType;
	/** @maxLength 100 */
	experiment_name: string;
	/** @maxLength 2000 */
	description: string;
	start_date: string;
	end_date: string;
	/**
	 * @minItems 2
	 * @maxItems 10
	 */
	arms: ArmBandit[];
	/** Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments. */
	contexts?: MABExperimentSpecInputContexts;
	/** The type of prior distribution for the arms. */
	prior_type?: PriorTypes;
	/** The type of reward we observe from the experiment. */
	reward_type?: LikelihoodTypes;
}

/**
 * ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.
 */
export type MABExperimentSpecOutputExperimentId = string | null;

export type MABExperimentSpecOutputExperimentType =
	(typeof MABExperimentSpecOutputExperimentType)[keyof typeof MABExperimentSpecOutputExperimentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MABExperimentSpecOutputExperimentType = {
	mab_online: "mab_online",
} as const;

/**
 * Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments.
 */
export type MABExperimentSpecOutputContexts = Context[] | null;

/**
 * Use this type to randomly assign participants into arms during live experiment execution with MAB experiments.

For example, you may wish to experiment on new users. Assignments are issued via API request.
 */
export interface MABExperimentSpecOutput {
	/** @maxLength 100 */
	participant_type: string;
	/** ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. */
	experiment_id?: MABExperimentSpecOutputExperimentId;
	experiment_type: MABExperimentSpecOutputExperimentType;
	/** @maxLength 100 */
	experiment_name: string;
	/** @maxLength 2000 */
	description: string;
	start_date: string;
	end_date: string;
	/**
	 * @minItems 2
	 * @maxItems 10
	 */
	arms: ArmBandit[];
	/** Optional list of contexts that can be used to condition the bandit assignment. Required for contextual bandit experiments. */
	contexts?: MABExperimentSpecOutputContexts;
	/** The type of prior distribution for the arms. */
	prior_type?: PriorTypes;
	/** The type of reward we observe from the experiment. */
	reward_type?: LikelihoodTypes;
}

export type MetricAnalysisMetricName = string | null;

export type MetricAnalysisMetric = DesignSpecMetricRequest | null;

/**
 * Describes the change in a single metric for each arm of an experiment.
 */
export interface MetricAnalysis {
	metric_name?: MetricAnalysisMetricName;
	metric?: MetricAnalysisMetric;
	/** The results of the analysis for each arm (coefficient) for this specific metric. */
	arm_analyses: ArmAnalysis[];
}

/**
 * Minimum sample size needed to meet the design specs.
 */
export type MetricPowerAnalysisInputTargetN = number | null;

/**
 * Whether or not there are enough available units to sample from to meet target_n.
 */
export type MetricPowerAnalysisInputSufficientN = boolean | null;

/**
 * If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.
 */
export type MetricPowerAnalysisInputTargetPossible = number | null;

/**
 * If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.
 */
export type MetricPowerAnalysisInputPctChangePossible = number | null;

/**
 * Human friendly message about the above results.
 */
export type MetricPowerAnalysisInputMsg = MetricPowerAnalysisMessage | null;

/**
 * Describes analysis results of a single metric.
 */
export interface MetricPowerAnalysisInput {
	metric_spec: DesignSpecMetric;
	/** Minimum sample size needed to meet the design specs. */
	target_n?: MetricPowerAnalysisInputTargetN;
	/** Whether or not there are enough available units to sample from to meet target_n. */
	sufficient_n?: MetricPowerAnalysisInputSufficientN;
	/** If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change. */
	target_possible?: MetricPowerAnalysisInputTargetPossible;
	/** If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change. */
	pct_change_possible?: MetricPowerAnalysisInputPctChangePossible;
	/** Human friendly message about the above results. */
	msg?: MetricPowerAnalysisInputMsg;
}

/**
 * Minimum sample size needed to meet the design specs.
 */
export type MetricPowerAnalysisOutputTargetN = number | null;

/**
 * Whether or not there are enough available units to sample from to meet target_n.
 */
export type MetricPowerAnalysisOutputSufficientN = boolean | null;

/**
 * If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.
 */
export type MetricPowerAnalysisOutputTargetPossible = number | null;

/**
 * If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.
 */
export type MetricPowerAnalysisOutputPctChangePossible = number | null;

/**
 * Human friendly message about the above results.
 */
export type MetricPowerAnalysisOutputMsg = MetricPowerAnalysisMessage | null;

/**
 * Describes analysis results of a single metric.
 */
export interface MetricPowerAnalysisOutput {
	metric_spec: DesignSpecMetric;
	/** Minimum sample size needed to meet the design specs. */
	target_n?: MetricPowerAnalysisOutputTargetN;
	/** Whether or not there are enough available units to sample from to meet target_n. */
	sufficient_n?: MetricPowerAnalysisOutputSufficientN;
	/** If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change. */
	target_possible?: MetricPowerAnalysisOutputTargetPossible;
	/** If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change. */
	pct_change_possible?: MetricPowerAnalysisOutputPctChangePossible;
	/** Human friendly message about the above results. */
	msg?: MetricPowerAnalysisOutputMsg;
}

export type MetricPowerAnalysisMessageValuesAnyOf = {
	[key: string]: number | number;
};

export type MetricPowerAnalysisMessageValues =
	MetricPowerAnalysisMessageValuesAnyOf | null;

/**
 * Describes interpretation of power analysis results.
 */
export interface MetricPowerAnalysisMessage {
	type: MetricPowerAnalysisMessageType;
	/** Main power analysis result stated in human-friendly English. */
	msg: string;
	/** Power analysis result formatted as a template string with curly-braced {} named placeholders. Use with the dictionary of values to support localization of messages. */
	source_msg: string;
	values?: MetricPowerAnalysisMessageValues;
}

/**
 * Classifies metric power analysis results.
 */
export type MetricPowerAnalysisMessageType =
	(typeof MetricPowerAnalysisMessageType)[keyof typeof MetricPowerAnalysisMessageType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MetricPowerAnalysisMessageType = {
	sufficient: "sufficient",
	insufficient: "insufficient",
	no_baseline: "no baseline",
	no_available_n: "no available n",
	zero_effect_size: "zero effect size",
	zero_variation: "zero variation",
} as const;

/**
 * Classifies metrics by their value type.
 */
export type MetricType = (typeof MetricType)[keyof typeof MetricType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MetricType = {
	binary: "binary",
	numeric: "numeric",
} as const;

export type NoDwhDriver = (typeof NoDwhDriver)[keyof typeof NoDwhDriver];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NoDwhDriver = {
	none: "none",
} as const;

/**
 * NoDwh is used to indicate that no data warehouse is configured.
 */
export interface NoDwh {
	driver: NoDwhDriver;
}

/**
 * ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.
 */
export type OnlineFrequentistExperimentSpecInputExperimentId = string | null;

export type OnlineFrequentistExperimentSpecInputExperimentType =
	(typeof OnlineFrequentistExperimentSpecInputExperimentType)[keyof typeof OnlineFrequentistExperimentSpecInputExperimentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OnlineFrequentistExperimentSpecInputExperimentType = {
	freq_online: "freq_online",
} as const;

/**
 * Use this type to randomly assign participants into arms during live experiment execution with frequentist A/B experiments.

For example, you may wish to experiment on new users. Assignments are issued via API request.
 */
export interface OnlineFrequentistExperimentSpecInput {
	/** @maxLength 100 */
	participant_type: string;
	/** ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. */
	experiment_id?: OnlineFrequentistExperimentSpecInputExperimentId;
	experiment_type: OnlineFrequentistExperimentSpecInputExperimentType;
	/** @maxLength 100 */
	experiment_name: string;
	/** @maxLength 2000 */
	description: string;
	start_date: string;
	end_date: string;
	/**
	 * @minItems 2
	 * @maxItems 10
	 */
	arms: Arm[];
	/**
	 * Optional participant_type fields to use for stratified assignment.
	 * @maxItems 150
	 */
	strata: Stratum[];
	/**
	 * Primary and optional secondary metrics to target.
	 * @minItems 1
	 * @maxItems 150
	 */
	metrics: DesignSpecMetricRequest[];
	/**
	 * Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.
	 * @maxItems 20
	 */
	filters: FilterInput[];
	/**
	 * The chance of detecting a real non-null effect, i.e. 1 - false negative rate.
	 * @minimum 0
	 * @maximum 1
	 */
	power?: number;
	/**
	 * The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.
	 * @minimum 0
	 * @maximum 1
	 */
	alpha?: number;
	/**
	 * Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".
	 * @minimum 0
	 * @maximum 1
	 */
	fstat_thresh?: number;
}

/**
 * ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.
 */
export type OnlineFrequentistExperimentSpecOutputExperimentId = string | null;

export type OnlineFrequentistExperimentSpecOutputExperimentType =
	(typeof OnlineFrequentistExperimentSpecOutputExperimentType)[keyof typeof OnlineFrequentistExperimentSpecOutputExperimentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OnlineFrequentistExperimentSpecOutputExperimentType = {
	freq_online: "freq_online",
} as const;

/**
 * Use this type to randomly assign participants into arms during live experiment execution with frequentist A/B experiments.

For example, you may wish to experiment on new users. Assignments are issued via API request.
 */
export interface OnlineFrequentistExperimentSpecOutput {
	/** @maxLength 100 */
	participant_type: string;
	/** ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. */
	experiment_id?: OnlineFrequentistExperimentSpecOutputExperimentId;
	experiment_type: OnlineFrequentistExperimentSpecOutputExperimentType;
	/** @maxLength 100 */
	experiment_name: string;
	/** @maxLength 2000 */
	description: string;
	start_date: string;
	end_date: string;
	/**
	 * @minItems 2
	 * @maxItems 10
	 */
	arms: Arm[];
	/**
	 * Optional participant_type fields to use for stratified assignment.
	 * @maxItems 150
	 */
	strata: Stratum[];
	/**
	 * Primary and optional secondary metrics to target.
	 * @minItems 1
	 * @maxItems 150
	 */
	metrics: DesignSpecMetricRequest[];
	/**
	 * Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.
	 * @maxItems 20
	 */
	filters: FilterOutput[];
	/**
	 * The chance of detecting a real non-null effect, i.e. 1 - false negative rate.
	 * @minimum 0
	 * @maximum 1
	 */
	power?: number;
	/**
	 * The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.
	 * @minimum 0
	 * @maximum 1
	 */
	alpha?: number;
	/**
	 * Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".
	 * @minimum 0
	 * @maximum 1
	 */
	fstat_thresh?: number;
}

export interface OrganizationSummary {
	/** @maxLength 64 */
	id: string;
	/** @maxLength 100 */
	name: string;
}

export type ParticipantsConfig = ParticipantsDef;

export type ParticipantsDefType =
	(typeof ParticipantsDefType)[keyof typeof ParticipantsDefType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ParticipantsDefType = {
	schema: "schema",
} as const;

export interface ParticipantsDef {
	/** Name of the table in the data warehouse */
	table_name: string;
	/** List of fields available in this table */
	fields: FieldDescriptor[];
	/** The name of the set of participants defined by the filters. This name must be unique within a datasource. */
	participant_type: string;
	type: ParticipantsDefType;
}

/**
 * Represents a single worksheet describing metadata about a type of Participant.
 */
export interface ParticipantsSchemaInput {
	/** Name of the table in the data warehouse */
	table_name: string;
	/** List of fields available in this table */
	fields: FieldDescriptor[];
}

/**
 * Represents a single worksheet describing metadata about a type of Participant.
 */
export interface ParticipantsSchemaOutput {
	/** Name of the table in the data warehouse */
	table_name: string;
	/** List of fields available in this table */
	fields: FieldDescriptor[];
}

export interface PowerRequest {
	design_spec: DesignSpecInput;
}

export interface PowerResponseInput {
	/** @maxItems 150 */
	analyses: MetricPowerAnalysisInput[];
}

export interface PowerResponseOutput {
	/** @maxItems 150 */
	analyses: MetricPowerAnalysisOutput[];
}

/**
 * ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.
 */
export type PreassignedFrequentistExperimentSpecInputExperimentId =
	| string
	| null;

export type PreassignedFrequentistExperimentSpecInputExperimentType =
	(typeof PreassignedFrequentistExperimentSpecInputExperimentType)[keyof typeof PreassignedFrequentistExperimentSpecInputExperimentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PreassignedFrequentistExperimentSpecInputExperimentType = {
	freq_preassigned: "freq_preassigned",
} as const;

/**
 * Use this type to randomly select and assign from existing participants at design time with frequentist A/B experiments.
 */
export interface PreassignedFrequentistExperimentSpecInput {
	/** @maxLength 100 */
	participant_type: string;
	/** ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. */
	experiment_id?: PreassignedFrequentistExperimentSpecInputExperimentId;
	experiment_type: PreassignedFrequentistExperimentSpecInputExperimentType;
	/** @maxLength 100 */
	experiment_name: string;
	/** @maxLength 2000 */
	description: string;
	start_date: string;
	end_date: string;
	/**
	 * @minItems 2
	 * @maxItems 10
	 */
	arms: Arm[];
	/**
	 * Optional participant_type fields to use for stratified assignment.
	 * @maxItems 150
	 */
	strata: Stratum[];
	/**
	 * Primary and optional secondary metrics to target.
	 * @minItems 1
	 * @maxItems 150
	 */
	metrics: DesignSpecMetricRequest[];
	/**
	 * Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.
	 * @maxItems 20
	 */
	filters: FilterInput[];
	/**
	 * The chance of detecting a real non-null effect, i.e. 1 - false negative rate.
	 * @minimum 0
	 * @maximum 1
	 */
	power?: number;
	/**
	 * The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.
	 * @minimum 0
	 * @maximum 1
	 */
	alpha?: number;
	/**
	 * Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".
	 * @minimum 0
	 * @maximum 1
	 */
	fstat_thresh?: number;
}

/**
 * ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.
 */
export type PreassignedFrequentistExperimentSpecOutputExperimentId =
	| string
	| null;

export type PreassignedFrequentistExperimentSpecOutputExperimentType =
	(typeof PreassignedFrequentistExperimentSpecOutputExperimentType)[keyof typeof PreassignedFrequentistExperimentSpecOutputExperimentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PreassignedFrequentistExperimentSpecOutputExperimentType = {
	freq_preassigned: "freq_preassigned",
} as const;

/**
 * Use this type to randomly select and assign from existing participants at design time with frequentist A/B experiments.
 */
export interface PreassignedFrequentistExperimentSpecOutput {
	/** @maxLength 100 */
	participant_type: string;
	/** ID of the experiment. If creating a new experiment (POST /datasources/{datasource_id}/experiments), this is generated for you and made available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. */
	experiment_id?: PreassignedFrequentistExperimentSpecOutputExperimentId;
	experiment_type: PreassignedFrequentistExperimentSpecOutputExperimentType;
	/** @maxLength 100 */
	experiment_name: string;
	/** @maxLength 2000 */
	description: string;
	start_date: string;
	end_date: string;
	/**
	 * @minItems 2
	 * @maxItems 10
	 */
	arms: Arm[];
	/**
	 * Optional participant_type fields to use for stratified assignment.
	 * @maxItems 150
	 */
	strata: Stratum[];
	/**
	 * Primary and optional secondary metrics to target.
	 * @minItems 1
	 * @maxItems 150
	 */
	metrics: DesignSpecMetricRequest[];
	/**
	 * Optional filters that constrain a general participant_type to a specific subset who can participate in an experiment.
	 * @maxItems 20
	 */
	filters: FilterOutput[];
	/**
	 * The chance of detecting a real non-null effect, i.e. 1 - false negative rate.
	 * @minimum 0
	 * @maximum 1
	 */
	power?: number;
	/**
	 * The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.
	 * @minimum 0
	 * @maximum 1
	 */
	alpha?: number;
	/**
	 * Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".
	 * @minimum 0
	 * @maximum 1
	 */
	fstat_thresh?: number;
}

/**
 * Enum for the prior distribution of the arm.
 */
export type PriorTypes = (typeof PriorTypes)[keyof typeof PriorTypes];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PriorTypes = {
	beta: "beta",
	normal: "normal",
} as const;

/**
 * Defines operators for filtering values.

INCLUDES matches when the value matches any of the provided values, including null if explicitly
specified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided
values will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).

EXCLUDES matches when the value does not match any of the provided values, including null if
explicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV
fields (i.e. experiment_ids), the match will fail if any of the provided values are present
in the value, but nulls are unsupported.

BETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.
 */
export type Relation = (typeof Relation)[keyof typeof Relation];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Relation = {
	includes: "includes",
	excludes: "excludes",
	between: "between",
} as const;

/**
 * The reason assignments were stopped.
 */
export type StopAssignmentReason =
	(typeof StopAssignmentReason)[keyof typeof StopAssignmentReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StopAssignmentReason = {
	preassigned: "preassigned",
	end_date: "end_date",
	manual: "manual",
	target_n: "target_n",
} as const;

export type StrataStrataValue = string | null;

/**
 * Describes stratification for an experiment participant.
 */
export interface Strata {
	/** @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$ */
	field_name: string;
	strata_value?: StrataStrataValue;
}

/**
 * Describes a variable used for stratification.
 */
export interface Stratum {
	/** @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$ */
	field_name: string;
}

export type StrictFloat = number | null;

export type StrictInt = number | null;

/**
 * Describes the outcome of a bandit experiment.
 */
export interface UpdateBanditArmOutcomeRequest {
	participant_id: string;
	outcome: number;
}

export type UpdateDatasourceRequestName = string | null;

export type UpdateDatasourceRequestDwh = DwhInput | null;

export interface UpdateDatasourceRequest {
	name?: UpdateDatasourceRequestName;
	dwh?: UpdateDatasourceRequestDwh;
}

export type UpdateOrganizationRequestName = string | null;

export interface UpdateOrganizationRequest {
	name?: UpdateOrganizationRequestName;
}

/**
 * Request to update a webhook's name and URL.
 */
export interface UpdateOrganizationWebhookRequest {
	/**
	 * User-friendly name for the webhook. This name is displayed in the UI and helps identify the webhook's purpose.
	 * @maxLength 100
	 */
	name: string;
	/**
	 * The HTTP or HTTPS URL that will receive webhook notifications when events occur.
	 * @maxLength 500
	 */
	url: string;
}

export type UpdateParticipantsTypeRequestParticipantType = string | null;

export type UpdateParticipantsTypeRequestTableName = string | null;

export type UpdateParticipantsTypeRequestFields = FieldDescriptor[] | null;

export interface UpdateParticipantsTypeRequest {
	participant_type?: UpdateParticipantsTypeRequestParticipantType;
	table_name?: UpdateParticipantsTypeRequestTableName;
	fields?: UpdateParticipantsTypeRequestFields;
}

export type UpdateParticipantsTypeResponseTableName = string | null;

export type UpdateParticipantsTypeResponseFields = FieldDescriptor[] | null;

export interface UpdateParticipantsTypeResponse {
	/** @maxLength 100 */
	participant_type: string;
	table_name?: UpdateParticipantsTypeResponseTableName;
	fields?: UpdateParticipantsTypeResponseFields;
}

export interface UserSummary {
	/** @maxLength 64 */
	id: string;
	/** @maxLength 64 */
	email: string;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
	loc: ValidationErrorLocItem[];
	msg: string;
	type: string;
}

export type WebhookActionsCommit = WebhookUrl | null;

/**
 * The set of supported actions that trigger a user callback.
 */
export interface WebhookActions {
	commit?: WebhookActionsCommit;
}

export type WebhookCommonHeadersAuthorization = string | null;

/**
 * Enumerates supported headers to attach to all webhook requests.
 */
export interface WebhookCommonHeaders {
	authorization: WebhookCommonHeadersAuthorization;
}

/**
 * Top-level configuration object for user-defined webhooks.
 */
export interface WebhookConfig {
	actions: WebhookActions;
	common_headers: WebhookCommonHeaders;
}

/**
 * The value of the Webhook-Token: header that will be sent with the request to the configured URL.
 */
export type WebhookSummaryAuthToken = string | null;

/**
 * Summarizes a Webhook configuration for an organization.
 */
export interface WebhookSummary {
	/** The ID of the webhook. */
	id: string;
	/** The type of webhook; e.g. experiment.created */
	type: string;
	/** User-friendly name for the webhook. */
	name: string;
	/** The URL to notify. */
	url: string;
	/** The value of the Webhook-Token: header that will be sent with the request to the configured URL. */
	auth_token: WebhookSummaryAuthToken;
}

/**
 * Represents a url and HTTP method to use with it.
 */
export interface WebhookUrl {
	method: HttpMethodTypes;
	url: string;
}

export type DeleteWebhookFromOrganizationParams = {
	/**
	 * If true, return a 204 even if the resource does not exist.
	 */
	allow_missing?: boolean;
};

export type InspectDatasourceParams = {
	/**
	 * Refresh the cache.
	 */
	refresh?: boolean;
};

export type InspectTableInDatasourceParams = {
	/**
	 * Refresh the cache.
	 */
	refresh?: boolean;
};

export type DeleteDatasourceParams = {
	/**
	 * If true, return a 204 even if the resource does not exist.
	 */
	allow_missing?: boolean;
};

export type InspectParticipantTypesParams = {
	/**
	 * Refresh the cache.
	 */
	refresh?: boolean;
};

export type DeleteParticipantParams = {
	/**
	 * If true, return a 204 even if the resource does not exist.
	 */
	allow_missing?: boolean;
};

export type DeleteApiKeyParams = {
	/**
	 * If true, return a 204 even if the resource does not exist.
	 */
	allow_missing?: boolean;
};

export type CreateExperimentParams = {
	/**
	 * Number of participants to assign.
	 */
	chosen_n?: number | null;
	/**
	 * Whether to also stratify on metrics during assignment.
	 */
	stratify_on_metrics?: boolean;
};

export type AnalyzeExperimentParams = {
	/**
	 * UUID of the baseline arm. If None, the first design spec arm is used.
	 */
	baseline_arm_id?: string | null;
};

export type AnalyzeExperiment200 =
	| FreqExperimentAnalysisResponse
	| BanditExperimentAnalysisResponse;

export type DeleteExperimentParams = {
	/**
	 * If true, return a 204 even if the resource does not exist.
	 */
	allow_missing?: boolean;
};

export type GetExperimentAssignmentForParticipantParams = {
	/**
	 * Create an assignment if none exists. Does nothing for preassigned experiments. Override if you just want to check if an assignment exists.
	 */
	create_if_none?: boolean;
};
