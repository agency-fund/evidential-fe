/**
 * Generated by orval v7.6.0 üç∫
 * Do not edit manually.
 * xngin: Experiments API
 * OpenAPI spec version: 0.9.0
 */
export interface AddMemberToOrganizationRequest {
	email: string;
}

export interface ApiKeySummary {
	id: string;
	datasource_id: string;
	organization_id: string;
	organization_name: string;
}

/**
 * UUID of the arm. If using the /experiments/with-assignment endpoint, this is generated for you and available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.
 */
export type ArmArmId = string | null;

export type ArmArmDescription = string | null;

/**
 * Describes an experiment treatment arm.
 */
export interface Arm {
	/** UUID of the arm. If using the /experiments/with-assignment endpoint, this is generated for you and available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. */
	arm_id: ArmArmId;
	arm_name: string;
	arm_description?: ArmArmDescription;
}

export interface ArmUpdate {
	/**
	 * New experiment arm name to be updated.
	 * @minLength 1
	 */
	arm_name: string;
	/** The id originally assigned to this arm by the user. */
	arm_id: string;
}

export interface AssignRequest {
	design_spec: DesignSpec;
	audience_spec: AudienceSpecInput;
}

/**
 * Describes assignments for all participants and balance test results.
 */
export interface AssignResponseInput {
	balance_check: BalanceCheck;
	experiment_id: string;
	sample_size: number;
	/** Name of the datasource field used as the unique identifier for the participant_id value stored in each Assignment, as configured in the datasource settings. Included for frontend convenience. */
	unique_id_field: string;
	assignments: Assignment[];
}

/**
 * Describes assignments for all participants and balance test results.
 */
export interface AssignResponseOutput {
	balance_check: BalanceCheck;
	experiment_id: string;
	sample_size: number;
	/** Name of the datasource field used as the unique identifier for the participant_id value stored in each Assignment, as configured in the datasource settings. Included for frontend convenience. */
	unique_id_field: string;
	assignments: Assignment[];
}

/**
 * Key pieces of an AssignResponse without the assignments.
 */
export interface AssignSummary {
	balance_check: BalanceCheck;
	sample_size: number;
}

/**
 * Describes treatment assignment for an experiment participant.
 */
export interface Assignment {
	participant_id: string;
	/** UUID of the arm this participant was assigned to. Same as Arm.arm_id. */
	arm_id: string;
	/** The arm this participant was assigned to. Same as Arm.arm_name. */
	arm_name: string;
	/** List of properties and their values for this participant used for stratification or tracking metrics. */
	strata: Strata[];
}

/**
 * Defines target participants for an experiment using filters.
 */
export interface AudienceSpecInput {
	participant_type: string;
	filters: AudienceSpecFilter[];
}

/**
 * Defines target participants for an experiment using filters.
 */
export interface AudienceSpecOutput {
	participant_type: string;
	filters: AudienceSpecFilter[];
}

/**
 * Defines criteria for filtering rows by value.

## Examples

| Relation | Value       | logical Result                                    |
|----------|-------------|---------------------------------------------------|
| INCLUDES | [None]      | Match when `x IS NULL`                            |
| INCLUDES | ["a"]       | Match when `x IN ("a")`                           |
| INCLUDES | ["a", None] | Match when `x IS NULL OR x IN ("a")`              |
| INCLUDES | ["a", "b"]  | Match when `x IN ("a", "b")`                      |
| EXCLUDES | [None]      | Match `x IS NOT NULL`                             |
| EXCLUDES | ["a", None] | Match `x IS NOT NULL AND x NOT IN ("a")`          |
| EXCLUDES | ["a", "b"]  | Match `x IS NULL OR (x NOT IN ("a", "b"))`        |
| BETWEEN  | ["a", "z"]  | Match `"a" <= x <= "z"`                           |
| BETWEEN  | ["a", None] | Match `x >= "a"`                                  |

String comparisons are case-sensitive.

## Special Handling for Comma-Separated Fields

When the filter name ends in "experiment_ids", the filter is interpreted as follows:

| Value | Filter         | Result   |
|-------|----------------|----------|
| "a,b" | INCLUDES ["a"] | Match    |
| "a,b" | INCLUDES ["d"] | No match |
| "a,b" | EXCLUDES ["d"] | Match    |
| "a,b" | EXCLUDES ["b"] | No match |

Note: The BETWEEN relation is not supported for comma-separated values.

Note: CSV field comparisons are case-insensitive.

## Handling of datetime and timestamp values

DATETIME or TIMESTAMP-type columns support INCLUDES/EXCLUDES/BETWEEN, similar to numerics.

Values must be expressed as ISO8601 datetime strings compatible with Python's datetime.fromisoformat()
(https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat).

If a timezone is provided, it must be UTC.
 */
export interface AudienceSpecFilter {
	/** @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$ */
	field_name: string;
	relation: Relation;
	value: FilterValueTypes;
}

/**
 * Describes balance test results for treatment assignment.
 */
export interface BalanceCheck {
	f_statistic: number;
	numerator_df: number;
	denominator_df: number;
	p_value: number;
	balance_ok: boolean;
}

export type BqDsnInputDriver =
	(typeof BqDsnInputDriver)[keyof typeof BqDsnInputDriver];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BqDsnInputDriver = {
	bigquery: "bigquery",
} as const;

/**
 * Describes a BigQuery connection.
 */
export interface BqDsnInput {
	driver: BqDsnInputDriver;
	/** The Google Cloud Project ID containing the dataset. */
	project_id: string;
	/** The dataset name. */
	dataset_id: string;
	credentials: GcpCredentials;
}

export type BqDsnOutputDriver =
	(typeof BqDsnOutputDriver)[keyof typeof BqDsnOutputDriver];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BqDsnOutputDriver = {
	bigquery: "bigquery",
} as const;

/**
 * Describes a BigQuery connection.
 */
export interface BqDsnOutput {
	driver: BqDsnOutputDriver;
	/** The Google Cloud Project ID containing the dataset. */
	project_id: string;
	/** The dataset name. */
	dataset_id: string;
	credentials: GcpCredentials;
}

/**
 * The credentials returned to the SPA.
 */
export interface CallbackResponse {
	/** The ID token as generated by Google. Represents a successful authentication. */
	id_token: string;
}

/**
 * Optionally include the power analyses of your tracking metrics if performed.
 */
export type CommitRequestPowerAnalyses = PowerResponseInput | null;

/**
 * The complete experiment configuration to persist in an experiment registry.
 */
export interface CommitRequest {
	design_spec: DesignSpec;
	audience_spec: AudienceSpecInput;
	/** Optionally include the power analyses of your tracking metrics if performed. */
	power_analyses?: CommitRequestPowerAnalyses;
	experiment_assignment: AssignResponseInput;
}

export interface CreateApiKeyRequest {
	datasource_id: string;
}

export interface CreateApiKeyResponse {
	id: string;
	datasource_id: string;
	key: string;
}

export interface CreateDatasourceRequest {
	organization_id: string;
	name: string;
	dwh: DwhInput;
}

export interface CreateDatasourceResponse {
	id: string;
}

export type CreateExperimentRequestPowerAnalyses = PowerResponseInput | null;

export interface CreateExperimentRequest {
	design_spec: DesignSpec;
	audience_spec: AudienceSpecInput;
	power_analyses?: CreateExperimentRequestPowerAnalyses;
}

export type CreateExperimentWithAssignmentResponsePowerAnalyses =
	PowerResponseOutput | null;

/**
 * Same as the request but with uuids filled for the experiment and arms, and summary info on the assignment.
 */
export interface CreateExperimentWithAssignmentResponse {
	datasource_id: string;
	/** Current state of this experiment. */
	state: ExperimentState;
	design_spec: DesignSpec;
	audience_spec: AudienceSpecOutput;
	power_analyses: CreateExperimentWithAssignmentResponsePowerAnalyses;
	assign_summary: AssignSummary;
}

export interface CreateOrganizationRequest {
	name: string;
}

export interface CreateOrganizationResponse {
	id: string;
}

export interface CreateParticipantsTypeRequest {
	participant_type: string;
	schema_def: ParticipantsSchemaInput;
}

export interface CreateParticipantsTypeResponse {
	participant_type: string;
	schema_def: ParticipantsSchemaOutput;
}

/**
 * Defines the supported data types for fields in the data source.
 */
export type DataType = (typeof DataType)[keyof typeof DataType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DataType = {
	boolean: "boolean",
	character_varying: "character varying",
	date: "date",
	integer: "integer",
	double_precision: "double precision",
	numeric: "numeric",
	timestamp_without_time_zone: "timestamp without time zone",
	bigint: "bigint",
} as const;

export type DatasourceConfig = RemoteDatabaseConfig | SqliteLocalConfig;

export interface DatasourceSummary {
	id: string;
	name: string;
	driver: string;
	type: string;
	organization_id: string;
	organization_name: string;
}

/**
 * UUID of the experiment. If using the /experiments/with-assignment endpoint, this is generated for you and available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence.
 */
export type DesignSpecExperimentId = string | null;

/**
 * Experiment design parameters for power calculations and treatment assignment.
 */
export interface DesignSpec {
	/** UUID of the experiment. If using the /experiments/with-assignment endpoint, this is generated for you and available in the response; you should NOT set this. Only generate ids of your own if using the stateless Experiment Design API as you will do your own persistence. */
	experiment_id: DesignSpecExperimentId;
	experiment_name: string;
	description: string;
	start_date: string;
	end_date: string;
	/** @minItems 2 */
	arms: Arm[];
	strata_field_names: string[];
	/**
	 * Primary and optional secondary metrics to target.
	 * @minItems 1
	 */
	metrics: DesignSpecMetricRequest[];
	/**
	 * The chance of detecting a real non-null effect, i.e. 1 - false negative rate.
	 * @minimum 0
	 * @maximum 1
	 */
	power?: number;
	/**
	 * The chance of a false positive, i.e. there is no real non-null effect, but we mistakenly think there is one.
	 * @minimum 0
	 * @maximum 1
	 */
	alpha?: number;
	/**
	 * Threshold on the p-value of joint significance in doing the omnibus balance check, above which we declare the data to be "balanced".
	 * @minimum 0
	 * @maximum 1
	 */
	fstat_thresh?: number;
}

/**
 * Percent change target relative to the metric_baseline.
 */
export type DesignSpecMetricMetricPctChange = number | null;

/**
 * Absolute target value = metric_baseline*(1 + metric_pct_change)
 */
export type DesignSpecMetricMetricTarget = number | null;

/**
 * Inferred from dwh type.
 */
export type DesignSpecMetricMetricType = MetricType | null;

/**
 * Mean of the tracked metric.
 */
export type DesignSpecMetricMetricBaseline = number | null;

/**
 * Standard deviation is set only for metric_type.NUMERIC metrics.
 */
export type DesignSpecMetricMetricStddev = number | null;

/**
 * The number of participants meeting the filtering criteria with a *non-null* value for this metric.
 */
export type DesignSpecMetricAvailableNonnullN = number | null;

/**
 * The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n.
 */
export type DesignSpecMetricAvailableN = number | null;

/**
 * Defines a metric to measure in an experiment with its baseline stats.
 */
export interface DesignSpecMetric {
	/** @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$ */
	field_name: string;
	/** Percent change target relative to the metric_baseline. */
	metric_pct_change?: DesignSpecMetricMetricPctChange;
	/** Absolute target value = metric_baseline*(1 + metric_pct_change) */
	metric_target?: DesignSpecMetricMetricTarget;
	/** Inferred from dwh type. */
	metric_type?: DesignSpecMetricMetricType;
	/** Mean of the tracked metric. */
	metric_baseline?: DesignSpecMetricMetricBaseline;
	/** Standard deviation is set only for metric_type.NUMERIC metrics. */
	metric_stddev?: DesignSpecMetricMetricStddev;
	/** The number of participants meeting the filtering criteria with a *non-null* value for this metric. */
	available_nonnull_n?: DesignSpecMetricAvailableNonnullN;
	/** The number of participants meeting the filtering criteria regardless of whether or not this metric's value is NULL. NOTE: Assignments are made from the targeted aviailable_n population, so be sure you are ok with participants potentially having this value missing during assignment if available_n != available_nonnull_n. */
	available_n?: DesignSpecMetricAvailableN;
}

/**
 * Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target.
 */
export type DesignSpecMetricRequestMetricPctChange = number | null;

/**
 * Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change.
 */
export type DesignSpecMetricRequestMetricTarget = number | null;

/**
 * Defines a request to look up baseline stats for a metric to measure in an experiment.
 */
export interface DesignSpecMetricRequest {
	/** @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$ */
	field_name: string;
	/** Specify a meaningful min percent change relative to the metric_baseline you want to detect. Cannot be set if you set metric_target. */
	metric_pct_change?: DesignSpecMetricRequestMetricPctChange;
	/** Specify the absolute value you want to detect. Cannot be set if you set metric_pct_change. */
	metric_target?: DesignSpecMetricRequestMetricTarget;
}

export type DsnDriver = (typeof DsnDriver)[keyof typeof DsnDriver];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DsnDriver = {
	"postgresql+psycopg": "postgresql+psycopg",
	"postgresql+psycopg2": "postgresql+psycopg2",
} as const;

export type DsnSslmode =
	| "disable"
	| "allow"
	| "prefer"
	| "require"
	| "verify-ca"
	| "verify-full"
	| null;

export type DsnSearchPath = string | null;

/**
 * Describes a set of parameters suitable for connecting to most types of remote databases.
 */
export interface Dsn {
	driver: DsnDriver;
	host: string;
	/**
	 * @minimum 1024
	 * @maximum 65535
	 */
	port?: number;
	user: string;
	password: string;
	dbname: string;
	sslmode?: DsnSslmode;
	search_path?: DsnSearchPath;
}

export type DwhInput = Dsn | BqDsnInput;

export type DwhOutput = Dsn | BqDsnOutput;

export type ExperimentConfigPowerAnalyses = PowerResponseOutput | null;

/**
 * Representation of our stored Experiment information.
 */
export interface ExperimentConfig {
	datasource_id: string;
	/** Current state of this experiment. */
	state: ExperimentState;
	design_spec: DesignSpec;
	audience_spec: AudienceSpecOutput;
	power_analyses: ExperimentConfigPowerAnalyses;
	assign_summary: AssignSummary;
}

/**
 * Experiment lifecycle states.

note: [starting state], [[terminal state]]
[DESIGNING]->[ASSIGNED]->{[[ABANDONED]], COMMITTED}->[[ABORTED]]
 */
export type ExperimentState =
	(typeof ExperimentState)[keyof typeof ExperimentState];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ExperimentState = {
	designing: "designing",
	assigned: "assigned",
	abandoned: "abandoned",
	committed: "committed",
	aborted: "aborted",
} as const;

export type FieldDescriptorExtraAnyOf = { [key: string]: string };

/**
 * Additional field metadata
 */
export type FieldDescriptorExtra = FieldDescriptorExtraAnyOf | null;

export interface FieldDescriptor {
	/** Name of the field in the data source */
	field_name: string;
	/** The data type of this field */
	data_type: DataType;
	/** Human-readable description of the field */
	description: string;
	/** Whether this field uniquely identifies records */
	is_unique_id: boolean;
	/** Whether this field should be used for stratification */
	is_strata: boolean;
	/** Whether this field can be used as a filter */
	is_filter: boolean;
	/** Whether this field can be used as a metric */
	is_metric: boolean;
	/** Additional field metadata */
	extra?: FieldDescriptorExtra;
}

/**
 * Concise summary of fields in the table.
 */
export interface FieldMetadata {
	field_name: string;
	data_type: DataType;
	description: string;
}

export type FilterValueTypesAnyOfItem = number | null;

export type FilterValueTypesAnyOfTwoItem = number | null;

export type FilterValueTypesAnyOfThreeItem = string | null;

export type FilterValueTypesAnyOfFourItem = boolean | null;

export type FilterValueTypes =
	| FilterValueTypesAnyOfItem[]
	| FilterValueTypesAnyOfTwoItem[]
	| FilterValueTypesAnyOfThreeItem[]
	| FilterValueTypesAnyOfFourItem[];

export type GcpCredentials = GcpServiceAccountInfo | GcpServiceAccountFile;

export type GcpServiceAccountFileType =
	(typeof GcpServiceAccountFileType)[keyof typeof GcpServiceAccountFileType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GcpServiceAccountFileType = {
	serviceaccountfile: "serviceaccountfile",
} as const;

/**
 * Describes a file path to a Google Cloud Service Account credential file.
 */
export interface GcpServiceAccountFile {
	type: GcpServiceAccountFileType;
	/** The path to the service account credentials file containing the credentials in canonical JSON form. */
	path: string;
}

export type GcpServiceAccountInfoType =
	(typeof GcpServiceAccountInfoType)[keyof typeof GcpServiceAccountInfoType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GcpServiceAccountInfoType = {
	serviceaccountinfo: "serviceaccountinfo",
} as const;

/**
 * Describes a Google Cloud Service Account credential.
 */
export interface GcpServiceAccountInfo {
	type: GcpServiceAccountInfoType;
	/** The base64-encoded service account info in the canonical JSON form. */
	content_base64: string;
}

export interface GetDatasourceResponse {
	id: string;
	name: string;
	config: DatasourceConfig;
	organization_id: string;
	organization_name: string;
}

/**
 * Describes assignments for all participants and balance test results.
 */
export interface GetExperimentAssigmentsResponse {
	balance_check: BalanceCheck;
	experiment_id: string;
	sample_size: number;
	assignments: Assignment[];
}

export type GetExperimentResponsePowerAnalyses = PowerResponseOutput | null;

/**
 * An experiment configuration capturing all info at design time when assignment was made.
 */
export interface GetExperimentResponse {
	datasource_id: string;
	/** Current state of this experiment. */
	state: ExperimentState;
	design_spec: DesignSpec;
	audience_spec: AudienceSpecOutput;
	power_analyses: GetExperimentResponsePowerAnalyses;
	assign_summary: AssignSummary;
}

/**
 * Response model for the /filters endpoint.
 */
export interface GetFiltersResponse {
	results: GetFiltersResponseElement[];
}

/**
 * Sorted list of unique values.
 */
export type GetFiltersResponseDiscreteDistinctValues = string[] | null;

/**
 * Describes a discrete filter variable.
 */
export interface GetFiltersResponseDiscrete {
	/**
	 * Name of the field.
	 * @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$
	 */
	field_name: string;
	data_type: DataType;
	/** @minItems 1 */
	relations: Relation[];
	description: string;
	/** Sorted list of unique values. */
	distinct_values: GetFiltersResponseDiscreteDistinctValues;
}

export type GetFiltersResponseElement =
	| GetFiltersResponseNumericOrDate
	| GetFiltersResponseDiscrete;

/**
 * The minimum observed value.
 */
export type GetFiltersResponseNumericOrDateMin =
	| string
	| string
	| number
	| number
	| null;

/**
 * The maximum observed value.
 */
export type GetFiltersResponseNumericOrDateMax =
	| string
	| string
	| number
	| number
	| null;

/**
 * Describes a numeric or date filter variable.
 */
export interface GetFiltersResponseNumericOrDate {
	/**
	 * Name of the field.
	 * @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$
	 */
	field_name: string;
	data_type: DataType;
	/** @minItems 1 */
	relations: Relation[];
	description: string;
	/** The minimum observed value. */
	min: GetFiltersResponseNumericOrDateMin;
	/** The maximum observed value. */
	max: GetFiltersResponseNumericOrDateMax;
}

/**
 * Response model for the /metrics endpoint.
 */
export interface GetMetricsResponse {
	results: GetMetricsResponseElement[];
}

/**
 * Describes a metric.
 */
export interface GetMetricsResponseElement {
	/** @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$ */
	field_name: string;
	data_type: DataType;
	description: string;
}

export interface GetOrganizationResponse {
	id: string;
	name: string;
	users: UserSummary[];
	datasources: DatasourceSummary[];
}

/**
 * Response model for the /strata endpoint.
 */
export interface GetStrataResponse {
	results: GetStrataResponseElement[];
}

export type GetStrataResponseElementExtraAnyOf = { [key: string]: string };

export type GetStrataResponseElementExtra =
	GetStrataResponseElementExtraAnyOf | null;

/**
 * Describes a stratification variable.
 */
export interface GetStrataResponseElement {
	data_type: DataType;
	/** @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$ */
	field_name: string;
	description: string;
	extra?: GetStrataResponseElementExtra;
}

export interface HTTPValidationError {
	detail?: ValidationError[];
}

export type HttpMethodTypes =
	(typeof HttpMethodTypes)[keyof typeof HttpMethodTypes];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HttpMethodTypes = {
	GET: "GET",
	POST: "POST",
	PUT: "PUT",
	PATCH: "PATCH",
	DELETE: "DELETE",
} as const;

export interface InspectDatasourceResponse {
	tables: string[];
}

/**
 * Describes a table in the datasource.
 */
export interface InspectDatasourceTableResponse {
	/** Fields that are possibly candidates for unique IDs. */
	detected_unique_id_fields: string[];
	/** Fields in the table. */
	fields: FieldMetadata[];
}

/**
 * Describes a participant type's strata, metrics, and filters (including exemplar values).
 */
export interface InspectParticipantTypesResponse {
	filters: GetFiltersResponseElement[];
	metrics: GetMetricsResponseElement[];
	strata: GetStrataResponseElement[];
}

export interface ListApiKeysResponse {
	items: ApiKeySummary[];
}

export interface ListDatasourcesResponse {
	items: DatasourceSummary[];
}

export interface ListExperimentsResponse {
	items: ExperimentConfig[];
}

export interface ListOrganizationsResponse {
	items: OrganizationSummary[];
}

export interface ListParticipantsTypeResponse {
	items: ParticipantsConfig[];
}

/**
 * Minimum sample size needed to meet the design specs.
 */
export type MetricAnalysisInputTargetN = number | null;

/**
 * Whether or not there are enough available units to sample from to meet target_n.
 */
export type MetricAnalysisInputSufficientN = boolean | null;

/**
 * If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.
 */
export type MetricAnalysisInputTargetPossible = number | null;

/**
 * If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.
 */
export type MetricAnalysisInputPctChangePossible = number | null;

/**
 * Human friendly message about the above results.
 */
export type MetricAnalysisInputMsg = MetricAnalysisMessage | null;

/**
 * Describes analysis results of a single metric.
 */
export interface MetricAnalysisInput {
	metric_spec: DesignSpecMetric;
	/** Minimum sample size needed to meet the design specs. */
	target_n?: MetricAnalysisInputTargetN;
	/** Whether or not there are enough available units to sample from to meet target_n. */
	sufficient_n?: MetricAnalysisInputSufficientN;
	/** If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change. */
	target_possible?: MetricAnalysisInputTargetPossible;
	/** If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change. */
	pct_change_possible?: MetricAnalysisInputPctChangePossible;
	/** Human friendly message about the above results. */
	msg?: MetricAnalysisInputMsg;
}

/**
 * Minimum sample size needed to meet the design specs.
 */
export type MetricAnalysisOutputTargetN = number | null;

/**
 * Whether or not there are enough available units to sample from to meet target_n.
 */
export type MetricAnalysisOutputSufficientN = boolean | null;

/**
 * If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change.
 */
export type MetricAnalysisOutputTargetPossible = number | null;

/**
 * If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change.
 */
export type MetricAnalysisOutputPctChangePossible = number | null;

/**
 * Human friendly message about the above results.
 */
export type MetricAnalysisOutputMsg = MetricAnalysisMessage | null;

/**
 * Describes analysis results of a single metric.
 */
export interface MetricAnalysisOutput {
	metric_spec: DesignSpecMetric;
	/** Minimum sample size needed to meet the design specs. */
	target_n?: MetricAnalysisOutputTargetN;
	/** Whether or not there are enough available units to sample from to meet target_n. */
	sufficient_n?: MetricAnalysisOutputSufficientN;
	/** If there is an insufficient sample size to meet the desired metric_target, we report what is possible given the available_n. This value is equivalent to the relative pct_change_possible. This is None when there is a sufficient sample size to detect the desired change. */
	target_possible?: MetricAnalysisOutputTargetPossible;
	/** If there is an insufficient sample size to meet the desired metric_pct_change, we report what is possible given the available_n. This value is equivalent to the absolute target_possible. This is None when there is a sufficient sample size to detect the desired change. */
	pct_change_possible?: MetricAnalysisOutputPctChangePossible;
	/** Human friendly message about the above results. */
	msg?: MetricAnalysisOutputMsg;
}

export type MetricAnalysisMessageValuesAnyOf = {
	[key: string]: number | number;
};

export type MetricAnalysisMessageValues =
	MetricAnalysisMessageValuesAnyOf | null;

/**
 * Describes interpretation of analysis results.
 */
export interface MetricAnalysisMessage {
	type: MetricAnalysisMessageType;
	/** Main analysis result stated in human-friendly English. */
	msg: string;
	/** Analysis result formatted as a template string with curly-braced {} named placeholders. Use with the dictionary of values to support localization of messages. */
	source_msg: string;
	values?: MetricAnalysisMessageValues;
}

/**
 * Classifies metric analysis results.
 */
export type MetricAnalysisMessageType =
	(typeof MetricAnalysisMessageType)[keyof typeof MetricAnalysisMessageType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MetricAnalysisMessageType = {
	sufficient: "sufficient",
	insufficient: "insufficient",
	no_baseline: "no baseline",
} as const;

/**
 * Classifies metrics by their value type.
 */
export type MetricType = (typeof MetricType)[keyof typeof MetricType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MetricType = {
	binary: "binary",
	numeric: "numeric",
} as const;

export interface OrganizationSummary {
	id: string;
	name: string;
}

export type ParticipantsConfig = SheetParticipantsRef | ParticipantsDef;

export type ParticipantsDefType =
	(typeof ParticipantsDefType)[keyof typeof ParticipantsDefType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ParticipantsDefType = {
	schema: "schema",
} as const;

export interface ParticipantsDef {
	/** Name of the table in the data warehouse */
	table_name: string;
	/** List of fields available in this table */
	fields: FieldDescriptor[];
	participant_type: string;
	type: ParticipantsDefType;
}

/**
 * Represents a single worksheet describing metadata about a type of Participant.
 */
export interface ParticipantsSchemaInput {
	/** Name of the table in the data warehouse */
	table_name: string;
	/** List of fields available in this table */
	fields: FieldDescriptor[];
}

/**
 * Represents a single worksheet describing metadata about a type of Participant.
 */
export interface ParticipantsSchemaOutput {
	/** Name of the table in the data warehouse */
	table_name: string;
	/** List of fields available in this table */
	fields: FieldDescriptor[];
}

export interface PowerRequest {
	design_spec: DesignSpec;
	audience_spec: AudienceSpecInput;
}

export interface PowerResponseInput {
	analyses: MetricAnalysisInput[];
}

export interface PowerResponseOutput {
	analyses: MetricAnalysisOutput[];
}

/**
 * Defines operators for filtering values.

INCLUDES matches when the value matches any of the provided values, including null if explicitly
specified. For CSV fields (i.e. experiment_ids), any value in the CSV that matches the provided
values will match, but nulls are unsupported. This is equivalent to NOT(EXCLUDES(values)).

EXCLUDES matches when the value does not match any of the provided values, including null if
explicitly specified. If null is not explicitly excluded, we include nulls in the result.  CSV
fields (i.e. experiment_ids), the match will fail if any of the provided values are present
in the value, but nulls are unsupported.

BETWEEN matches when the value is between the two provided values (inclusive). Not allowed for CSV fields.
 */
export type Relation = (typeof Relation)[keyof typeof Relation];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Relation = {
	includes: "includes",
	excludes: "excludes",
	between: "between",
} as const;

export type RemoteDatabaseConfigWebhookConfig = WebhookConfig | null;

export type RemoteDatabaseConfigType =
	(typeof RemoteDatabaseConfigType)[keyof typeof RemoteDatabaseConfigType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RemoteDatabaseConfigType = {
	remote: "remote",
} as const;

/**
 * RemoteDatabaseConfig defines a configuration for a remote data warehouse.
 */
export interface RemoteDatabaseConfig {
	participants: ParticipantsConfig[];
	webhook_config?: RemoteDatabaseConfigWebhookConfig;
	type: RemoteDatabaseConfigType;
	dwh: DwhOutput;
}

export type SheetParticipantsRefType =
	(typeof SheetParticipantsRefType)[keyof typeof SheetParticipantsRefType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SheetParticipantsRefType = {
	sheet: "sheet",
} as const;

export interface SheetParticipantsRef {
	participant_type: string;
	type: SheetParticipantsRefType;
	table_name: string;
	sheet: SheetRef;
}

export interface SheetRef {
	url: string;
	worksheet: string;
}

export type SqliteLocalConfigType =
	(typeof SqliteLocalConfigType)[keyof typeof SqliteLocalConfigType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SqliteLocalConfigType = {
	sqlite_local: "sqlite_local",
} as const;

export interface SqliteLocalConfig {
	participants: ParticipantsConfig[];
	type: SqliteLocalConfigType;
	sqlite_filename: string;
}

export type StrataStrataValue = string | null;

/**
 * Describes stratification for an experiment participant.
 */
export interface Strata {
	/** @pattern ^[a-zA-Z_][a-zA-Z0-9_]*$ */
	field_name: string;
	strata_value?: StrataStrataValue;
}

export interface TokenInfo {
	email: string;
	iss: string;
	sub: string;
	hd: string;
}

export type UpdateDatasourceRequestName = string | null;

export type UpdateDatasourceRequestDwh = DwhInput | null;

export interface UpdateDatasourceRequest {
	name?: UpdateDatasourceRequestName;
	dwh?: UpdateDatasourceRequestDwh;
}

export type UpdateOrganizationRequestName = string | null;

export interface UpdateOrganizationRequest {
	name?: UpdateOrganizationRequestName;
}

export type UpdateParticipantsTypeRequestParticipantType = string | null;

export type UpdateParticipantsTypeRequestTableName = string | null;

export type UpdateParticipantsTypeRequestFields = FieldDescriptor[] | null;

export interface UpdateParticipantsTypeRequest {
	participant_type?: UpdateParticipantsTypeRequestParticipantType;
	table_name?: UpdateParticipantsTypeRequestTableName;
	fields?: UpdateParticipantsTypeRequestFields;
}

export interface UpdateParticipantsTypeResponse {
	participant_type: string;
	table_name: string;
	fields: FieldDescriptor[];
}

export interface UserSummary {
	id: string;
	email: string;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
	loc: ValidationErrorLocItem[];
	msg: string;
	type: string;
}

export type WebhookActionsCommit = WebhookUrl | null;

export type WebhookActionsAssignmentFile = WebhookUrl | null;

export type WebhookActionsUpdateTimestamps = WebhookUrl | null;

export type WebhookActionsUpdateDescription = WebhookUrl | null;

/**
 * The set of supported actions that trigger a user callback.
 */
export interface WebhookActions {
	commit?: WebhookActionsCommit;
	assignment_file?: WebhookActionsAssignmentFile;
	update_timestamps?: WebhookActionsUpdateTimestamps;
	update_description?: WebhookActionsUpdateDescription;
}

export type WebhookCommonHeadersAuthorization = string | null;

/**
 * Enumerates supported headers to attach to all webhook requests.
 */
export interface WebhookCommonHeaders {
	authorization: WebhookCommonHeadersAuthorization;
}

/**
 * Top-level configuration object for user-defined webhooks.
 */
export interface WebhookConfig {
	actions: WebhookActions;
	common_headers: WebhookCommonHeaders;
}

/**
 * Generic wrapper around upstream webhook responses.
 */
export interface WebhookResponse {
	/** HTTP status code we received from the webhook's server. */
	status_code: number;
	/** HTTP body (if any) we received from the webhook's server. May be empty. */
	body: string;
}

export type WebhookUpdateCommitRequestUpdateJson =
	| WebhookUpdateTimestampsRequest
	| WebhookUpdateDescriptionRequest;

/**
 * Request structure for supported types of experiment updates.
 */
export interface WebhookUpdateCommitRequest {
	update_json: WebhookUpdateCommitRequestUpdateJson;
}

/**
 * Describes how to update an experiment description and/or the names of its arms.
 */
export interface WebhookUpdateDescriptionRequest {
	/** ID of the experiment to update. */
	experiment_id: string;
	/**
	 * New experiment name.
	 * @minLength 1
	 */
	experiment_name: string;
	/**
	 * New experiment description.
	 * @minLength 1
	 */
	description: string;
	/** All arms as saved in the original DesignSpec must be present here, even if you don't intend to change the arm_name */
	arms: ArmUpdate[];
}

/**
 * Describes how to update an experiment's start and/or end dates.
 */
export interface WebhookUpdateTimestampsRequest {
	/** ID of the experiment to update. */
	experiment_id: string;
	/** New or the same start date to update with. */
	start_date: string;
	/** New or the same end date to update with. Must be later than start_date. */
	end_date: string;
}

/**
 * Represents a url and HTTP method to use with it.
 */
export interface WebhookUrl {
	method: HttpMethodTypes;
	url: string;
}

export type GetStrataParams = {
	/**
	 * Unit of analysis for experiment.
	 */
	participant_type: string;
	/**
	 * Refresh the cache.
	 */
	refresh?: boolean;
};

export type GetFiltersParams = {
	/**
	 * Unit of analysis for experiment.
	 */
	participant_type: string;
	/**
	 * Refresh the cache.
	 */
	refresh?: boolean;
};

export type GetMetricsParams = {
	/**
	 * Unit of analysis for experiment.
	 */
	participant_type: string;
	/**
	 * Refresh the cache.
	 */
	refresh?: boolean;
};

export type PowercheckParams = {
	/**
	 * Refresh the cache.
	 */
	refresh?: boolean;
};

export type AssignTreatmentParams = {
	/**
	 * Number of participants to assign.
	 */
	chosen_n: number;
	/**
	 * Refresh the cache.
	 */
	refresh?: boolean;
};

export type CreateExperimentWithAssignmentSlParams = {
	/**
	 * Number of participants to assign.
	 */
	chosen_n: number;
	/**
	 * Refresh the cache.
	 */
	refresh?: boolean;
};

export type AssignmentFileParams = {
	/**
	 * ID of the experiment whose assignments we wish to fetch.
	 */
	experiment_id: string;
};

export type CommitExperimentParams = {
	user_id: string;
};

export type UpdateExperimentParams = {
	/**
	 * The type of experiment metadata update to perform
	 */
	update_type: UpdateExperimentUpdateType;
};

export type UpdateExperimentUpdateType =
	(typeof UpdateExperimentUpdateType)[keyof typeof UpdateExperimentUpdateType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateExperimentUpdateType = {
	timestamps: "timestamps",
	description: "description",
} as const;

export type AuthCallbackParams = {
	code: string;
	code_verifier: string;
};

export type InspectDatasourceParams = {
	/**
	 * Refresh the cache.
	 */
	refresh?: boolean;
};

export type InspectTableInDatasourceParams = {
	/**
	 * Refresh the cache.
	 */
	refresh?: boolean;
};

export type InspectParticipantTypesParams = {
	/**
	 * Refresh the cache.
	 */
	refresh?: boolean;
};

export type CreateExperimentWithAssignmentParams = {
	/**
	 * Number of participants to assign.
	 */
	chosen_n: number;
};
