/**
 * Generated by orval v7.6.0 üç∫
 * Do not edit manually.
 * xngin: Experiments API
 * OpenAPI spec version: 0.9.0
 */
import useSwr from "swr";
import type { Arguments, Key, SWRConfiguration } from "swr";

import useSWRMutation from "swr/mutation";
import type { SWRMutationConfiguration } from "swr/mutation";

import type {
	CreateExperimentRequest,
	CreateExperimentWithAssignmentResponse,
	CreateExperimentWithAssignmentSlParams,
	GetExperimentAssigmentsResponse,
	GetExperimentResponse,
	HTTPValidationError,
	ListExperimentsResponse,
} from "./methods.schemas";

import { orvalFetch } from "../services/orval-fetch";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Creates an experiment and saves its assignments to the database.
 * @summary Create a pending experiment and save its assignments to the database. User will still need to /experiments/<id>/commit the experiment after reviewing assignment balance summary.
 */
export type createExperimentWithAssignmentSlResponse200 = {
	data: CreateExperimentWithAssignmentResponse;
	status: 200;
};

export type createExperimentWithAssignmentSlResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type createExperimentWithAssignmentSlResponseComposite =
	| createExperimentWithAssignmentSlResponse200
	| createExperimentWithAssignmentSlResponse422;

export type createExperimentWithAssignmentSlResponse =
	createExperimentWithAssignmentSlResponseComposite & {
		headers: Headers;
	};

export const getCreateExperimentWithAssignmentSlUrl = (
	params: CreateExperimentWithAssignmentSlParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/experiments/with-assignment?${stringifiedParams}`
		: `/v1/experiments/with-assignment`;
};

export const createExperimentWithAssignmentSl = async (
	createExperimentRequest: CreateExperimentRequest,
	params: CreateExperimentWithAssignmentSlParams,
	options?: RequestInit,
): Promise<createExperimentWithAssignmentSlResponse> => {
	return orvalFetch<createExperimentWithAssignmentSlResponse>(
		getCreateExperimentWithAssignmentSlUrl(params),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(createExperimentRequest),
		},
	);
};

export const getCreateExperimentWithAssignmentSlMutationFetcher = (
	params: CreateExperimentWithAssignmentSlParams,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		{ arg }: { arg: CreateExperimentRequest },
	): Promise<createExperimentWithAssignmentSlResponse> => {
		return createExperimentWithAssignmentSl(arg, params, options);
	};
};
export const getCreateExperimentWithAssignmentSlMutationKey = (
	params: CreateExperimentWithAssignmentSlParams,
) => [`/v1/experiments/with-assignment`, ...(params ? [params] : [])] as const;

export type CreateExperimentWithAssignmentSlMutationResult = NonNullable<
	Awaited<ReturnType<typeof createExperimentWithAssignmentSl>>
>;
export type CreateExperimentWithAssignmentSlMutationError = HTTPValidationError;

/**
 * @summary Create a pending experiment and save its assignments to the database. User will still need to /experiments/<id>/commit the experiment after reviewing assignment balance summary.
 */
export const useCreateExperimentWithAssignmentSl = <
	TError = HTTPValidationError,
>(
	params: CreateExperimentWithAssignmentSlParams,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof createExperimentWithAssignmentSl>>,
			TError,
			Key,
			CreateExperimentRequest,
			Awaited<ReturnType<typeof createExperimentWithAssignmentSl>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ??
		getCreateExperimentWithAssignmentSlMutationKey(params);
	const swrFn = getCreateExperimentWithAssignmentSlMutationFetcher(
		params,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Marks any ASSIGNED experiment as COMMITTED.
 */
export type commitExperimentSlResponse200 = {
	data: unknown;
	status: 200;
};

export type commitExperimentSlResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type commitExperimentSlResponseComposite =
	| commitExperimentSlResponse200
	| commitExperimentSlResponse422;

export type commitExperimentSlResponse = commitExperimentSlResponseComposite & {
	headers: Headers;
};

export const getCommitExperimentSlUrl = (experimentId: string) => {
	return `/v1/experiments/${experimentId}/commit`;
};

export const commitExperimentSl = async (
	experimentId: string,
	options?: RequestInit,
): Promise<commitExperimentSlResponse> => {
	return orvalFetch<commitExperimentSlResponse>(
		getCommitExperimentSlUrl(experimentId),
		{
			...options,
			method: "POST",
		},
	);
};

export const getCommitExperimentSlMutationFetcher = (
	experimentId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		__: { arg: Arguments },
	): Promise<commitExperimentSlResponse> => {
		return commitExperimentSl(experimentId, options);
	};
};
export const getCommitExperimentSlMutationKey = (experimentId: string) =>
	[`/v1/experiments/${experimentId}/commit`] as const;

export type CommitExperimentSlMutationResult = NonNullable<
	Awaited<ReturnType<typeof commitExperimentSl>>
>;
export type CommitExperimentSlMutationError = HTTPValidationError;

/**
 * @summary Marks any ASSIGNED experiment as COMMITTED.
 */
export const useCommitExperimentSl = <TError = HTTPValidationError>(
	experimentId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof commitExperimentSl>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof commitExperimentSl>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getCommitExperimentSlMutationKey(experimentId);
	const swrFn = getCommitExperimentSlMutationFetcher(
		experimentId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Marks any DESIGNING or ASSIGNED experiment as ABANDONED.
 */
export type abandonExperimentSlResponse200 = {
	data: unknown;
	status: 200;
};

export type abandonExperimentSlResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type abandonExperimentSlResponseComposite =
	| abandonExperimentSlResponse200
	| abandonExperimentSlResponse422;

export type abandonExperimentSlResponse =
	abandonExperimentSlResponseComposite & {
		headers: Headers;
	};

export const getAbandonExperimentSlUrl = (experimentId: string) => {
	return `/v1/experiments/${experimentId}/abandon`;
};

export const abandonExperimentSl = async (
	experimentId: string,
	options?: RequestInit,
): Promise<abandonExperimentSlResponse> => {
	return orvalFetch<abandonExperimentSlResponse>(
		getAbandonExperimentSlUrl(experimentId),
		{
			...options,
			method: "POST",
		},
	);
};

export const getAbandonExperimentSlMutationFetcher = (
	experimentId: string,
	options?: SecondParameter<typeof orvalFetch>,
) => {
	return (
		_: Key,
		__: { arg: Arguments },
	): Promise<abandonExperimentSlResponse> => {
		return abandonExperimentSl(experimentId, options);
	};
};
export const getAbandonExperimentSlMutationKey = (experimentId: string) =>
	[`/v1/experiments/${experimentId}/abandon`] as const;

export type AbandonExperimentSlMutationResult = NonNullable<
	Awaited<ReturnType<typeof abandonExperimentSl>>
>;
export type AbandonExperimentSlMutationError = HTTPValidationError;

/**
 * @summary Marks any DESIGNING or ASSIGNED experiment as ABANDONED.
 */
export const useAbandonExperimentSl = <TError = HTTPValidationError>(
	experimentId: string,
	options?: {
		swr?: SWRMutationConfiguration<
			Awaited<ReturnType<typeof abandonExperimentSl>>,
			TError,
			Key,
			Arguments,
			Awaited<ReturnType<typeof abandonExperimentSl>>
		> & { swrKey?: string };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const swrKey =
		swrOptions?.swrKey ?? getAbandonExperimentSlMutationKey(experimentId);
	const swrFn = getAbandonExperimentSlMutationFetcher(
		experimentId,
		requestOptions,
	);

	const query = useSWRMutation(swrKey, swrFn, swrOptions);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Fetch experiment meta data (design & assignment specs) for the given id.
 */
export type listExperimentsSlResponse200 = {
	data: ListExperimentsResponse;
	status: 200;
};

export type listExperimentsSlResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type listExperimentsSlResponseComposite =
	| listExperimentsSlResponse200
	| listExperimentsSlResponse422;

export type listExperimentsSlResponse = listExperimentsSlResponseComposite & {
	headers: Headers;
};

export const getListExperimentsSlUrl = () => {
	return `/v1/experiments`;
};

export const listExperimentsSl = async (
	options?: RequestInit,
): Promise<listExperimentsSlResponse> => {
	return orvalFetch<listExperimentsSlResponse>(getListExperimentsSlUrl(), {
		...options,
		method: "GET",
	});
};

export const getListExperimentsSlKey = () => [`/v1/experiments`] as const;

export type ListExperimentsSlQueryResult = NonNullable<
	Awaited<ReturnType<typeof listExperimentsSl>>
>;
export type ListExperimentsSlQueryError = HTTPValidationError;

/**
 * @summary Fetch experiment meta data (design & assignment specs) for the given id.
 */
export const useListExperimentsSl = <TError = HTTPValidationError>(options?: {
	swr?: SWRConfiguration<
		Awaited<ReturnType<typeof listExperimentsSl>>,
		TError
	> & { swrKey?: Key; enabled?: boolean };
	request?: SecondParameter<typeof orvalFetch>;
}) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getListExperimentsSlKey() : null));
	const swrFn = () => listExperimentsSl(requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Fetch experiment meta data (design & assignment specs) for the given id.
 */
export type getExperimentSlResponse200 = {
	data: GetExperimentResponse;
	status: 200;
};

export type getExperimentSlResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getExperimentSlResponseComposite =
	| getExperimentSlResponse200
	| getExperimentSlResponse422;

export type getExperimentSlResponse = getExperimentSlResponseComposite & {
	headers: Headers;
};

export const getGetExperimentSlUrl = (experimentId: string) => {
	return `/v1/experiments/${experimentId}`;
};

export const getExperimentSl = async (
	experimentId: string,
	options?: RequestInit,
): Promise<getExperimentSlResponse> => {
	return orvalFetch<getExperimentSlResponse>(
		getGetExperimentSlUrl(experimentId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetExperimentSlKey = (experimentId: string) =>
	[`/v1/experiments/${experimentId}`] as const;

export type GetExperimentSlQueryResult = NonNullable<
	Awaited<ReturnType<typeof getExperimentSl>>
>;
export type GetExperimentSlQueryError = HTTPValidationError;

/**
 * @summary Fetch experiment meta data (design & assignment specs) for the given id.
 */
export const useGetExperimentSl = <TError = HTTPValidationError>(
	experimentId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getExperimentSl>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!experimentId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getGetExperimentSlKey(experimentId) : null));
	const swrFn = () => getExperimentSl(experimentId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
/**
 * @summary Fetch list of participant=>arm assignments for the given experiment id.
 */
export type getExperimentAssignmentsSlResponse200 = {
	data: GetExperimentAssigmentsResponse;
	status: 200;
};

export type getExperimentAssignmentsSlResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getExperimentAssignmentsSlResponseComposite =
	| getExperimentAssignmentsSlResponse200
	| getExperimentAssignmentsSlResponse422;

export type getExperimentAssignmentsSlResponse =
	getExperimentAssignmentsSlResponseComposite & {
		headers: Headers;
	};

export const getGetExperimentAssignmentsSlUrl = (experimentId: string) => {
	return `/v1/experiments/${experimentId}/assignments`;
};

export const getExperimentAssignmentsSl = async (
	experimentId: string,
	options?: RequestInit,
): Promise<getExperimentAssignmentsSlResponse> => {
	return orvalFetch<getExperimentAssignmentsSlResponse>(
		getGetExperimentAssignmentsSlUrl(experimentId),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetExperimentAssignmentsSlKey = (experimentId: string) =>
	[`/v1/experiments/${experimentId}/assignments`] as const;

export type GetExperimentAssignmentsSlQueryResult = NonNullable<
	Awaited<ReturnType<typeof getExperimentAssignmentsSl>>
>;
export type GetExperimentAssignmentsSlQueryError = HTTPValidationError;

/**
 * @summary Fetch list of participant=>arm assignments for the given experiment id.
 */
export const useGetExperimentAssignmentsSl = <TError = HTTPValidationError>(
	experimentId: string,
	options?: {
		swr?: SWRConfiguration<
			Awaited<ReturnType<typeof getExperimentAssignmentsSl>>,
			TError
		> & { swrKey?: Key; enabled?: boolean };
		request?: SecondParameter<typeof orvalFetch>;
	},
) => {
	const { swr: swrOptions, request: requestOptions } = options ?? {};

	const isEnabled = swrOptions?.enabled !== false && !!experimentId;
	const swrKey =
		swrOptions?.swrKey ??
		(() => (isEnabled ? getGetExperimentAssignmentsSlKey(experimentId) : null));
	const swrFn = () => getExperimentAssignmentsSl(experimentId, requestOptions);

	const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
		swrKey,
		swrFn,
		swrOptions,
	);

	return {
		swrKey,
		...query,
	};
};
